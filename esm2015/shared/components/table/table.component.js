import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, HostBinding, Input, isDevMode, } from '@angular/core';
/**
 * The table component provides a generic DOM structure based on the `dataset` input.
 * The `Table` dataset contains a type, table structure and table data.
 *
 * The table component only supports horizontal table structure.
 *
 * The implementation is fairly "dumb" and only provides the following features:
 * - Use outlet for table headers (`<th>`) and cells (`<td>`).
 * - Localizing table headers, using the `I18nModule`.
 * - Add CSS classes on each cell to
 *
 * Al features are optional.
 *
 * By default, the headers and columns are rendered with an outlet template. The template
 * reference is generated by concatenating the table `type` and table header `key`.
 * The following snippet shows an outlet generated for a table header, for the table type
 * "cost-center" with a label "name":
 *
 * ```
 * <th>
 *   <template cxOutlet="tbl.cost-center.header.name">
 *     [localized label is generated here]
 *   </template>
 * </th>
 * ```
 *
 * Similarly, the `<td>` is generated with the outlet template reference `tbl.cost-center.data.name`.
 *
 * This allows smart components to further customize the table rendering. More over, customers can
 * customize the header and data by using the generated outlets.
 */
let TableComponent = class TableComponent {
    set dataset(dataset) {
        this._dataset = dataset;
        this.addTableDebugInfo();
    }
    get dataset() {
        return this._dataset;
    }
    /**
     * Returns the configured data value by the label key.
     * If there's no headerKey available, or no corresponding value, the
     * first value in the data row is returned.
     */
    getDataValue(dataRow, headerKey, index) {
        return dataRow[headerKey] || Object.values(dataRow)[index];
    }
    /**
     * Generates the table type into the UI in devMode, so that developers
     * can easily get the notion of the table type.
     */
    addTableDebugInfo() {
        var _a, _b;
        if (isDevMode) {
            this.tableType = (_b = (_a = this.dataset) === null || _a === void 0 ? void 0 : _a.structure) === null || _b === void 0 ? void 0 : _b.type;
        }
    }
};
__decorate([
    HostBinding('attr.__cx-table-type')
], TableComponent.prototype, "tableType", void 0);
__decorate([
    Input()
], TableComponent.prototype, "dataset", null);
TableComponent = __decorate([
    Component({
        selector: 'cx-table',
        template: "<table *ngIf=\"dataset?.structure as structure\">\n  <thead *ngIf=\"!structure.hideHeader\">\n    <tr>\n      <th\n        scope=\"col\"\n        *ngFor=\"let header of structure.headers; let i = index\"\n        [class]=\"header.key\"\n      >\n        <!-- render an outlet for each column header -->\n        <ng-template\n          [cxOutlet]=\"\n            'table.' + structure.type + '.header.' + (header.key || i)\n          \"\n          [cxOutletContext]=\"header\"\n        >\n          <!-- Render the label by default, fallback to localize the label by it's key -->\n          {{\n            header.label || (structure.type + '.' + header.key | cxTranslate)\n          }}\n        </ng-template>\n      </th>\n    </tr>\n  </thead>\n\n  <tr *ngFor=\"let row of dataset.data$ | async\">\n    <td *ngFor=\"let col of structure.headers; let i = index\" [class]=\"col.key\">\n      <!-- render an outlet for each cell -->\n      <ng-template\n        [cxOutlet]=\"'table.' + structure.type + '.data.' + (col.key || i)\"\n        [cxOutletContext]=\"row\"\n      >\n        {{ getDataValue(row, col.key, i) }}\n      </ng-template>\n    </td>\n  </tr>\n</table>\n",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], TableComponent);
export { TableComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9zdG9yZWZyb250LyIsInNvdXJjZXMiOlsic2hhcmVkL2NvbXBvbmVudHMvdGFibGUvdGFibGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxXQUFXLEVBQ1gsS0FBSyxFQUNMLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUd2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOEJHO0FBTUgsSUFBYSxjQUFjLEdBQTNCLE1BQWEsY0FBYztJQUt6QixJQUFJLE9BQU8sQ0FBQyxPQUFjO1FBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRCxJQUFJLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxZQUFZLENBQUMsT0FBWSxFQUFFLFNBQWlCLEVBQUUsS0FBYTtRQUN6RCxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRDs7O09BR0c7SUFDTyxpQkFBaUI7O1FBQ3pCLElBQUksU0FBUyxFQUFFO1lBQ2IsSUFBSSxDQUFDLFNBQVMsZUFBRyxJQUFJLENBQUMsT0FBTywwQ0FBRSxTQUFTLDBDQUFFLElBQUksQ0FBQztTQUNoRDtJQUNILENBQUM7Q0FDRixDQUFBO0FBL0JzQztJQUFwQyxXQUFXLENBQUMsc0JBQXNCLENBQUM7aURBQW1CO0FBSXZEO0lBREMsS0FBSyxFQUFFOzZDQUlQO0FBUlUsY0FBYztJQUwxQixTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsVUFBVTtRQUNwQixncUNBQXFDO1FBQ3JDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO0tBQ2hELENBQUM7R0FDVyxjQUFjLENBZ0MxQjtTQWhDWSxjQUFjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgSG9zdEJpbmRpbmcsXG4gIElucHV0LFxuICBpc0Rldk1vZGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlLm1vZGVsJztcblxuLyoqXG4gKiBUaGUgdGFibGUgY29tcG9uZW50IHByb3ZpZGVzIGEgZ2VuZXJpYyBET00gc3RydWN0dXJlIGJhc2VkIG9uIHRoZSBgZGF0YXNldGAgaW5wdXQuXG4gKiBUaGUgYFRhYmxlYCBkYXRhc2V0IGNvbnRhaW5zIGEgdHlwZSwgdGFibGUgc3RydWN0dXJlIGFuZCB0YWJsZSBkYXRhLlxuICpcbiAqIFRoZSB0YWJsZSBjb21wb25lbnQgb25seSBzdXBwb3J0cyBob3Jpem9udGFsIHRhYmxlIHN0cnVjdHVyZS5cbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgZmFpcmx5IFwiZHVtYlwiIGFuZCBvbmx5IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXM6XG4gKiAtIFVzZSBvdXRsZXQgZm9yIHRhYmxlIGhlYWRlcnMgKGA8dGg+YCkgYW5kIGNlbGxzIChgPHRkPmApLlxuICogLSBMb2NhbGl6aW5nIHRhYmxlIGhlYWRlcnMsIHVzaW5nIHRoZSBgSTE4bk1vZHVsZWAuXG4gKiAtIEFkZCBDU1MgY2xhc3NlcyBvbiBlYWNoIGNlbGwgdG9cbiAqXG4gKiBBbCBmZWF0dXJlcyBhcmUgb3B0aW9uYWwuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIGhlYWRlcnMgYW5kIGNvbHVtbnMgYXJlIHJlbmRlcmVkIHdpdGggYW4gb3V0bGV0IHRlbXBsYXRlLiBUaGUgdGVtcGxhdGVcbiAqIHJlZmVyZW5jZSBpcyBnZW5lcmF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgdGFibGUgYHR5cGVgIGFuZCB0YWJsZSBoZWFkZXIgYGtleWAuXG4gKiBUaGUgZm9sbG93aW5nIHNuaXBwZXQgc2hvd3MgYW4gb3V0bGV0IGdlbmVyYXRlZCBmb3IgYSB0YWJsZSBoZWFkZXIsIGZvciB0aGUgdGFibGUgdHlwZVxuICogXCJjb3N0LWNlbnRlclwiIHdpdGggYSBsYWJlbCBcIm5hbWVcIjpcbiAqXG4gKiBgYGBcbiAqIDx0aD5cbiAqICAgPHRlbXBsYXRlIGN4T3V0bGV0PVwidGJsLmNvc3QtY2VudGVyLmhlYWRlci5uYW1lXCI+XG4gKiAgICAgW2xvY2FsaXplZCBsYWJlbCBpcyBnZW5lcmF0ZWQgaGVyZV1cbiAqICAgPC90ZW1wbGF0ZT5cbiAqIDwvdGg+XG4gKiBgYGBcbiAqXG4gKiBTaW1pbGFybHksIHRoZSBgPHRkPmAgaXMgZ2VuZXJhdGVkIHdpdGggdGhlIG91dGxldCB0ZW1wbGF0ZSByZWZlcmVuY2UgYHRibC5jb3N0LWNlbnRlci5kYXRhLm5hbWVgLlxuICpcbiAqIFRoaXMgYWxsb3dzIHNtYXJ0IGNvbXBvbmVudHMgdG8gZnVydGhlciBjdXN0b21pemUgdGhlIHRhYmxlIHJlbmRlcmluZy4gTW9yZSBvdmVyLCBjdXN0b21lcnMgY2FuXG4gKiBjdXN0b21pemUgdGhlIGhlYWRlciBhbmQgZGF0YSBieSB1c2luZyB0aGUgZ2VuZXJhdGVkIG91dGxldHMuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2N4LXRhYmxlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3RhYmxlLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlQ29tcG9uZW50IHtcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLl9fY3gtdGFibGUtdHlwZScpIHRhYmxlVHlwZTogc3RyaW5nO1xuXG4gIHByb3RlY3RlZCBfZGF0YXNldDogVGFibGU7XG4gIEBJbnB1dCgpXG4gIHNldCBkYXRhc2V0KGRhdGFzZXQ6IFRhYmxlKSB7XG4gICAgdGhpcy5fZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgdGhpcy5hZGRUYWJsZURlYnVnSW5mbygpO1xuICB9XG5cbiAgZ2V0IGRhdGFzZXQoKTogVGFibGUge1xuICAgIHJldHVybiB0aGlzLl9kYXRhc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbmZpZ3VyZWQgZGF0YSB2YWx1ZSBieSB0aGUgbGFiZWwga2V5LlxuICAgKiBJZiB0aGVyZSdzIG5vIGhlYWRlcktleSBhdmFpbGFibGUsIG9yIG5vIGNvcnJlc3BvbmRpbmcgdmFsdWUsIHRoZVxuICAgKiBmaXJzdCB2YWx1ZSBpbiB0aGUgZGF0YSByb3cgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXREYXRhVmFsdWUoZGF0YVJvdzogYW55LCBoZWFkZXJLZXk6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGRhdGFSb3dbaGVhZGVyS2V5XSB8fCBPYmplY3QudmFsdWVzKGRhdGFSb3cpW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHRhYmxlIHR5cGUgaW50byB0aGUgVUkgaW4gZGV2TW9kZSwgc28gdGhhdCBkZXZlbG9wZXJzXG4gICAqIGNhbiBlYXNpbHkgZ2V0IHRoZSBub3Rpb24gb2YgdGhlIHRhYmxlIHR5cGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWRkVGFibGVEZWJ1Z0luZm8oKSB7XG4gICAgaWYgKGlzRGV2TW9kZSkge1xuICAgICAgdGhpcy50YWJsZVR5cGUgPSB0aGlzLmRhdGFzZXQ/LnN0cnVjdHVyZT8udHlwZTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==