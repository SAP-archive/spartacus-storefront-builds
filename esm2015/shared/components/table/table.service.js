import { __decorate } from "tslib";
import { Injectable, isDevMode } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { BreakpointService } from '../../../layout/breakpoint/breakpoint.service';
import { TableConfig } from './config/table.config';
import * as i0 from "@angular/core";
import * as i1 from "../../../layout/breakpoint/breakpoint.service";
import * as i2 from "./config/table.config";
/**
 * Responsive table service.
 *
 * The `TableService` is used to generate a `TableStructure` based on configuration. The table
 * structure configuration allows for breakpoint specific configuration, so that the table
 * experience can be differentiated various screen sizes.
 *
 * The table structure configuration is driven by a table type. The various supported
 * table types are exposed in feature libraries.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data or randomly (in case no data is passed in) by
 * generating 5 headers. In case of a generated header, we warn the developer in devMode that
 * there is no configuration available.
 */
let TableService = class TableService {
    constructor(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
    }
    /**
     * Builds the table structure. The table structure can be created by the help of
     * the `tableType`. The `tableType` can be used in the configuration `TableConfig`,
     * so that the table headers can be defined.
     */
    buildStructure(tableType, data$) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType);
        }
        else {
            if (data$) {
                return this.buildStructureFromData(tableType, data$);
            }
            else {
                return this.buildRandomStructure(tableType);
            }
        }
    }
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    buildStructureFromConfig(type) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => (Object.assign(Object.assign({}, this.getTableConfig(type, breakpoint)), { type }))));
    }
    /**
     * This method generates a table structure by the help of the first data row.
     */
    buildStructureFromData(type, data$) {
        this.warn(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
        return data$.pipe(map((data) => {
            const headers = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map((key) => ({
                key,
                label: key,
            }));
            return {
                type: type,
                headers,
            };
        }));
    }
    /**
     * As a last resort, the table structure is randomly created. We add 5 unknown headers
     * and use the `hideHeader` to avoid the unknown headers to be rendered.
     */
    buildRandomStructure(type) {
        this.warn(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
        return of({
            type,
            headers: [
                { key: 'unknown' },
                { key: 'unknown' },
                { key: 'unknown' },
                { key: 'unknown' },
                { key: 'unknown' },
            ],
            hideHeader: true,
        });
    }
    /**
     * Finds the best applicable table configuration for the given type
     * and breakpoint. If there is no configuration available for the breakpoint,
     * the best match will be returned, using mobile first approach.
     *
     * If there is no match for any breakpoint, the fallback is a configuration
     * without the notion of a breakpoint. Otherwise we fallback to the first
     * available config.
     */
    getTableConfig(type, breakpoint) {
        const tableConfig = this.config.table[type];
        // find all relevant breakpoints
        const current = this.breakpointService.breakpoints.indexOf(breakpoint);
        const relevant = this.breakpointService.breakpoints
            .slice(0, current + 1)
            .reverse();
        const bestMatch = relevant.find((br) => !!tableConfig.find((structure) => structure.breakpoint === br));
        return bestMatch
            ? tableConfig.find((config) => config.breakpoint === bestMatch)
            : tableConfig.find((structure) => !structure.breakpoint) ||
                tableConfig[0];
    }
    hasTableConfig(tableType) {
        var _a;
        return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
    }
    /**
     * Prints a convenient message in the console to increase developer experience.
     */
    warn(message) {
        if (isDevMode) {
            console.warn(message);
        }
    }
};
TableService.ctorParameters = () => [
    { type: BreakpointService },
    { type: TableConfig }
];
TableService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TableService_Factory() { return new TableService(i0.ɵɵinject(i1.BreakpointService), i0.ɵɵinject(i2.TableConfig)); }, token: TableService, providedIn: "root" });
TableService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], TableService);
export { TableService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbInNoYXJlZC9jb21wb25lbnRzL3RhYmxlL3RhYmxlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXRELE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLCtDQUErQyxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7OztBQUdwRDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUlILElBQWEsWUFBWSxHQUF6QixNQUFhLFlBQVk7SUFDdkIsWUFDWSxpQkFBb0MsRUFDcEMsTUFBbUI7UUFEbkIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxXQUFNLEdBQU4sTUFBTSxDQUFhO0lBQzVCLENBQUM7SUFFSjs7OztPQUlHO0lBQ0gsY0FBYyxDQUNaLFNBQWlCLEVBQ2pCLEtBQXVCO1FBRXZCLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNsQyxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNqRDthQUFNO1lBQ0wsSUFBSSxLQUFLLEVBQUU7Z0JBQ1QsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3REO2lCQUFNO2dCQUNMLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQzdDO1NBQ0Y7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08sd0JBQXdCLENBQUMsSUFBWTtRQUM3QyxPQUFPLElB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Q2xCLElBQUksU0FBUyxFQUFFO1lBQ2IsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN2QjtJQUNILENBQUM7Q0FDRixDQUFBOztZQTlIZ0MsaUJBQWlCO1lBQzVCLFdBQVc7OztBQUhwQixZQUFZO0lBSHhCLFVBQVUsQ0FBQztRQUNWLFVBQVUsRUFBRSxNQUFNO0tBQ25CLENBQUM7R0FDVyxZQUFZLENBZ0l4QjtTQWhJWSxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgaXNEZXZNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCUkVBS1BPSU5UIH0gZnJvbSAnLi4vLi4vLi4vbGF5b3V0L2NvbmZpZy9sYXlvdXQtY29uZmlnJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBCcmVha3BvaW50U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2xheW91dC9icmVha3BvaW50L2JyZWFrcG9pbnQuc2VydmljZSc7XG5pbXBvcnQgeyBUYWJsZUNvbmZpZyB9IGZyb20gJy4vY29uZmlnL3RhYmxlLmNvbmZpZyc7XG5pbXBvcnQgeyBUYWJsZVN0cnVjdHVyZSwgVGFibGVTdHJ1Y3R1cmVDb25maWd1cmF0aW9uIH0gZnJvbSAnLi90YWJsZS5tb2RlbCc7XG5cbi8qKlxuICogUmVzcG9uc2l2ZSB0YWJsZSBzZXJ2aWNlLlxuICpcbiAqIFRoZSBgVGFibGVTZXJ2aWNlYCBpcyB1c2VkIHRvIGdlbmVyYXRlIGEgYFRhYmxlU3RydWN0dXJlYCBiYXNlZCBvbiBjb25maWd1cmF0aW9uLiBUaGUgdGFibGVcbiAqIHN0cnVjdHVyZSBjb25maWd1cmF0aW9uIGFsbG93cyBmb3IgYnJlYWtwb2ludCBzcGVjaWZpYyBjb25maWd1cmF0aW9uLCBzbyB0aGF0IHRoZSB0YWJsZVxuICogZXhwZXJpZW5jZSBjYW4gYmUgZGlmZmVyZW50aWF0ZWQgdmFyaW91cyBzY3JlZW4gc2l6ZXMuXG4gKlxuICogVGhlIHRhYmxlIHN0cnVjdHVyZSBjb25maWd1cmF0aW9uIGlzIGRyaXZlbiBieSBhIHRhYmxlIHR5cGUuIFRoZSB2YXJpb3VzIHN1cHBvcnRlZFxuICogdGFibGUgdHlwZXMgYXJlIGV4cG9zZWQgaW4gZmVhdHVyZSBsaWJyYXJpZXMuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gdGFibGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGdpdmVuIHR5cGUgZm91bmQsIGEgdGFibGUgaGVhZGVyIHN0cnVjdHVyZVxuICogaXMgZ2VuZXJhdGVkIGJhc2VkIG9uIHRoZSBhY3R1YWwgZGF0YSBvciByYW5kb21seSAoaW4gY2FzZSBubyBkYXRhIGlzIHBhc3NlZCBpbikgYnlcbiAqIGdlbmVyYXRpbmcgNSBoZWFkZXJzLiBJbiBjYXNlIG9mIGEgZ2VuZXJhdGVkIGhlYWRlciwgd2Ugd2FybiB0aGUgZGV2ZWxvcGVyIGluIGRldk1vZGUgdGhhdFxuICogdGhlcmUgaXMgbm8gY29uZmlndXJhdGlvbiBhdmFpbGFibGUuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZVNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgYnJlYWtwb2ludFNlcnZpY2U6IEJyZWFrcG9pbnRTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBjb25maWc6IFRhYmxlQ29uZmlnXG4gICkge31cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSB0YWJsZSBzdHJ1Y3R1cmUuIFRoZSB0YWJsZSBzdHJ1Y3R1cmUgY2FuIGJlIGNyZWF0ZWQgYnkgdGhlIGhlbHAgb2ZcbiAgICogdGhlIGB0YWJsZVR5cGVgLiBUaGUgYHRhYmxlVHlwZWAgY2FuIGJlIHVzZWQgaW4gdGhlIGNvbmZpZ3VyYXRpb24gYFRhYmxlQ29uZmlnYCxcbiAgICogc28gdGhhdCB0aGUgdGFibGUgaGVhZGVycyBjYW4gYmUgZGVmaW5lZC5cbiAgICovXG4gIGJ1aWxkU3RydWN0dXJlKFxuICAgIHRhYmxlVHlwZTogc3RyaW5nLFxuICAgIGRhdGEkPzogT2JzZXJ2YWJsZTxhbnk+XG4gICk6IE9ic2VydmFibGU8VGFibGVTdHJ1Y3R1cmU+IHtcbiAgICBpZiAodGhpcy5oYXNUYWJsZUNvbmZpZyh0YWJsZVR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsZFN0cnVjdHVyZUZyb21Db25maWcodGFibGVUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkU3RydWN0dXJlRnJvbURhdGEodGFibGVUeXBlLCBkYXRhJCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFJhbmRvbVN0cnVjdHVyZSh0YWJsZVR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YWJsZSBzdHJ1Y3R1cmUgYnkgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gY2FuIGJlXG4gICAqIGJyZWFrcG9pbnQtZHJpdmVuLCB3aGljaCBtZWFucyB0aGF0IGFuIGFsdGVybmF0aXZlIGhlYWRlciBzdHJ1Y3R1cmUgY2FuXG4gICAqIGJlIGNyZWF0ZWQgcGVyIHNjcmVlbiBzaXplLlxuICAgKlxuICAgKiBUaGUgYnJlYWtwb2ludCBpcyByZXNvbHZlZCBieSB0ZWggYEJyZWFrcG9pbnRTZXJ2aWNlYC5cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZFN0cnVjdHVyZUZyb21Db25maWcodHlwZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRTZXJ2aWNlLmJyZWFrcG9pbnQkLnBpcGUoXG4gICAgICBtYXAoKGJyZWFrcG9pbnQpID0+ICh7IC4uLnRoaXMuZ2V0VGFibGVDb25maWcodHlwZSwgYnJlYWtwb2ludCksIHR5cGUgfSkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgYSB0YWJsZSBzdHJ1Y3R1cmUgYnkgdGhlIGhlbHAgb2YgdGhlIGZpcnN0IGRhdGEgcm93LlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkU3RydWN0dXJlRnJvbURhdGEoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGRhdGEkOiBPYnNlcnZhYmxlPGFueT5cbiAgKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHRoaXMud2FybihcbiAgICAgIGBObyB0YWJsZSBjb25maWd1cmF0aW9uIGZvdW5kIHRvIHJlbmRlciB0YWJsZSB3aXRoIHR5cGUgXCIke3R5cGV9XCIuIFRoZSB0YWJsZSBoZWFkZXIgZm9yIFwiJHt0eXBlfVwiIGlzIGdlbmVyYXRlZCBieSB0aGUgaGVscCBvZiB0aGUgZmlyc3QgZGF0YSBpdGVtYFxuICAgICk7XG4gICAgcmV0dXJuIGRhdGEkLnBpcGUoXG4gICAgICBtYXAoKGRhdGE6IGFueVtdKSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3Qua2V5cyhkYXRhPy5bMF0pLm1hcCgoa2V5KSA9PiAoe1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBsYWJlbDoga2V5LFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9IGFzIFRhYmxlU3RydWN0dXJlO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzIGEgbGFzdCByZXNvcnQsIHRoZSB0YWJsZSBzdHJ1Y3R1cmUgaXMgcmFuZG9tbHkgY3JlYXRlZC4gV2UgYWRkIDUgdW5rbm93biBoZWFkZXJzXG4gICAqIGFuZCB1c2UgdGhlIGBoaWRlSGVhZGVyYCB0byBhdm9pZCB0aGUgdW5rbm93biBoZWFkZXJzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkUmFuZG9tU3RydWN0dXJlKHR5cGU6IHN0cmluZyk6IE9ic2VydmFibGU8VGFibGVTdHJ1Y3R1cmU+IHtcbiAgICB0aGlzLndhcm4oXG4gICAgICBgTm8gZGF0YSBhdmFpbGFibGUgZm9yIFwiJHt0eXBlfVwiLCBhIHJhbmRvbSBzdHJ1Y3R1cmUgaXMgZ2VuZXJhdGVkICh3aXRoIGhpZGRlbiB0YWJsZSBoZWFkZXJzKS5gXG4gICAgKTtcblxuICAgIHJldHVybiBvZih7XG4gICAgICB0eXBlLFxuICAgICAgaGVhZGVyczogW1xuICAgICAgICB7IGtleTogJ3Vua25vd24nIH0sXG4gICAgICAgIHsga2V5OiAndW5rbm93bicgfSxcbiAgICAgICAgeyBrZXk6ICd1bmtub3duJyB9LFxuICAgICAgICB7IGtleTogJ3Vua25vd24nIH0sXG4gICAgICAgIHsga2V5OiAndW5rbm93bicgfSxcbiAgICAgIF0sXG4gICAgICBoaWRlSGVhZGVyOiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBiZXN0IGFwcGxpY2FibGUgdGFibGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGdpdmVuIHR5cGVcbiAgICogYW5kIGJyZWFrcG9pbnQuIElmIHRoZXJlIGlzIG5vIGNvbmZpZ3VyYXRpb24gYXZhaWxhYmxlIGZvciB0aGUgYnJlYWtwb2ludCxcbiAgICogdGhlIGJlc3QgbWF0Y2ggd2lsbCBiZSByZXR1cm5lZCwgdXNpbmcgbW9iaWxlIGZpcnN0IGFwcHJvYWNoLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBubyBtYXRjaCBmb3IgYW55IGJyZWFrcG9pbnQsIHRoZSBmYWxsYmFjayBpcyBhIGNvbmZpZ3VyYXRpb25cbiAgICogd2l0aG91dCB0aGUgbm90aW9uIG9mIGEgYnJlYWtwb2ludC4gT3RoZXJ3aXNlIHdlIGZhbGxiYWNrIHRvIHRoZSBmaXJzdFxuICAgKiBhdmFpbGFibGUgY29uZmlnLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFRhYmxlQ29uZmlnKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBicmVha3BvaW50OiBCUkVBS1BPSU5UXG4gICk6IFRhYmxlU3RydWN0dXJlQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3QgdGFibGVDb25maWcgPSB0aGlzLmNvbmZpZy50YWJsZVt0eXBlXTtcblxuICAgIC8vIGZpbmQgYWxsIHJlbGV2YW50IGJyZWFrcG9pbnRzXG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuYnJlYWtwb2ludFNlcnZpY2UuYnJlYWtwb2ludHMuaW5kZXhPZihicmVha3BvaW50KTtcbiAgICBjb25zdCByZWxldmFudCA9IHRoaXMuYnJlYWtwb2ludFNlcnZpY2UuYnJlYWtwb2ludHNcbiAgICAgIC5zbGljZSgwLCBjdXJyZW50ICsgMSlcbiAgICAgIC5yZXZlcnNlKCk7XG5cbiAgICBjb25zdCBiZXN0TWF0Y2g6IEJSRUFLUE9JTlQgPSByZWxldmFudC5maW5kKFxuICAgICAgKGJyKSA9PiAhIXRhYmxlQ29uZmlnLmZpbmQoKHN0cnVjdHVyZSkgPT4gc3RydWN0dXJlLmJyZWFrcG9pbnQgPT09IGJyKVxuICAgICk7XG5cbiAgICByZXR1cm4gYmVzdE1hdGNoXG4gICAgICA/IHRhYmxlQ29uZmlnLmZpbmQoKGNvbmZpZykgPT4gY29uZmlnLmJyZWFrcG9pbnQgPT09IGJlc3RNYXRjaClcbiAgICAgIDogdGFibGVDb25maWcuZmluZCgoc3RydWN0dXJlKSA9PiAhc3RydWN0dXJlLmJyZWFrcG9pbnQpIHx8XG4gICAgICAgICAgdGFibGVDb25maWdbMF07XG4gIH1cblxuICBwcm90ZWN0ZWQgaGFzVGFibGVDb25maWcodGFibGVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmNvbmZpZy50YWJsZT8uW3RhYmxlVHlwZV07XG4gIH1cblxuICAvKipcbiAgICogUHJpbnRzIGEgY29udmVuaWVudCBtZXNzYWdlIGluIHRoZSBjb25zb2xlIHRvIGluY3JlYXNlIGRldmVsb3BlciBleHBlcmllbmNlLlxuICAgKi9cbiAgcHJpdmF0ZSB3YXJuKG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNEZXZNb2RlKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG4iXX0=