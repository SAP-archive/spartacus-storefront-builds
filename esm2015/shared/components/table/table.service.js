import { Injectable, isDevMode } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { BreakpointService } from '../../../layout/breakpoint/breakpoint.service';
import { TableConfig, } from './config/table.config';
import * as i0 from "@angular/core";
import * as i1 from "../../../layout/breakpoint/breakpoint.service";
import * as i2 from "./config/table.config";
/**
 * Responsive table service.
 *
 * The `TableService` is used to build a `TableStructure` by configuration. The configuration
 * allows for breakpoint specific configuration, so that the table can differentiate for
 * various screen sizes.
 *
 * While there are some global options, the configuration is mainly driven by the table _type_.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data (if available) or randomly by generating 5 random headers.
 */
export class TableService {
    constructor(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
    }
    /**
     * Builds the table structure.
     *
     * @param tableType The table type is used  to find the specific table configuration.
     * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
     * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
     */
    buildStructure(tableType, defaultStructure) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType, defaultStructure);
        }
        else {
            return this.buildRandomStructure(tableType);
        }
    }
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    buildStructureFromConfig(type, defaultStructure) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => (Object.assign(Object.assign({}, this.getTableConfig(type, breakpoint, defaultStructure)), { type }))));
    }
    /**
     * Finds all applicable table configuration for the given type and breakpoint.
     * The default table configuration is merged with all relevant breakpoint
     * configurations.
     *
     * This allows to have some default configurations that apply to all screens, and
     * add configuration options for some screens.
     */
    getTableConfig(type, breakpoint, defaultStructure) {
        var _a, _b;
        if (!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[type])) {
            return null;
        }
        const relevant = this.findRelevantBreakpoints(breakpoint);
        const closestBreakpoint = [...relevant]
            .reverse()
            .find((br) => { var _a; return !!((_a = this.config.table[type][br]) === null || _a === void 0 ? void 0 : _a.cells); });
        const cells = ((_b = this.config.table[type][closestBreakpoint]) === null || _b === void 0 ? void 0 : _b.cells) ||
            this.config.table[type].cells || (defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.cells);
        // add all default table configurations
        let options = Object.assign(Object.assign({}, defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.options), this.config.table[type].options);
        // We merge all table options for smaller breakpoints into the global
        // options, so we inherit options.
        relevant.forEach((br) => {
            var _a, _b, _c;
            options = Object.assign(Object.assign(Object.assign({}, options), (_a = defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure[br]) === null || _a === void 0 ? void 0 : _a.options), (_c = (_b = this.config.table[type]) === null || _b === void 0 ? void 0 : _b[br]) === null || _c === void 0 ? void 0 : _c.options);
        });
        return { cells, options };
    }
    /**
     * Generates the table structure by the help of the first data row.
     */
    buildStructureFromData(type, data$) {
        this.logWarning(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
        return data$.pipe(map((data) => {
            const cells = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map((key) => key);
            return { type, cells };
        }));
    }
    /**
     * As a last resort, the table structure is randomly created. The random structure
     * contains 5 headers, so that some of the unknown data is visualized.
     */
    buildRandomStructure(type) {
        this.logWarning(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
        return of({
            type,
            cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
        });
    }
    /**
     * Finds all the breakpoints can contribute to the table configuration, from small
     * to current.
     *
     * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
     */
    findRelevantBreakpoints(breakpoint) {
        const current = this.breakpointService.breakpoints.indexOf(breakpoint);
        return this.breakpointService.breakpoints.slice(0, current + 1);
    }
    /**
     * Indicates if the there is a configuration for the table available.
     */
    hasTableConfig(tableType) {
        var _a;
        return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
    }
    /**
     * Logs a message in the console to increase developer experience.
     *
     * The message is only logged in dev mode.
     */
    logWarning(message) {
        if (isDevMode()) {
            console.warn(message);
        }
    }
}
TableService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TableService_Factory() { return new TableService(i0.ɵɵinject(i1.BreakpointService), i0.ɵɵinject(i2.TableConfig)); }, token: TableService, providedIn: "root" });
TableService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
TableService.ctorParameters = () => [
    { type: BreakpointService },
    { type: TableConfig }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc3JjL3NoYXJlZC9jb21wb25lbnRzL3RhYmxlL3RhYmxlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEQsT0FBTyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0QyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFFbEYsT0FBTyxFQUVMLFdBQVcsR0FDWixNQUFNLHVCQUF1QixDQUFDOzs7O0FBRy9COzs7Ozs7Ozs7OztHQVdHO0FBSUgsTUFBTSxPQUFPLFlBQVk7SUFDdkIsWUFDWSxpQkFBb0MsRUFDcEMsTUFBbUI7UUFEbkIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxXQUFNLEdBQU4sTUFBTSxDQUFhO0lBQzVCLENBQUM7SUFFSjs7Ozs7O09BTUc7SUFDSCxjQUFjLENBQ1osU0FBaUIsRUFDakIsZ0JBQStDO1FBRS9DLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNsQyxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztTQUNuRTthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDN0M7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ08sd0JBQXdCLENBQ2hDLElBQVksRUFDWixnQkFBK0M7UUFFL0MsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLElBQUksQ0FDNUMsR0FBRyxDQUFDLENBQUMsVUFBVSxFQUFF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SUFDTyx1QkFBdUIsQ0FBQyxVQUFzQjtRQUN0RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN2RSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEOztPQUVHO0lBQ08sY0FBYyxDQUFDLFNBQWlCOztRQUN4QyxPQUFPLENBQUMsUUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssMENBQUcsU0FBUyxFQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxVQUFVLENBQUMsT0FBTztRQUN4QixJQUFJLFNBQVMsRUFBRSxFQUFFO1lBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN2QjtJQUNILENBQUM7Ozs7WUF2SkYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUF0QlEsaUJBQWlCO1lBSXhCLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBCcmVha3BvaW50U2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2xheW91dC9icmVha3BvaW50L2JyZWFrcG9pbnQuc2VydmljZSc7XG5pbXBvcnQgeyBCUkVBS1BPSU5UIH0gZnJvbSAnLi4vLi4vLi4vbGF5b3V0L2NvbmZpZy9sYXlvdXQtY29uZmlnJztcbmltcG9ydCB7XG4gIFJlc3BvbnNpdmVUYWJsZUNvbmZpZ3VyYXRpb24sXG4gIFRhYmxlQ29uZmlnLFxufSBmcm9tICcuL2NvbmZpZy90YWJsZS5jb25maWcnO1xuaW1wb3J0IHsgVGFibGVTdHJ1Y3R1cmUsIFRhYmxlU3RydWN0dXJlQ29uZmlndXJhdGlvbiB9IGZyb20gJy4vdGFibGUubW9kZWwnO1xuXG4vKipcbiAqIFJlc3BvbnNpdmUgdGFibGUgc2VydmljZS5cbiAqXG4gKiBUaGUgYFRhYmxlU2VydmljZWAgaXMgdXNlZCB0byBidWlsZCBhIGBUYWJsZVN0cnVjdHVyZWAgYnkgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb25cbiAqIGFsbG93cyBmb3IgYnJlYWtwb2ludCBzcGVjaWZpYyBjb25maWd1cmF0aW9uLCBzbyB0aGF0IHRoZSB0YWJsZSBjYW4gZGlmZmVyZW50aWF0ZSBmb3JcbiAqIHZhcmlvdXMgc2NyZWVuIHNpemVzLlxuICpcbiAqIFdoaWxlIHRoZXJlIGFyZSBzb21lIGdsb2JhbCBvcHRpb25zLCB0aGUgY29uZmlndXJhdGlvbiBpcyBtYWlubHkgZHJpdmVuIGJ5IHRoZSB0YWJsZSBfdHlwZV8uXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gdGFibGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGdpdmVuIHR5cGUgZm91bmQsIGEgdGFibGUgaGVhZGVyIHN0cnVjdHVyZVxuICogaXMgZ2VuZXJhdGVkIGJhc2VkIG9uIHRoZSBhY3R1YWwgZGF0YSAoaWYgYXZhaWxhYmxlKSBvciByYW5kb21seSBieSBnZW5lcmF0aW5nIDUgcmFuZG9tIGhlYWRlcnMuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZVNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgYnJlYWtwb2ludFNlcnZpY2U6IEJyZWFrcG9pbnRTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBjb25maWc6IFRhYmxlQ29uZmlnXG4gICkge31cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSB0YWJsZSBzdHJ1Y3R1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB0YWJsZVR5cGUgVGhlIHRhYmxlIHR5cGUgaXMgdXNlZCAgdG8gZmluZCB0aGUgc3BlY2lmaWMgdGFibGUgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIGRlZmF1bHRTdHJ1Y3R1cmUgKG9wdGlvbmFsKSBEZWZhdWx0IHRhYmxlIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGZhbGxiYWNrIG9wdGlvbnMuIE1vcmUgc3BlY2lmaWMgb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQgc3RydWN0dXJlLlxuICAgKiBAcGFyYW0gZGF0YSQgKG9wdGlvbmFsKSBUaGUgYWN0dWFsIGRhdGEgY2FuIGJlIHBhc3NlZCBpbiB0byBnZW5lcmF0ZSB0aGUgdGFibGUgc3RydWN0dXJlIGJhc2VkIG9uIGFjdHVhbCBkYXRhLlxuICAgKi9cbiAgYnVpbGRTdHJ1Y3R1cmUoXG4gICAgdGFibGVUeXBlOiBzdHJpbmcsXG4gICAgZGVmYXVsdFN0cnVjdHVyZT86IFJlc3BvbnNpdmVUYWJsZUNvbmZpZ3VyYXRpb25cbiAgKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIGlmICh0aGlzLmhhc1RhYmxlQ29uZmlnKHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkU3RydWN0dXJlRnJvbUNvbmZpZyh0YWJsZVR5cGUsIGRlZmF1bHRTdHJ1Y3R1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsZFJhbmRvbVN0cnVjdHVyZSh0YWJsZVR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YWJsZSBzdHJ1Y3R1cmUgYnkgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gY2FuIGJlXG4gICAqIGJyZWFrcG9pbnQtZHJpdmVuLCB3aGljaCBtZWFucyB0aGF0IGFuIGFsdGVybmF0aXZlIGhlYWRlciBzdHJ1Y3R1cmUgY2FuXG4gICAqIGJlIGNyZWF0ZWQgcGVyIHNjcmVlbiBzaXplLlxuICAgKlxuICAgKiBUaGUgYnJlYWtwb2ludCBpcyByZXNvbHZlZCBieSB0ZWggYEJyZWFrcG9pbnRTZXJ2aWNlYC5cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZFN0cnVjdHVyZUZyb21Db25maWcoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGRlZmF1bHRTdHJ1Y3R1cmU/OiBSZXNwb25zaXZlVGFibGVDb25maWd1cmF0aW9uXG4gICk6IE9ic2VydmFibGU8VGFibGVTdHJ1Y3R1cmU+IHtcbiAgICByZXR1cm4gdGhpcy5icmVha3BvaW50U2VydmljZS5icmVha3BvaW50JC5waXBlKFxuICAgICAgbWFwKChicmVha3BvaW50KSA9PiAoe1xuICAgICAgICAuLi50aGlzLmdldFRhYmxlQ29uZmlnKHR5cGUsIGJyZWFrcG9pbnQsIGRlZmF1bHRTdHJ1Y3R1cmUpLFxuICAgICAgICB0eXBlLFxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgYXBwbGljYWJsZSB0YWJsZSBjb25maWd1cmF0aW9uIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgYnJlYWtwb2ludC5cbiAgICogVGhlIGRlZmF1bHQgdGFibGUgY29uZmlndXJhdGlvbiBpcyBtZXJnZWQgd2l0aCBhbGwgcmVsZXZhbnQgYnJlYWtwb2ludFxuICAgKiBjb25maWd1cmF0aW9ucy5cbiAgICpcbiAgICogVGhpcyBhbGxvd3MgdG8gaGF2ZSBzb21lIGRlZmF1bHQgY29uZmlndXJhdGlvbnMgdGhhdCBhcHBseSB0byBhbGwgc2NyZWVucywgYW5kXG4gICAqIGFkZCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHNvbWUgc2NyZWVucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRUYWJsZUNvbmZpZyhcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgYnJlYWtwb2ludDogQlJFQUtQT0lOVCxcbiAgICBkZWZhdWx0U3RydWN0dXJlPzogUmVzcG9uc2l2ZVRhYmxlQ29uZmlndXJhdGlvblxuICApOiBUYWJsZVN0cnVjdHVyZUNvbmZpZ3VyYXRpb24ge1xuICAgIGlmICghdGhpcy5jb25maWcudGFibGU/Llt0eXBlXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVsZXZhbnQgPSB0aGlzLmZpbmRSZWxldmFudEJyZWFrcG9pbnRzKGJyZWFrcG9pbnQpO1xuXG4gICAgY29uc3QgY2xvc2VzdEJyZWFrcG9pbnQgPSBbLi4ucmVsZXZhbnRdXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZCgoYnIpID0+ICEhdGhpcy5jb25maWcudGFibGVbdHlwZV1bYnJdPy5jZWxscyk7XG4gICAgY29uc3QgY2VsbHMgPVxuICAgICAgdGhpcy5jb25maWcudGFibGVbdHlwZV1bY2xvc2VzdEJyZWFrcG9pbnRdPy5jZWxscyB8fFxuICAgICAgdGhpcy5jb25maWcudGFibGVbdHlwZV0uY2VsbHMgfHxcbiAgICAgIGRlZmF1bHRTdHJ1Y3R1cmU/LmNlbGxzO1xuXG4gICAgLy8gYWRkIGFsbCBkZWZhdWx0IHRhYmxlIGNvbmZpZ3VyYXRpb25zXG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAuLi5kZWZhdWx0U3RydWN0dXJlPy5vcHRpb25zLFxuICAgICAgLi4udGhpcy5jb25maWcudGFibGVbdHlwZV0ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gV2UgbWVyZ2UgYWxsIHRhYmxlIG9wdGlvbnMgZm9yIHNtYWxsZXIgYnJlYWtwb2ludHMgaW50byB0aGUgZ2xvYmFsXG4gICAgLy8gb3B0aW9ucywgc28gd2UgaW5oZXJpdCBvcHRpb25zLlxuICAgIHJlbGV2YW50LmZvckVhY2goKGJyKSA9PiB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5kZWZhdWx0U3RydWN0dXJlPy5bYnJdPy5vcHRpb25zLFxuICAgICAgICAuLi50aGlzLmNvbmZpZy50YWJsZVt0eXBlXT8uW2JyXT8ub3B0aW9ucyxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjZWxscywgb3B0aW9ucyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgdGFibGUgc3RydWN0dXJlIGJ5IHRoZSBoZWxwIG9mIHRoZSBmaXJzdCBkYXRhIHJvdy5cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZFN0cnVjdHVyZUZyb21EYXRhKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBkYXRhJDogT2JzZXJ2YWJsZTxhbnk+XG4gICk6IE9ic2VydmFibGU8VGFibGVTdHJ1Y3R1cmU+IHtcbiAgICB0aGlzLmxvZ1dhcm5pbmcoXG4gICAgICBgTm8gdGFibGUgY29uZmlndXJhdGlvbiBmb3VuZCB0byByZW5kZXIgdGFibGUgd2l0aCB0eXBlIFwiJHt0eXBlfVwiLiBUaGUgdGFibGUgaGVhZGVyIGZvciBcIiR7dHlwZX1cIiBpcyBnZW5lcmF0ZWQgYnkgdGhlIGhlbHAgb2YgdGhlIGZpcnN0IGRhdGEgaXRlbWBcbiAgICApO1xuICAgIHJldHVybiBkYXRhJC5waXBlKFxuICAgICAgbWFwKChkYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgICBjb25zdCBjZWxscyA9IE9iamVjdC5rZXlzKGRhdGE/LlswXSkubWFwKChrZXkpID0+IGtleSk7XG4gICAgICAgIHJldHVybiB7IHR5cGUsIGNlbGxzIH0gYXMgVGFibGVTdHJ1Y3R1cmU7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQXMgYSBsYXN0IHJlc29ydCwgdGhlIHRhYmxlIHN0cnVjdHVyZSBpcyByYW5kb21seSBjcmVhdGVkLiBUaGUgcmFuZG9tIHN0cnVjdHVyZVxuICAgKiBjb250YWlucyA1IGhlYWRlcnMsIHNvIHRoYXQgc29tZSBvZiB0aGUgdW5rbm93biBkYXRhIGlzIHZpc3VhbGl6ZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRSYW5kb21TdHJ1Y3R1cmUodHlwZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHRoaXMubG9nV2FybmluZyhcbiAgICAgIGBObyBkYXRhIGF2YWlsYWJsZSBmb3IgXCIke3R5cGV9XCIsIGEgcmFuZG9tIHN0cnVjdHVyZSBpcyBnZW5lcmF0ZWQgKHdpdGggaGlkZGVuIHRhYmxlIGhlYWRlcnMpLmBcbiAgICApO1xuICAgIHJldHVybiBvZih7XG4gICAgICB0eXBlLFxuICAgICAgY2VsbHM6IFsndW5rbm93bicsICd1bmtub3duJywgJ3Vua25vd24nLCAndW5rbm93bicsICd1bmtub3duJ10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIHRoZSBicmVha3BvaW50cyBjYW4gY29udHJpYnV0ZSB0byB0aGUgdGFibGUgY29uZmlndXJhdGlvbiwgZnJvbSBzbWFsbFxuICAgKiB0byBjdXJyZW50LlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBpcyBgTURgLCB0aGlzIHJldHVybnMgYFtYUywgU00sIE1EXWAuXG4gICAqL1xuICBwcm90ZWN0ZWQgZmluZFJlbGV2YW50QnJlYWtwb2ludHMoYnJlYWtwb2ludDogQlJFQUtQT0lOVCk6IEJSRUFLUE9JTlRbXSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuYnJlYWtwb2ludFNlcnZpY2UuYnJlYWtwb2ludHMuaW5kZXhPZihicmVha3BvaW50KTtcbiAgICByZXR1cm4gdGhpcy5icmVha3BvaW50U2VydmljZS5icmVha3BvaW50cy5zbGljZSgwLCBjdXJyZW50ICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSB0aGVyZSBpcyBhIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSB0YWJsZSBhdmFpbGFibGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgaGFzVGFibGVDb25maWcodGFibGVUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmNvbmZpZy50YWJsZT8uW3RhYmxlVHlwZV07XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgdG8gaW5jcmVhc2UgZGV2ZWxvcGVyIGV4cGVyaWVuY2UuXG4gICAqXG4gICAqIFRoZSBtZXNzYWdlIGlzIG9ubHkgbG9nZ2VkIGluIGRldiBtb2RlLlxuICAgKi9cbiAgcHJpdmF0ZSBsb2dXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==