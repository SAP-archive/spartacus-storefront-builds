import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, Input, Output, } from '@angular/core';
import { timer } from 'rxjs';
import { delayWhen } from 'rxjs/operators';
import { SplitViewService } from '../split-view.service';
/**
 * The view component is part of the `SplitViewComponent`. The view
 * contains the navigable content that should be split up. It maintains
 * a view position and allows to show or hide the view.
 *
 * The ViewComponent interacts with the `SplitViewService` for handing over the
 * view state, so that the overarching `SplitViewComponent` can manage the
 * overall experience.
 */
export class ViewComponent {
    constructor(splitService, elementRef, cd) {
        this.splitService = splitService;
        this.elementRef = elementRef;
        this.cd = cd;
        /**
         * The disappeared flag is added to the
         */
        this.disappeared = true;
        /**
         * An update of the view visibility is emitted to the hiddenChange output.
         */
        this.hiddenChange = new EventEmitter();
    }
    /**
     * The hidden input is used to set the initial visible state of the view.
     * The hidden state defaults to false.
     *
     * The hidden input supports 2-way binding, see `hiddenChange` property.
     */
    set hidden(hidden) {
        this._hidden = hidden;
        this.splitService.toggle(this.viewPosition, hidden);
    }
    ngOnInit() {
        const hidden = this._hidden ? { hidden: this._hidden } : {};
        this.splitService.add(this.viewPosition, hidden);
        this.subscription = this.splitService
            .getViewState(this.viewPosition)
            // delay the disappeared state, so that the (CSS driven) animation has time to finish
            .pipe(delayWhen((view) => timer(view.hidden ? this.duration * 1.25 : 0)))
            .subscribe((view) => {
            this.hiddenChange.emit(view.hidden);
            this._hidden = view.hidden;
            this.disappeared = view.hidden;
            this.cd.markForCheck();
        });
    }
    /**
     * Toggles the visibility of the view.
     *
     * An optional force flag can be used to explicitly show or hide view component.
     */
    toggle(force) {
        this.splitService.toggle(this.viewPosition, force);
    }
    /**
     * Returns the position for the view.
     *
     * The position is either taken from the input `position` or generated by the `SplitService`.
     */
    get viewPosition() {
        if (!(Number(this.position) >= 0)) {
            this.position = this.splitService.nextPosition.toString();
        }
        return Number(this.position);
    }
    /**
     * Returns the duration in milliseconds. The duration is based on the CSS custom property
     * `--cx-transition-duration`. Defaults to 300 milliseconds.
     */
    get duration() {
        const duration = getComputedStyle(this.elementRef.nativeElement)
            .getPropertyValue('--cx-transition-duration')
            .trim();
        if (duration.indexOf('ms') > -1) {
            return Number(duration.split('ms')[0]);
        }
        else if (duration.indexOf('s') > -1) {
            return Number(duration.split('s')[0]) * 1000;
        }
        else {
            return 300;
        }
    }
    /**
     * The view is removed from the `SplitService` so that the view no longer
     * plays a role in the overall split view.
     */
    ngOnDestroy() {
        var _a;
        this.splitService.remove(this.viewPosition);
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
ViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'cx-view',
                template: "<ng-content></ng-content>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ViewComponent.ctorParameters = () => [
    { type: SplitViewService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
ViewComponent.propDecorators = {
    position: [{ type: Input }, { type: HostBinding, args: ['attr.position',] }, { type: HostBinding, args: ['style.--cx-view-position',] }],
    disappeared: [{ type: HostBinding, args: ['attr.disappeared',] }],
    hidden: [{ type: Input }],
    hiddenChange: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlldy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NyYy9zaGFyZWQvY29tcG9uZW50cy9zcGxpdC12aWV3L3ZpZXcvdmlldy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFHTCxNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFnQixLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXpEOzs7Ozs7OztHQVFHO0FBTUgsTUFBTSxPQUFPLGFBQWE7SUFpQ3hCLFlBQ1ksWUFBOEIsRUFDOUIsVUFBc0IsRUFDdEIsRUFBcUI7UUFGckIsaUJBQVksR0FBWixZQUFZLENBQWtCO1FBQzlCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsT0FBRSxHQUFGLEVBQUUsQ0FBbUI7UUE1QmpDOztXQUVHO1FBQzhCLGdCQUFXLEdBQUcsSUFBSSxDQUFDO1FBY3BEOztXQUVHO1FBRUgsaUJBQVksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBUS9CLENBQUM7SUF4Qko7Ozs7O09BS0c7SUFDSCxJQUNJLE1BQU0sQ0FBQyxNQUFlO1FBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQWdCRCxRQUFRO1FBQ04sTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9B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TXRDLFdBQVcsU0FBQyxrQkFBa0I7cUJBUTlCLEtBQUs7MkJBU0wsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWxheVdoZW4gfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTcGxpdFZpZXdTZXJ2aWNlIH0gZnJvbSAnLi4vc3BsaXQtdmlldy5zZXJ2aWNlJztcblxuLyoqXG4gKiBUaGUgdmlldyBjb21wb25lbnQgaXMgcGFydCBvZiB0aGUgYFNwbGl0Vmlld0NvbXBvbmVudGAuIFRoZSB2aWV3XG4gKiBjb250YWlucyB0aGUgbmF2aWdhYmxlIGNvbnRlbnQgdGhhdCBzaG91bGQgYmUgc3BsaXQgdXAuIEl0IG1haW50YWluc1xuICogYSB2aWV3IHBvc2l0aW9uIGFuZCBhbGxvd3MgdG8gc2hvdyBvciBoaWRlIHRoZSB2aWV3LlxuICpcbiAqIFRoZSBWaWV3Q29tcG9uZW50IGludGVyYWN0cyB3aXRoIHRoZSBgU3BsaXRWaWV3U2VydmljZWAgZm9yIGhhbmRpbmcgb3ZlciB0aGVcbiAqIHZpZXcgc3RhdGUsIHNvIHRoYXQgdGhlIG92ZXJhcmNoaW5nIGBTcGxpdFZpZXdDb21wb25lbnRgIGNhbiBtYW5hZ2UgdGhlXG4gKiBvdmVyYWxsIGV4cGVyaWVuY2UuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2N4LXZpZXcnLFxuICB0ZW1wbGF0ZVVybDogJy4vdmlldy5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcm90ZWN0ZWQgX2hpZGRlbjtcblxuICBASW5wdXQoKVxuICBASG9zdEJpbmRpbmcoJ2F0dHIucG9zaXRpb24nKVxuICBASG9zdEJpbmRpbmcoJ3N0eWxlLi0tY3gtdmlldy1wb3NpdGlvbicpXG4gIHBvc2l0aW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBkaXNhcHBlYXJlZCBmbGFnIGlzIGFkZGVkIHRvIHRoZVxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmRpc2FwcGVhcmVkJykgZGlzYXBwZWFyZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUaGUgaGlkZGVuIGlucHV0IGlzIHVzZWQgdG8gc2V0IHRoZSBpbml0aWFsIHZpc2libGUgc3RhdGUgb2YgdGhlIHZpZXcuXG4gICAqIFRoZSBoaWRkZW4gc3RhdGUgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqXG4gICAqIFRoZSBoaWRkZW4gaW5wdXQgc3VwcG9ydHMgMi13YXkgYmluZGluZywgc2VlIGBoaWRkZW5DaGFuZ2VgIHByb3BlcnR5LlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGhpZGRlbihoaWRkZW46IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9oaWRkZW4gPSBoaWRkZW47XG4gICAgdGhpcy5zcGxpdFNlcnZpY2UudG9nZ2xlKHRoaXMudmlld1Bvc2l0aW9uLCBoaWRkZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIHVwZGF0ZSBvZiB0aGUgdmlldyB2aXNpYmlsaXR5IGlzIGVtaXR0ZWQgdG8gdGhlIGhpZGRlbkNoYW5nZSBvdXRwdXQuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgaGlkZGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHByb3RlY3RlZCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgc3BsaXRTZXJ2aWNlOiBTcGxpdFZpZXdTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByb3RlY3RlZCBjZDogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGNvbnN0IGhpZGRlbiA9IHRoaXMuX2hpZGRlbiA/IHsgaGlkZGVuOiB0aGlzLl9oaWRkZW4gfSA6IHt9O1xuICAgIHRoaXMuc3BsaXRTZXJ2aWNlLmFkZCh0aGlzLnZpZXdQb3NpdGlvbiwgaGlkZGVuKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zcGxpdFNlcnZpY2VcbiAgICAgIC5nZXRWaWV3U3RhdGUodGhpcy52aWV3UG9zaXRpb24pXG4gICAgICAvLyBkZWxheSB0aGUgZGlzYXBwZWFyZWQgc3RhdGUsIHNvIHRoYXQgdGhlIChDU1MgZHJpdmVuKSBhbmltYXRpb24gaGFzIHRpbWUgdG8gZmluaXNoXG4gICAgICAucGlwZShkZWxheVdoZW4oKHZpZXcpID0+IHRpbWVyKHZpZXcuaGlkZGVuID8gdGhpcy5kdXJhdGlvbiAqIDEuMjUgOiAwKSkpXG4gICAgICAuc3Vic2NyaWJlKCh2aWV3KSA9PiB7XG4gICAgICAgIHRoaXMuaGlkZGVuQ2hhbmdlLmVtaXQodmlldy5oaWRkZW4pO1xuICAgICAgICB0aGlzLl9oaWRkZW4gPSB2aWV3LmhpZGRlbjtcblxuICAgICAgICB0aGlzLmRpc2FwcGVhcmVkID0gdmlldy5oaWRkZW47XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB2aWV3LlxuICAgKlxuICAgKiBBbiBvcHRpb25hbCBmb3JjZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGV4cGxpY2l0bHkgc2hvdyBvciBoaWRlIHZpZXcgY29tcG9uZW50LlxuICAgKi9cbiAgdG9nZ2xlKGZvcmNlPzogYm9vbGVhbikge1xuICAgIHRoaXMuc3BsaXRTZXJ2aWNlLnRvZ2dsZSh0aGlzLnZpZXdQb3NpdGlvbiwgZm9yY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIGZvciB0aGUgdmlldy5cbiAgICpcbiAgICogVGhlIHBvc2l0aW9uIGlzIGVpdGhlciB0YWtlbiBmcm9tIHRoZSBpbnB1dCBgcG9zaXRpb25gIG9yIGdlbmVyYXRlZCBieSB0aGUgYFNwbGl0U2VydmljZWAuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IHZpZXdQb3NpdGlvbigpOiBudW1iZXIge1xuICAgIGlmICghKE51bWJlcih0aGlzLnBvc2l0aW9uKSA+PSAwKSkge1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuc3BsaXRTZXJ2aWNlLm5leHRQb3NpdGlvbi50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyKHRoaXMucG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy4gVGhlIGR1cmF0aW9uIGlzIGJhc2VkIG9uIHRoZSBDU1MgY3VzdG9tIHByb3BlcnR5XG4gICAqIGAtLWN4LXRyYW5zaXRpb24tZHVyYXRpb25gLiBEZWZhdWx0cyB0byAzMDAgbWlsbGlzZWNvbmRzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBkdXJhdGlvbigpOiBudW1iZXIge1xuICAgIGNvbnN0IGR1cmF0aW9uOiBzdHJpbmcgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KVxuICAgICAgLmdldFByb3BlcnR5VmFsdWUoJy0tY3gtdHJhbnNpdGlvbi1kdXJhdGlvbicpXG4gICAgICAudHJpbSgpO1xuXG4gICAgaWYgKGR1cmF0aW9uLmluZGV4T2YoJ21zJykgPiAtMSkge1xuICAgICAgcmV0dXJuIE51bWJlcihkdXJhdGlvbi5zcGxpdCgnbXMnKVswXSk7XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbi5pbmRleE9mKCdzJykgPiAtMSkge1xuICAgICAgcmV0dXJuIE51bWJlcihkdXJhdGlvbi5zcGxpdCgncycpWzBdKSAqIDEwMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAzMDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2aWV3IGlzIHJlbW92ZWQgZnJvbSB0aGUgYFNwbGl0U2VydmljZWAgc28gdGhhdCB0aGUgdmlldyBubyBsb25nZXJcbiAgICogcGxheXMgYSByb2xlIGluIHRoZSBvdmVyYWxsIHNwbGl0IHZpZXcuXG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnNwbGl0U2VydmljZS5yZW1vdmUodGhpcy52aWV3UG9zaXRpb24pO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iXX0=