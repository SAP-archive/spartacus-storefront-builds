import { Injectable, } from '@angular/core';
import { from } from 'rxjs';
import { DefaultComponentHandler } from './default-component.handler';
import { switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./default-component.handler";
/**
 * Lazy component handler used for launching lazy loaded cms components implemented
 * as native Angular components.
 */
export class LazyComponentHandler {
    constructor(defaultHandler) {
        this.defaultHandler = defaultHandler;
    }
    /**
     * We want to mach dynamic import signature () => import('')
     */
    hasMatch(componentMapping) {
        return (typeof componentMapping.component === 'function' &&
            this.isNotClass(componentMapping.component));
    }
    isNotClass(symbol) {
        const signature = symbol.toString().substr(0, 20).replace(' ', '');
        return signature.startsWith('function()') || signature.startsWith('()=>');
    }
    getPriority() {
        return -10 /* LOW */;
    }
    launcher(componentMapping, viewContainerRef, elementInjector) {
        return from(componentMapping.component()).pipe(switchMap((component) => this.defaultHandler.launcher(Object.assign(Object.assign({}, componentMapping), { component }), viewContainerRef, elementInjector)));
    }
}
LazyComponentHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyComponentHandler_Factory() { return new LazyComponentHandler(i0.ɵɵinject(i1.DefaultComponentHandler)); }, token: LazyComponentHandler, providedIn: "root" });
LazyComponentHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
LazyComponentHandler.ctorParameters = () => [
    { type: DefaultComponentHandler }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS1jb21wb25lbnQuaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc3JjL2Ntcy1zdHJ1Y3R1cmUvcGFnZS9jb21wb25lbnQvaGFuZGxlcnMvbGF6eS1jb21wb25lbnQuaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBR0wsVUFBVSxHQUdYLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxJQUFJLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDeEMsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDdEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFHM0M7OztHQUdHO0FBSUgsTUFBTSxPQUFPLG9CQUFvQjtJQUMvQixZQUFzQixjQUF1QztRQUF2QyxtQkFBYyxHQUFkLGNBQWMsQ0FBeUI7SUFBRyxDQUFDO0lBRWpFOztPQUVHO0lBQ0gsUUFBUSxDQUFDLGdCQUFxQztRQUM1QyxPQUFPLENBQ0wsT0FBTyxnQkFBZ0IsQ0FBQyxTQUFTLEtBQUssVUFBVTtZQUNoRCxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUM1QyxDQUFDO0lBQ0osQ0FBQztJQUVPLFVBQVUsQ0FBQyxNQUFXO1FBQzVCLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDbkUsT0FBTyxTQUFTLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVELFdBQVc7UUFDVCxxQkFBb0I7SUFDdEIsQ0FBQztJQUVELFFBQVEsQ0FDTixnQkFBcUMsRUFDckMsZ0JBQWtDLEVBQ2xDLGVBQTBCO1FBRTFCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUM1QyxTQUFTLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUN0QixJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsaUNBQ3JCLGdCQUFnQixLQUFFLFNBQVMsS0FDaEMsZ0JBQWdCLEVBQ2hCLGVBQWUsQ0FDaEIsQ0FDRixDQUNGLENBQUM7SUFDSixDQUFDOzs7O1lBdkNGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBVlEsdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50UmVmLFxuICBFbGVtZW50UmVmLFxuICBJbmplY3RhYmxlLFxuICBJbmplY3RvcixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbXNDb21wb25lbnRNYXBwaW5nLCBQcmlvcml0eSB9IGZyb20gJ0BzcGFydGFjdXMvY29yZSc7XG5pbXBvcnQgeyBmcm9tLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBEZWZhdWx0Q29tcG9uZW50SGFuZGxlciB9IGZyb20gJy4vZGVmYXVsdC1jb21wb25lbnQuaGFuZGxlcic7XG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDb21wb25lbnRIYW5kbGVyIH0gZnJvbSAnLi9jb21wb25lbnQtaGFuZGxlcic7XG5cbi8qKlxuICogTGF6eSBjb21wb25lbnQgaGFuZGxlciB1c2VkIGZvciBsYXVuY2hpbmcgbGF6eSBsb2FkZWQgY21zIGNvbXBvbmVudHMgaW1wbGVtZW50ZWRcbiAqIGFzIG5hdGl2ZSBBbmd1bGFyIGNvbXBvbmVudHMuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBMYXp5Q29tcG9uZW50SGFuZGxlciBpbXBsZW1lbnRzIENvbXBvbmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGVmYXVsdEhhbmRsZXI6IERlZmF1bHRDb21wb25lbnRIYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIG1hY2ggZHluYW1pYyBpbXBvcnQgc2lnbmF0dXJlICgpID0+IGltcG9ydCgnJylcbiAgICovXG4gIGhhc01hdGNoKGNvbXBvbmVudE1hcHBpbmc6IENtc0NvbXBvbmVudE1hcHBpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIGNvbXBvbmVudE1hcHBpbmcuY29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0aGlzLmlzTm90Q2xhc3MoY29tcG9uZW50TWFwcGluZy5jb21wb25lbnQpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNOb3RDbGFzcyhzeW1ib2w6IGFueSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHN5bWJvbC50b1N0cmluZygpLnN1YnN0cigwLCAyMCkucmVwbGFjZSgnICcsICcnKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlLnN0YXJ0c1dpdGgoJ2Z1bmN0aW9uKCknKSB8fCBzaWduYXR1cmUuc3RhcnRzV2l0aCgnKCk9PicpO1xuICB9XG5cbiAgZ2V0UHJpb3JpdHkoKTogUHJpb3JpdHkge1xuICAgIHJldHVybiBQcmlvcml0eS5MT1c7XG4gIH1cblxuICBsYXVuY2hlcihcbiAgICBjb21wb25lbnRNYXBwaW5nOiBDbXNDb21wb25lbnRNYXBwaW5nLFxuICAgIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgZWxlbWVudEluamVjdG9yPzogSW5qZWN0b3JcbiAgKTogT2JzZXJ2YWJsZTx7IGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7IGNvbXBvbmVudFJlZj86IENvbXBvbmVudFJlZjxhbnk+IH0+IHtcbiAgICByZXR1cm4gZnJvbShjb21wb25lbnRNYXBwaW5nLmNvbXBvbmVudCgpKS5waXBlKFxuICAgICAgc3dpdGNoTWFwKChjb21wb25lbnQpID0+XG4gICAgICAgIHRoaXMuZGVmYXVsdEhhbmRsZXIubGF1bmNoZXIoXG4gICAgICAgICAgeyAuLi5jb21wb25lbnRNYXBwaW5nLCBjb21wb25lbnQgfSxcbiAgICAgICAgICB2aWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgIGVsZW1lbnRJbmplY3RvclxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuIl19