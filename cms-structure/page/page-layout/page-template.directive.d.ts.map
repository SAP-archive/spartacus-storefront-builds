{"version":3,"file":"page-template.directive.d.ts","sources":["page-template.directive.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ChangeDetectorRef, ElementRef, OnDestroy, OnInit, TemplateRef } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { PageLayoutService } from './page-layout.service';\n/**\n * Directive that Adds a style class to the host element based on the cms page\n * template. The CMS page template is driven by the CMS structure, which is configurable\n * in the backend.\n *\n * The style class is added to the host element of the directive. The host element is resolved\n * from the `elementRef`, or, in case the directive is used in an `ng-template`, by the\n * `TemplateRef`.\n *\n * An example of the usage is given below:\n *\n * ```html\n * <cx-storefront class=\"LandingPageTemplate\">\n *   <ng-template cxPageTemplateStyle>...</ng-template>\n * <cx-storefront>\n * ```\n *\n * The style class can also be provided by an input:\n *\n * ```html\n * <ng-template [cxPageTemplateStyle]=\"pageTemplateName\">\n * ```\n *\n */\nexport declare class PageTemplateDirective implements OnInit, OnDestroy {\n    protected pageLayoutService: PageLayoutService;\n    protected elementRef: ElementRef;\n    protected templateRef: TemplateRef<HTMLElement>;\n    protected cd: ChangeDetectorRef;\n    /**\n     * Indicates whether this component is driven by an input template or should\n     * observe the CMS driven page layout template.\n     */\n    protected useTemplateFromInput: boolean;\n    /**\n     * Adds a style class to the host element based on the cms page template, unless\n     * the class is given as an input.\n     *\n     * The host element is either the actual host, or the parent element in case this\n     * is used inside an `ng-template`.\n     */\n    set setTemplate(template: string);\n    protected subscription: Subscription;\n    /**\n     * Holds the current page template, so we can remove previous page templates\n     * from the element classList.\n     */\n    protected currentTemplate: string;\n    constructor(pageLayoutService: PageLayoutService, elementRef: ElementRef, templateRef: TemplateRef<HTMLElement>, cd: ChangeDetectorRef);\n    ngOnInit(): void;\n    /**\n     * Adds the page template as a style class to the given element. If any\n     * page template was added before, we clean it up.\n     *\n     * We'll not use hostBinding for the style class, as it will potential drop\n     * an existing class name on the host. This is why we need to work with\n     * the lower level change detection api.\n     */\n    protected addStyleClass(template: string, el?: HTMLElement): void;\n    /**\n     * Cleans up the class host binding, if a template class was assigned before.\n     */\n    protected clear(el?: HTMLElement): void;\n    /**\n     * Returns the host element (`HTMLElement`).\n     *\n     * If the directive is used on an `ng-template`, we take the parent element,\n     * to ensure that we're not ending up with a comment.\n     */\n    protected get host(): HTMLElement;\n    ngOnDestroy(): void;\n}\n"]}