import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, HostBinding, Input, isDevMode, } from '@angular/core';
/**
 * The table component provides a generic DOM structure based on the `dataset` input.
 * The `Table` dataset contains a type, table structure and table data.
 *
 * The table component only supports horizontal table structure.
 *
 * The implementation is fairly "dumb" and only provides the following features:
 * - Use outlet for table headers (`<th>`) and cells (`<td>`).
 * - Localizing table headers, using the `I18nModule`.
 * - Add CSS classes on each cell to
 *
 * Al features are optional.
 *
 * By default, the headers and columns are rendered with an outlet template. The template
 * reference is generated by concatenating the table `type` and table header `key`.
 * The following snippet shows an outlet generated for a table header, for the table type
 * "cost-center" with a label "name":
 *
 * ```
 * <th>
 *   <template cxOutlet="tbl.cost-center.header.name">
 *     [localized label is generated here]
 *   </template>
 * </th>
 * ```
 *
 * Similarly, the `<td>` is generated with the outlet template reference `tbl.cost-center.data.name`.
 *
 * This allows smart components to further customize the table rendering. More over, customers can
 * customize the header and data by using the generated outlets.
 */
var TableComponent = /** @class */ (function () {
    function TableComponent() {
    }
    Object.defineProperty(TableComponent.prototype, "dataset", {
        get: function () {
            return this._dataset;
        },
        set: function (dataset) {
            this._dataset = dataset;
            this.addTableDebugInfo();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the configured data value by the label key.
     * If there's no headerKey available, or no corresponding value, the
     * first value in the data row is returned.
     */
    TableComponent.prototype.getDataValue = function (dataRow, headerKey, index) {
        return dataRow[headerKey] || Object.values(dataRow)[index];
    };
    /**
     * Generates the table type into the UI in devMode, so that developers
     * can easily get the notion of the table type.
     */
    TableComponent.prototype.addTableDebugInfo = function () {
        var _a, _b;
        if (isDevMode) {
            this.tableType = (_b = (_a = this.dataset) === null || _a === void 0 ? void 0 : _a.structure) === null || _b === void 0 ? void 0 : _b.type;
        }
    };
    __decorate([
        HostBinding('attr.__cx-table-type')
    ], TableComponent.prototype, "tableType", void 0);
    __decorate([
        Input()
    ], TableComponent.prototype, "dataset", null);
    TableComponent = __decorate([
        Component({
            selector: 'cx-table',
            template: "<table *ngIf=\"dataset?.structure as structure\">\n  <thead *ngIf=\"!structure.hideHeader\">\n    <tr>\n      <th\n        scope=\"col\"\n        *ngFor=\"let header of structure.headers; let i = index\"\n        [class]=\"header.key\"\n      >\n        <!-- render an outlet for each column header -->\n        <ng-template\n          [cxOutlet]=\"\n            'table.' + structure.type + '.header.' + (header.key || i)\n          \"\n          [cxOutletContext]=\"header\"\n        >\n          <!-- Render the label by default, fallback to localize the label by it's key -->\n          {{\n            header.label || (structure.type + '.' + header.key | cxTranslate)\n          }}\n        </ng-template>\n      </th>\n    </tr>\n  </thead>\n\n  <tr *ngFor=\"let row of dataset.data$ | async\">\n    <td *ngFor=\"let col of structure.headers; let i = index\" [class]=\"col.key\">\n      <!-- render an outlet for each cell -->\n      <ng-template\n        [cxOutlet]=\"'table.' + structure.type + '.data.' + (col.key || i)\"\n        [cxOutletContext]=\"row\"\n      >\n        {{ getDataValue(row, col.key, i) }}\n      </ng-template>\n    </td>\n  </tr>\n</table>\n",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], TableComponent);
    return TableComponent;
}());
export { TableComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9zdG9yZWZyb250LyIsInNvdXJjZXMiOlsic2hhcmVkL2NvbXBvbmVudHMvdGFibGUvdGFibGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxXQUFXLEVBQ1gsS0FBSyxFQUNMLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUd2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOEJHO0FBTUg7SUFBQTtJQWdDQSxDQUFDO0lBM0JDLHNCQUFJLG1DQUFPO2FBS1g7WUFDRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQzthQVBELFVBQVksT0FBYztZQUN4QixJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztZQUN4QixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUMzQixDQUFDOzs7T0FBQTtJQU1EOzs7O09BSUc7SUFDSCxxQ0FBWSxHQUFaLFVBQWEsT0FBWSxFQUFFLFNBQWlCLEVBQUUsS0FBYTtRQUN6RCxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRDs7O09BR0c7SUFDTywwQ0FBaUIsR0FBM0I7O1FBQ0UsSUFBSSxTQUFTLEVBQUU7WUFDYixJQUFJLENBQUMsU0FBUyxlQUFHLElBQUksQ0FBQyxPQUFPLDBDQUFFLFNBQVMsMENBQUUsSUFBSSxDQUFDO1NBQ2hEO0lBQ0gsQ0FBQztJQTlCb0M7UUFBcEMsV0FBVyxDQUFDLHNCQUFzQixDQUFDO3FEQUFtQjtJQUl2RDtRQURDLEtBQUssRUFBRTtpREFJUDtJQVJVLGNBQWM7UUFMMUIsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLFVBQVU7WUFDcEIsZ3FDQUFxQztZQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtTQUNoRCxDQUFDO09BQ1csY0FBYyxDQWdDMUI7SUFBRCxxQkFBQztDQUFBLEFBaENELElBZ0NDO1NBaENZLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBIb3N0QmluZGluZyxcbiAgSW5wdXQsXG4gIGlzRGV2TW9kZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gJy4vdGFibGUubW9kZWwnO1xuXG4vKipcbiAqIFRoZSB0YWJsZSBjb21wb25lbnQgcHJvdmlkZXMgYSBnZW5lcmljIERPTSBzdHJ1Y3R1cmUgYmFzZWQgb24gdGhlIGBkYXRhc2V0YCBpbnB1dC5cbiAqIFRoZSBgVGFibGVgIGRhdGFzZXQgY29udGFpbnMgYSB0eXBlLCB0YWJsZSBzdHJ1Y3R1cmUgYW5kIHRhYmxlIGRhdGEuXG4gKlxuICogVGhlIHRhYmxlIGNvbXBvbmVudCBvbmx5IHN1cHBvcnRzIGhvcml6b250YWwgdGFibGUgc3RydWN0dXJlLlxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBmYWlybHkgXCJkdW1iXCIgYW5kIG9ubHkgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBmZWF0dXJlczpcbiAqIC0gVXNlIG91dGxldCBmb3IgdGFibGUgaGVhZGVycyAoYDx0aD5gKSBhbmQgY2VsbHMgKGA8dGQ+YCkuXG4gKiAtIExvY2FsaXppbmcgdGFibGUgaGVhZGVycywgdXNpbmcgdGhlIGBJMThuTW9kdWxlYC5cbiAqIC0gQWRkIENTUyBjbGFzc2VzIG9uIGVhY2ggY2VsbCB0b1xuICpcbiAqIEFsIGZlYXR1cmVzIGFyZSBvcHRpb25hbC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgaGVhZGVycyBhbmQgY29sdW1ucyBhcmUgcmVuZGVyZWQgd2l0aCBhbiBvdXRsZXQgdGVtcGxhdGUuIFRoZSB0ZW1wbGF0ZVxuICogcmVmZXJlbmNlIGlzIGdlbmVyYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSB0YWJsZSBgdHlwZWAgYW5kIHRhYmxlIGhlYWRlciBga2V5YC5cbiAqIFRoZSBmb2xsb3dpbmcgc25pcHBldCBzaG93cyBhbiBvdXRsZXQgZ2VuZXJhdGVkIGZvciBhIHRhYmxlIGhlYWRlciwgZm9yIHRoZSB0YWJsZSB0eXBlXG4gKiBcImNvc3QtY2VudGVyXCIgd2l0aCBhIGxhYmVsIFwibmFtZVwiOlxuICpcbiAqIGBgYFxuICogPHRoPlxuICogICA8dGVtcGxhdGUgY3hPdXRsZXQ9XCJ0YmwuY29zdC1jZW50ZXIuaGVhZGVyLm5hbWVcIj5cbiAqICAgICBbbG9jYWxpemVkIGxhYmVsIGlzIGdlbmVyYXRlZCBoZXJlXVxuICogICA8L3RlbXBsYXRlPlxuICogPC90aD5cbiAqIGBgYFxuICpcbiAqIFNpbWlsYXJseSwgdGhlIGA8dGQ+YCBpcyBnZW5lcmF0ZWQgd2l0aCB0aGUgb3V0bGV0IHRlbXBsYXRlIHJlZmVyZW5jZSBgdGJsLmNvc3QtY2VudGVyLmRhdGEubmFtZWAuXG4gKlxuICogVGhpcyBhbGxvd3Mgc21hcnQgY29tcG9uZW50cyB0byBmdXJ0aGVyIGN1c3RvbWl6ZSB0aGUgdGFibGUgcmVuZGVyaW5nLiBNb3JlIG92ZXIsIGN1c3RvbWVycyBjYW5cbiAqIGN1c3RvbWl6ZSB0aGUgaGVhZGVyIGFuZCBkYXRhIGJ5IHVzaW5nIHRoZSBnZW5lcmF0ZWQgb3V0bGV0cy5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtdGFibGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vdGFibGUuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgVGFibGVDb21wb25lbnQge1xuICBASG9zdEJpbmRpbmcoJ2F0dHIuX19jeC10YWJsZS10eXBlJykgdGFibGVUeXBlOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIF9kYXRhc2V0OiBUYWJsZTtcbiAgQElucHV0KClcbiAgc2V0IGRhdGFzZXQoZGF0YXNldDogVGFibGUpIHtcbiAgICB0aGlzLl9kYXRhc2V0ID0gZGF0YXNldDtcbiAgICB0aGlzLmFkZFRhYmxlRGVidWdJbmZvKCk7XG4gIH1cblxuICBnZXQgZGF0YXNldCgpOiBUYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFzZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29uZmlndXJlZCBkYXRhIHZhbHVlIGJ5IHRoZSBsYWJlbCBrZXkuXG4gICAqIElmIHRoZXJlJ3Mgbm8gaGVhZGVyS2V5IGF2YWlsYWJsZSwgb3Igbm8gY29ycmVzcG9uZGluZyB2YWx1ZSwgdGhlXG4gICAqIGZpcnN0IHZhbHVlIGluIHRoZSBkYXRhIHJvdyBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldERhdGFWYWx1ZShkYXRhUm93OiBhbnksIGhlYWRlcktleTogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZGF0YVJvd1toZWFkZXJLZXldIHx8IE9iamVjdC52YWx1ZXMoZGF0YVJvdylbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgdGFibGUgdHlwZSBpbnRvIHRoZSBVSSBpbiBkZXZNb2RlLCBzbyB0aGF0IGRldmVsb3BlcnNcbiAgICogY2FuIGVhc2lseSBnZXQgdGhlIG5vdGlvbiBvZiB0aGUgdGFibGUgdHlwZS5cbiAgICovXG4gIHByb3RlY3RlZCBhZGRUYWJsZURlYnVnSW5mbygpIHtcbiAgICBpZiAoaXNEZXZNb2RlKSB7XG4gICAgICB0aGlzLnRhYmxlVHlwZSA9IHRoaXMuZGF0YXNldD8uc3RydWN0dXJlPy50eXBlO1xuICAgIH1cbiAgfVxufVxuIl19