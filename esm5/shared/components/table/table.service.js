import { __assign, __decorate } from "tslib";
import { Injectable, isDevMode } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { BreakpointService } from '../../../layout/breakpoint/breakpoint.service';
import { TableConfig } from './config/table.config';
import * as i0 from "@angular/core";
import * as i1 from "../../../layout/breakpoint/breakpoint.service";
import * as i2 from "./config/table.config";
/**
 * Responsive table service.
 *
 * The `TableService` is used to generate a `TableStructure` based on configuration. The table
 * structure configuration allows for breakpoint specific configuration, so that the table
 * experience can be differentiated various screen sizes.
 *
 * The table structure configuration is driven by a table type. The various supported
 * table types are exposed in feature libraries.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data or randomly (in case no data is passed in) by
 * generating 5 headers. In case of a generated header, we warn the developer in devMode that
 * there is no configuration available.
 */
var TableService = /** @class */ (function () {
    function TableService(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
    }
    /**
     * Builds the table structure. The table structure can be created by the help of
     * the `tableType`. The `tableType` can be used in the configuration `TableConfig`,
     * so that the table headers can be defined.
     */
    TableService.prototype.buildStructure = function (tableType, data$) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType);
        }
        else {
            if (data$) {
                return this.buildStructureFromData(tableType, data$);
            }
            else {
                return this.buildRandomStructure(tableType);
            }
        }
    };
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    TableService.prototype.buildStructureFromConfig = function (type) {
        var _this = this;
        return this.breakpointService.breakpoint$.pipe(map(function (breakpoint) { return (__assign(__assign({}, _this.getTableConfig(type, breakpoint)), { type: type })); }));
    };
    /**
     * This method generates a table structure by the help of the first data row.
     */
    TableService.prototype.buildStructureFromData = function (type, data$) {
        this.warn("No table configuration found to render table with type \"" + type + "\". The table header for \"" + type + "\" is generated by the help of the first data item");
        return data$.pipe(map(function (data) {
            var headers = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map(function (key) { return ({
                key: key,
                label: key,
            }); });
            return {
                type: type,
                headers: headers,
            };
        }));
    };
    /**
     * As a last resort, the table structure is randomly created. We add 5 unknown headers
     * and use the `hideHeader` to avoid the unknown headers to be rendered.
     */
    TableService.prototype.buildRandomStructure = function (type) {
        this.warn("No data available for \"" + type + "\", a random structure is generated (with hidden table headers).");
        return of({
            type: type,
            headers: [
                { key: 'unknown' },
                { key: 'unknown' },
                { key: 'unknown' },
                { key: 'unknown' },
                { key: 'unknown' },
            ],
            hideHeader: true,
        });
    };
    /**
     * Finds the best applicable table configuration for the given type
     * and breakpoint. If there is no configuration available for the breakpoint,
     * the best match will be returned, using mobile first approach.
     *
     * If there is no match for any breakpoint, the fallback is a configuration
     * without the notion of a breakpoint. Otherwise we fallback to the first
     * available config.
     */
    TableService.prototype.getTableConfig = function (type, breakpoint) {
        var tableConfig = this.config.table[type];
        // find all relevant breakpoints
        var current = this.breakpointService.breakpoints.indexOf(breakpoint);
        var relevant = this.breakpointService.breakpoints
            .slice(0, current + 1)
            .reverse();
        var bestMatch = relevant.find(function (br) { return !!tableConfig.find(function (structure) { return structure.breakpoint === br; }); });
        return bestMatch
            ? tableConfig.find(function (config) { return config.breakpoint === bestMatch; })
            : tableConfig.find(function (structure) { return !structure.breakpoint; }) ||
                tableConfig[0];
    };
    TableService.prototype.hasTableConfig = function (tableType) {
        var _a;
        return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
    };
    /**
     * Prints a convenient message in the console to increase developer experience.
     */
    TableService.prototype.warn = function (message) {
        if (isDevMode) {
            console.warn(message);
        }
    };
    TableService.ctorParameters = function () { return [
        { type: BreakpointService },
        { type: TableConfig }
    ]; };
    TableService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TableService_Factory() { return new TableService(i0.ɵɵinject(i1.BreakpointService), i0.ɵɵinject(i2.TableConfig)); }, token: TableService, providedIn: "root" });
    TableService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], TableService);
    return TableService;
}());
export { TableService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbInNoYXJlZC9jb21wb25lbnRzL3RhYmxlL3RhYmxlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXRELE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLCtDQUErQyxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7OztBQUdwRDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUlIO0lBQ0Usc0JBQ1ksaUJBQW9DLEVBQ3BDLE1BQW1CO1FBRG5CLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDcEMsV0FBTSxHQUFOLE1BQU0sQ0FBYTtJQUM1QixDQUFDO0lBRUo7Ozs7T0FJRztJQUNILHFDQUFjLEdBQWQsVUFDRSxTQUFpQixFQUNqQixLQUF1QjtRQUV2QixJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDbEMsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDakQ7YUFBTTtZQUNMLElBQUksS0FBSyxFQUFFO2dCQUNULE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN0RDtpQkFBTTtnQkFDTCxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUM3QztTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLCtDQUF3QixHQUFsQyxVQUFtQyxJQUFZO1FBQS9DLGlCQUlDO1FBSEMsT0FBTyxJQUFJ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Q0FBQyxLQUFLLDBDQUFHLFNBQVMsRUFBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNLLDJCQUFJLEdBQVosVUFBYSxPQUFPO1FBQ2xCLElBQUksU0FBUyxFQUFFO1lBQ2IsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN2QjtJQUNILENBQUM7O2dCQTdIOEIsaUJBQWlCO2dCQUM1QixXQUFXOzs7SUFIcEIsWUFBWTtRQUh4QixVQUFVLENBQUM7WUFDVixVQUFVLEVBQUUsTUFBTTtTQUNuQixDQUFDO09BQ1csWUFBWSxDQWdJeEI7dUJBMUpEO0NBMEpDLEFBaElELElBZ0lDO1NBaElZLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJSRUFLUE9JTlQgfSBmcm9tICcuLi8uLi8uLi9sYXlvdXQvY29uZmlnL2xheW91dC1jb25maWcnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEJyZWFrcG9pbnRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vbGF5b3V0L2JyZWFrcG9pbnQvYnJlYWtwb2ludC5zZXJ2aWNlJztcbmltcG9ydCB7IFRhYmxlQ29uZmlnIH0gZnJvbSAnLi9jb25maWcvdGFibGUuY29uZmlnJztcbmltcG9ydCB7IFRhYmxlU3RydWN0dXJlLCBUYWJsZVN0cnVjdHVyZUNvbmZpZ3VyYXRpb24gfSBmcm9tICcuL3RhYmxlLm1vZGVsJztcblxuLyoqXG4gKiBSZXNwb25zaXZlIHRhYmxlIHNlcnZpY2UuXG4gKlxuICogVGhlIGBUYWJsZVNlcnZpY2VgIGlzIHVzZWQgdG8gZ2VuZXJhdGUgYSBgVGFibGVTdHJ1Y3R1cmVgIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb24uIFRoZSB0YWJsZVxuICogc3RydWN0dXJlIGNvbmZpZ3VyYXRpb24gYWxsb3dzIGZvciBicmVha3BvaW50IHNwZWNpZmljIGNvbmZpZ3VyYXRpb24sIHNvIHRoYXQgdGhlIHRhYmxlXG4gKiBleHBlcmllbmNlIGNhbiBiZSBkaWZmZXJlbnRpYXRlZCB2YXJpb3VzIHNjcmVlbiBzaXplcy5cbiAqXG4gKiBUaGUgdGFibGUgc3RydWN0dXJlIGNvbmZpZ3VyYXRpb24gaXMgZHJpdmVuIGJ5IGEgdGFibGUgdHlwZS4gVGhlIHZhcmlvdXMgc3VwcG9ydGVkXG4gKiB0YWJsZSB0eXBlcyBhcmUgZXhwb3NlZCBpbiBmZWF0dXJlIGxpYnJhcmllcy5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyB0YWJsZSBjb25maWd1cmF0aW9uIGZvciB0aGUgZ2l2ZW4gdHlwZSBmb3VuZCwgYSB0YWJsZSBoZWFkZXIgc3RydWN0dXJlXG4gKiBpcyBnZW5lcmF0ZWQgYmFzZWQgb24gdGhlIGFjdHVhbCBkYXRhIG9yIHJhbmRvbWx5IChpbiBjYXNlIG5vIGRhdGEgaXMgcGFzc2VkIGluKSBieVxuICogZ2VuZXJhdGluZyA1IGhlYWRlcnMuIEluIGNhc2Ugb2YgYSBnZW5lcmF0ZWQgaGVhZGVyLCB3ZSB3YXJuIHRoZSBkZXZlbG9wZXIgaW4gZGV2TW9kZSB0aGF0XG4gKiB0aGVyZSBpcyBubyBjb25maWd1cmF0aW9uIGF2YWlsYWJsZS5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBicmVha3BvaW50U2VydmljZTogQnJlYWtwb2ludFNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogVGFibGVDb25maWdcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIHRhYmxlIHN0cnVjdHVyZS4gVGhlIHRhYmxlIHN0cnVjdHVyZSBjYW4gYmUgY3JlYXRlZCBieSB0aGUgaGVscCBvZlxuICAgKiB0aGUgYHRhYmxlVHlwZWAuIFRoZSBgdGFibGVUeXBlYCBjYW4gYmUgdXNlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBgVGFibGVDb25maWdgLFxuICAgKiBzbyB0aGF0IHRoZSB0YWJsZSBoZWFkZXJzIGNhbiBiZSBkZWZpbmVkLlxuICAgKi9cbiAgYnVpbGRTdHJ1Y3R1cmUoXG4gICAgdGFibGVUeXBlOiBzdHJpbmcsXG4gICAgZGF0YSQ/OiBPYnNlcnZhYmxlPGFueT5cbiAgKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIGlmICh0aGlzLmhhc1RhYmxlQ29uZmlnKHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkU3RydWN0dXJlRnJvbUNvbmZpZyh0YWJsZVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0YSQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTdHJ1Y3R1cmVGcm9tRGF0YSh0YWJsZVR5cGUsIGRhdGEkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkUmFuZG9tU3RydWN0dXJlKHRhYmxlVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhYmxlIHN0cnVjdHVyZSBieSBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBjYW4gYmVcbiAgICogYnJlYWtwb2ludC1kcml2ZW4sIHdoaWNoIG1lYW5zIHRoYXQgYW4gYWx0ZXJuYXRpdmUgaGVhZGVyIHN0cnVjdHVyZSBjYW5cbiAgICogYmUgY3JlYXRlZCBwZXIgc2NyZWVuIHNpemUuXG4gICAqXG4gICAqIFRoZSBicmVha3BvaW50IGlzIHJlc29sdmVkIGJ5IHRlaCBgQnJlYWtwb2ludFNlcnZpY2VgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkU3RydWN0dXJlRnJvbUNvbmZpZyh0eXBlOiBzdHJpbmcpOiBPYnNlcnZhYmxlPFRhYmxlU3RydWN0dXJlPiB7XG4gICAgcmV0dXJuIHRoaXMuYnJlYWtwb2ludFNlcnZpY2UuYnJlYWtwb2ludCQucGlwZShcbiAgICAgIG1hcCgoYnJlYWtwb2ludCkgPT4gKHsgLi4udGhpcy5nZXRUYWJsZUNvbmZpZyh0eXBlLCBicmVha3BvaW50KSwgdHlwZSB9KSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIHRhYmxlIHN0cnVjdHVyZSBieSB0aGUgaGVscCBvZiB0aGUgZmlyc3QgZGF0YSByb3cuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRTdHJ1Y3R1cmVGcm9tRGF0YShcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgZGF0YSQ6IE9ic2VydmFibGU8YW55PlxuICApOiBPYnNlcnZhYmxlPFRhYmxlU3RydWN0dXJlPiB7XG4gICAgdGhpcy53YXJuKFxuICAgICAgYE5vIHRhYmxlIGNvbmZpZ3VyYXRpb24gZm91bmQgdG8gcmVuZGVyIHRhYmxlIHdpdGggdHlwZSBcIiR7dHlwZX1cIi4gVGhlIHRhYmxlIGhlYWRlciBmb3IgXCIke3R5cGV9XCIgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBoZWxwIG9mIHRoZSBmaXJzdCBkYXRhIGl0ZW1gXG4gICAgKTtcbiAgICByZXR1cm4gZGF0YSQucGlwZShcbiAgICAgIG1hcCgoZGF0YTogYW55W10pID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5rZXlzKGRhdGE/LlswXSkubWFwKChrZXkpID0+ICh7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGxhYmVsOiBrZXksXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0gYXMgVGFibGVTdHJ1Y3R1cmU7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQXMgYSBsYXN0IHJlc29ydCwgdGhlIHRhYmxlIHN0cnVjdHVyZSBpcyByYW5kb21seSBjcmVhdGVkLiBXZSBhZGQgNSB1bmtub3duIGhlYWRlcnNcbiAgICogYW5kIHVzZSB0aGUgYGhpZGVIZWFkZXJgIHRvIGF2b2lkIHRoZSB1bmtub3duIGhlYWRlcnMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRSYW5kb21TdHJ1Y3R1cmUodHlwZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUYWJsZVN0cnVjdHVyZT4ge1xuICAgIHRoaXMud2FybihcbiAgICAgIGBObyBkYXRhIGF2YWlsYWJsZSBmb3IgXCIke3R5cGV9XCIsIGEgcmFuZG9tIHN0cnVjdHVyZSBpcyBnZW5lcmF0ZWQgKHdpdGggaGlkZGVuIHRhYmxlIGhlYWRlcnMpLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIG9mKHtcbiAgICAgIHR5cGUsXG4gICAgICBoZWFkZXJzOiBbXG4gICAgICAgIHsga2V5OiAndW5rbm93bicgfSxcbiAgICAgICAgeyBrZXk6ICd1bmtub3duJyB9LFxuICAgICAgICB7IGtleTogJ3Vua25vd24nIH0sXG4gICAgICAgIHsga2V5OiAndW5rbm93bicgfSxcbiAgICAgICAgeyBrZXk6ICd1bmtub3duJyB9LFxuICAgICAgXSxcbiAgICAgIGhpZGVIZWFkZXI6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGJlc3QgYXBwbGljYWJsZSB0YWJsZSBjb25maWd1cmF0aW9uIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICAgKiBhbmQgYnJlYWtwb2ludC4gSWYgdGhlcmUgaXMgbm8gY29uZmlndXJhdGlvbiBhdmFpbGFibGUgZm9yIHRoZSBicmVha3BvaW50LFxuICAgKiB0aGUgYmVzdCBtYXRjaCB3aWxsIGJlIHJldHVybmVkLCB1c2luZyBtb2JpbGUgZmlyc3QgYXBwcm9hY2guXG4gICAqXG4gICAqIElmIHRoZXJlIGlzIG5vIG1hdGNoIGZvciBhbnkgYnJlYWtwb2ludCwgdGhlIGZhbGxiYWNrIGlzIGEgY29uZmlndXJhdGlvblxuICAgKiB3aXRob3V0IHRoZSBub3Rpb24gb2YgYSBicmVha3BvaW50LiBPdGhlcndpc2Ugd2UgZmFsbGJhY2sgdG8gdGhlIGZpcnN0XG4gICAqIGF2YWlsYWJsZSBjb25maWcuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VGFibGVDb25maWcoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGJyZWFrcG9pbnQ6IEJSRUFLUE9JTlRcbiAgKTogVGFibGVTdHJ1Y3R1cmVDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdCB0YWJsZUNvbmZpZyA9IHRoaXMuY29uZmlnLnRhYmxlW3R5cGVdO1xuXG4gICAgLy8gZmluZCBhbGwgcmVsZXZhbnQgYnJlYWtwb2ludHNcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5icmVha3BvaW50U2VydmljZS5icmVha3BvaW50cy5pbmRleE9mKGJyZWFrcG9pbnQpO1xuICAgIGNvbnN0IHJlbGV2YW50ID0gdGhpcy5icmVha3BvaW50U2VydmljZS5icmVha3BvaW50c1xuICAgICAgLnNsaWNlKDAsIGN1cnJlbnQgKyAxKVxuICAgICAgLnJldmVyc2UoKTtcblxuICAgIGNvbnN0IGJlc3RNYXRjaDogQlJFQUtQT0lOVCA9IHJlbGV2YW50LmZpbmQoXG4gICAgICAoYnIpID0+ICEhdGFibGVDb25maWcuZmluZCgoc3RydWN0dXJlKSA9PiBzdHJ1Y3R1cmUuYnJlYWtwb2ludCA9PT0gYnIpXG4gICAgKTtcblxuICAgIHJldHVybiBiZXN0TWF0Y2hcbiAgICAgID8gdGFibGVDb25maWcuZmluZCgoY29uZmlnKSA9PiBjb25maWcuYnJlYWtwb2ludCA9PT0gYmVzdE1hdGNoKVxuICAgICAgOiB0YWJsZUNvbmZpZy5maW5kKChzdHJ1Y3R1cmUpID0+ICFzdHJ1Y3R1cmUuYnJlYWtwb2ludCkgfHxcbiAgICAgICAgICB0YWJsZUNvbmZpZ1swXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYXNUYWJsZUNvbmZpZyh0YWJsZVR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuY29uZmlnLnRhYmxlPy5bdGFibGVUeXBlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmludHMgYSBjb252ZW5pZW50IG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgdG8gaW5jcmVhc2UgZGV2ZWxvcGVyIGV4cGVyaWVuY2UuXG4gICAqL1xuICBwcml2YXRlIHdhcm4obWVzc2FnZSkge1xuICAgIGlmIChpc0Rldk1vZGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==