{"version":3,"file":"lock-focus.directive.d.ts","sources":["lock-focus.directive.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { AfterViewInit, ElementRef, EventEmitter, OnInit, Renderer2 } from '@angular/core';\nimport { LockFocusConfig } from '../keyboard-focus.model';\nimport { TrapFocusDirective } from '../trap/trap-focus.directive';\nimport { LockFocusService } from './lock-focus.service';\n/**\n * Directive that adds persistence for focussed element in case\n * the elements are being rebuild. This happens often when change\n * detection kicks in because of new data set from the backend.\n */\nexport declare class LockFocusDirective extends TrapFocusDirective implements OnInit, AfterViewInit {\n    protected elementRef: ElementRef;\n    protected service: LockFocusService;\n    protected renderer: Renderer2;\n    protected defaultConfig: LockFocusConfig;\n    protected config: LockFocusConfig;\n    /**\n     * Indicates that the host is configured to use locking. This is available as a\n     * CSS class `focus-lock`.\n     */\n    shouldLock: boolean;\n    /**\n     * Indicates that the host is locked. This is available as a CSS class `is-locked`.\n     */\n    isLocked: boolean;\n    /**\n     * Emits an event when the host is unlocked.\n     */\n    unlock: EventEmitter<boolean>;\n    /**\n     * When the user selects enter or space, the focusable childs are\n     * unlocked, which means that the tabindex is set to 0.\n     */\n    handleEnter(event: KeyboardEvent): void;\n    /**\n     * In case any of the children elements is touched by the mouse,\n     * we unlock the group to not break the mouse-experience.\n     */\n    handleClick(event: UIEvent): void;\n    constructor(elementRef: ElementRef, service: LockFocusService, renderer: Renderer2);\n    protected lockFocus(): void;\n    protected unlockFocus(event?: UIEvent): void;\n    ngOnInit(): void;\n    ngAfterViewInit(): void;\n    handleFocus(event?: KeyboardEvent): void;\n    handleEscape(event: KeyboardEvent): void;\n    /**\n     * When the handleFocus is called without an actual event, it's coming from Autofocus.\n     * In this case we unlock the focusable children in case there's a focusable child that\n     * was unlocked before.\n     *\n     * We keep this private to not polute the API.\n     */\n    private shouldUnlockAfterAutofocus;\n    /**\n     * Add the tabindex attribute to the focusable children elements\n     */\n    protected addTabindexToChildren(i?: number): void;\n    /**\n     * Utility method, returns all focusable children for the host element.\n     *\n     * We keep this private to not polute the API.\n     */\n    private get hasFocusableChildren();\n    /**\n     * Returns the focusable children of the host element. If the host element\n     * is configured to be locked, the query is restricted to child elements\n     * with a tabindex !== `-1`.\n     *\n     * We keep this private to not polute the API.\n     */\n    private get focusable();\n}\n"]}