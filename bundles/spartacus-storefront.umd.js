(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@spartacus/core'), require('@angular/common'), require('@angular/platform-browser'), require('@angular/forms'), require('@angular/router'), require('@ng-select/ng-select'), require('@ng-bootstrap/ng-bootstrap'), require('@angular/common/http'), require('@angular/service-worker'), require('ngx-infinite-scroll'), require('@ngrx/store'), require('@ngrx/effects'), require('@ngrx/router-store')) :
    typeof define === 'function' && define.amd ? define('@spartacus/storefront', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@spartacus/core', '@angular/common', '@angular/platform-browser', '@angular/forms', '@angular/router', '@ng-select/ng-select', '@ng-bootstrap/ng-bootstrap', '@angular/common/http', '@angular/service-worker', 'ngx-infinite-scroll', '@ngrx/store', '@ngrx/effects', '@ngrx/router-store'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.spartacus = global.spartacus || {}, global.spartacus.storefront = {}), global.ng.core, global.rxjs, global.rxjs.operators, global.core, global.ng.common, global.ng.platformBrowser, global.ng.forms, global.ng.router, global.ngSelect, global.ngBootstrap, global.ng.common.http, global.ng.serviceWorker, global.ngxInfiniteScroll, global.store, global.effects, global.fromNgrxRouter));
}(this, (function (exports, i0, rxjs, operators, i1, i1$1, i1$2, forms, i4, ngSelect, i1$3, http, serviceWorker, ngxInfiniteScroll, i1$4, effects, routerStore) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * Types of dialog openings supported
     */
    (function (DIALOG_TYPE) {
        DIALOG_TYPE["POPOVER"] = "POPOVER";
        DIALOG_TYPE["POPOVER_CENTER"] = "POPOVER_CENTER";
        DIALOG_TYPE["POPOVER_CENTER_BACKDROP"] = "POPOVER_CENTER_BACKDROP";
        DIALOG_TYPE["DIALOG"] = "DIALOG";
        DIALOG_TYPE["SIDEBAR_START"] = "SIDEBAR_START";
        DIALOG_TYPE["SIDEBAR_END"] = "SIDEBAR_END";
    })(exports.DIALOG_TYPE || (exports.DIALOG_TYPE = {}));
    (function (LAUNCH_CALLER) {
        LAUNCH_CALLER["ASM"] = "ASM";
        LAUNCH_CALLER["SKIP_LINKS"] = "SKIP_LINKS";
        LAUNCH_CALLER["ANONYMOUS_CONSENT"] = "ANONYMOUS_CONSENT";
        LAUNCH_CALLER["REPLENISHMENT_ORDER"] = "REPLENISHMENT_ORDER";
        LAUNCH_CALLER["PLACE_ORDER_SPINNER"] = "PLACE_ORDER_SPINNER";
    })(exports.LAUNCH_CALLER || (exports.LAUNCH_CALLER = {}));

    (function (BREAKPOINT) {
        BREAKPOINT["xs"] = "xs";
        BREAKPOINT["sm"] = "sm";
        BREAKPOINT["md"] = "md";
        BREAKPOINT["lg"] = "lg";
        BREAKPOINT["xl"] = "xl";
    })(exports.BREAKPOINT || (exports.BREAKPOINT = {}));
    /**
     * The LayoutConfig supports the configuration of page slots by page templates
     * or page sections, such as headers and footers. The configuration also supports
     * adaptive design per breakpoint (not per device type), so that the DOM is (re)rendered
     * por a given breakpoint.
     */
    var LayoutConfig = /** @class */ (function () {
        function LayoutConfig() {
        }
        return LayoutConfig;
    }());
    LayoutConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function LayoutConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: LayoutConfig, providedIn: "root" });
    LayoutConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    var LaunchRenderStrategy = /** @class */ (function () {
        function LaunchRenderStrategy(document, rendererFactory) {
            this.document = document;
            this.rendererFactory = rendererFactory;
            // List of called references; only used for rendered elements
            this.renderedCallers = [];
            /**
             * Classes to apply to the component when the dialog is a DIALOG
             */
            this.dialogClasses = ['d-block', 'fade', 'modal', 'show'];
            /**
             * Classes to apply to the component when the dialog is a POPOVER
             */
            this.popoverClasses = ['cx-dialog-popover'];
            /**
             * Classes to apply to the component when the dialog is a POPOVER_CENTER
             */
            this.popoverCenterClasses = ['cx-dialog-popover-center'];
            /**
             * Classes to apply to the component when the dialog is a POPOVER_CENTER with a backdrop
             */
            this.popoverCenterBackdropClasses = [
                'cx-dialog-popover-center-backdrop',
            ];
            /**
             * Classes to apply to the component when the dialog is a SIDEBAR_END
             */
            this.sidebarEndClasses = ['cx-sidebar-end'];
            /**
             * Classes to apply to the component when the dialog is a SIDEBAR_START
             */
            this.sidebarStartClasses = ['cx-sidebar-start'];
            this.renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * Determines if element should render
         *
         * @param caller
         * @param config
         */
        LaunchRenderStrategy.prototype.shouldRender = function (caller, config) {
            return (Boolean(config.component) &&
                (this.renderedCallers.some(function (el) { return el.caller === caller; })
                    ? !!config.multi
                    : true));
        };
        LaunchRenderStrategy.prototype.applyClasses = function (component, dialogType) {
            var e_1, _b;
            var classes = [];
            // TODO: make classes configurable
            switch (dialogType) {
                case exports.DIALOG_TYPE.DIALOG:
                    classes = this.dialogClasses;
                    this.renderer.addClass(this.document.body, 'modal-open');
                    break;
                case exports.DIALOG_TYPE.POPOVER:
                    classes = this.popoverClasses;
                    break;
                case exports.DIALOG_TYPE.POPOVER_CENTER:
                    classes = this.popoverCenterClasses;
                    break;
                case exports.DIALOG_TYPE.POPOVER_CENTER_BACKDROP:
                    classes = this.popoverCenterBackdropClasses;
                    break;
                case exports.DIALOG_TYPE.SIDEBAR_END:
                    classes = this.sidebarEndClasses;
                    break;
                case exports.DIALOG_TYPE.SIDEBAR_START:
                    classes = this.sidebarStartClasses;
                    break;
            }
            try {
                for (var classes_1 = __values(classes), classes_1_1 = classes_1.next(); !classes_1_1.done; classes_1_1 = classes_1.next()) {
                    var newClass = classes_1_1.value;
                    this.renderer.addClass(component.location.nativeElement, newClass);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (classes_1_1 && !classes_1_1.done && (_b = classes_1.return)) _b.call(classes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Method to call when rendered element is destroyed
         * The element will be removed from the list of rendered elements
         *
         * @param caller
         * @param _config optional parameters used in children strategies
         */
        LaunchRenderStrategy.prototype.remove = function (caller, config) {
            var _a;
            this.renderedCallers = this.renderedCallers.filter(function (el) { return el.caller !== caller; });
            if (((_a = config) === null || _a === void 0 ? void 0 : _a.dialogType) === exports.DIALOG_TYPE.DIALOG) {
                this.renderer.removeClass(this.document.body, 'modal-open');
            }
        };
        LaunchRenderStrategy.prototype.getPriority = function () {
            return -10 /* LOW */; // low, as it's a default matcher
        };
        return LaunchRenderStrategy;
    }());
    LaunchRenderStrategy.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1$1.DOCUMENT,] }] },
        { type: i0.RendererFactory2 }
    ]; };

    var InlineRenderStrategy = /** @class */ (function (_super) {
        __extends(InlineRenderStrategy, _super);
        function InlineRenderStrategy(document, rendererFactory, componentFactoryResolver) {
            var _this = _super.call(this, document, rendererFactory) || this;
            _this.document = document;
            _this.rendererFactory = rendererFactory;
            _this.componentFactoryResolver = componentFactoryResolver;
            return _this;
        }
        /**
         * Renders the component from the configuration in the view container ref
         *
         * @param config
         * @param caller
         * @param vcr
         */
        InlineRenderStrategy.prototype.render = function (config, caller, vcr) {
            // Only render if a ViewContainerRef is provided
            if (vcr && this.shouldRender(caller, config)) {
                var template = this.componentFactoryResolver.resolveComponentFactory(config.component);
                var component = vcr.createComponent(template);
                if (config === null || config === void 0 ? void 0 : config.dialogType) {
                    this.applyClasses(component, config === null || config === void 0 ? void 0 : config.dialogType);
                }
                this.renderedCallers.push({ caller: caller, element: vcr.element, component: component });
                return rxjs.of(component);
            }
            else if (i0.isDevMode()) {
                if (!vcr) {
                    console.warn("No view container ref provided for " + caller);
                }
                else {
                    console.warn("Element for " + caller + " already rendered. To allow multi rendering add property multi: true.");
                }
            }
        };
        InlineRenderStrategy.prototype.hasMatch = function (config) {
            return Boolean(config.inline);
        };
        return InlineRenderStrategy;
    }(LaunchRenderStrategy));
    InlineRenderStrategy.ɵprov = i0.ɵɵdefineInjectable({ factory: function InlineRenderStrategy_Factory() { return new InlineRenderStrategy(i0.ɵɵinject(i1$1.DOCUMENT), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(i0.ComponentFactoryResolver)); }, token: InlineRenderStrategy, providedIn: "root" });
    InlineRenderStrategy.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    InlineRenderStrategy.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1$1.DOCUMENT,] }] },
        { type: i0.RendererFactory2 },
        { type: i0.ComponentFactoryResolver }
    ]; };

    var LaunchDialogService = /** @class */ (function () {
        function LaunchDialogService(renderStrategies, layoutConfig) {
            this.renderStrategies = renderStrategies;
            this.layoutConfig = layoutConfig;
            this._dialogClose = new rxjs.BehaviorSubject(undefined);
            this._dataSubject = new rxjs.BehaviorSubject(undefined);
            this.renderStrategies = this.renderStrategies || [];
        }
        Object.defineProperty(LaunchDialogService.prototype, "data$", {
            get: function () {
                return this._dataSubject.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Render the element based on the strategy from the launch configuration
         *
         * @param caller LAUNCH_CALLER
         * @param vcr View Container Ref of the container for inline rendering
         */
        LaunchDialogService.prototype.launch = function (caller, vcr, data) {
            var config = this.findConfiguration(caller);
            if (config) {
                var renderer = this.getStrategy(config);
                // Render if the strategy exists
                if (renderer) {
                    this._dialogClose.next(undefined);
                    this._dataSubject.next(data);
                    return renderer.render(config, caller, vcr);
                }
            }
            else if (i0.isDevMode()) {
                console.warn('No configuration provided for caller ' + caller);
            }
        };
        /**
         * Util method to remove element from rendered elements list
         *
         * @param caller LAUNCH_CALLER
         */
        LaunchDialogService.prototype.clear = function (caller) {
            var config = this.findConfiguration(caller);
            var renderer = this.getStrategy(config);
            // Render if the strategy exists
            if (renderer) {
                renderer.remove(caller, config);
            }
        };
        Object.defineProperty(LaunchDialogService.prototype, "dialogClose", {
            get: function () {
                return this._dialogClose.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        LaunchDialogService.prototype.closeDialog = function (reason) {
            this._dialogClose.next(reason);
        };
        /**
         * Returns the configuration for the caller
         *
         * @param caller LAUNCH_CALLER
         */
        LaunchDialogService.prototype.findConfiguration = function (caller) {
            var _a;
            if ((_a = this.layoutConfig) === null || _a === void 0 ? void 0 : _a.launch) {
                return this.layoutConfig.launch[caller];
            }
            return undefined;
        };
        /**
         * Returns the render strategy based on the configuration
         *
         * @param config Configuration for launch
         */
        LaunchDialogService.prototype.getStrategy = function (config) {
            return i1.resolveApplicable(this.renderStrategies, [config]);
        };
        return LaunchDialogService;
    }());
    LaunchDialogService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LaunchDialogService_Factory() { return new LaunchDialogService(i0.ɵɵinject(LaunchRenderStrategy), i0.ɵɵinject(LayoutConfig)); }, token: LaunchDialogService, providedIn: "root" });
    LaunchDialogService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    LaunchDialogService.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: i0.Inject, args: [LaunchRenderStrategy,] }] },
        { type: LayoutConfig }
    ]; };

    (function (OutletPosition) {
        OutletPosition["REPLACE"] = "replace";
        OutletPosition["BEFORE"] = "before";
        OutletPosition["AFTER"] = "after";
    })(exports.OutletPosition || (exports.OutletPosition = {}));
    var AVOID_STACKED_OUTLETS = false;
    var USE_STACKED_OUTLETS = true;
    /**
     * Token for injecting outlet related context to the component rendered in the outlet
     */
    var OutletContextData = /** @class */ (function () {
        function OutletContextData() {
        }
        return OutletContextData;
    }());

    var OutletService = /** @class */ (function () {
        function OutletService(features) {
            var _b;
            this.features = features;
            this.templatesRefs = (_b = {},
                _b[exports.OutletPosition.BEFORE] = new Map(),
                _b[exports.OutletPosition.REPLACE] = new Map(),
                _b[exports.OutletPosition.AFTER] = new Map(),
                _b);
        }
        /**
         * @param templateOrFactory A `ComponentFactory` that inserts a component dynamically.
         */
        OutletService.prototype.add = function (outlet, templateOrFactory, position) {
            if (position === void 0) { position = exports.OutletPosition.REPLACE; }
            var store = this.templatesRefs[position];
            if (store) {
                var existing = store.get(outlet) || [];
                var newValue = existing.concat([templateOrFactory]);
                store.set(outlet, newValue);
            }
        };
        /**
         *
         * Returns a single object or multiple objects for the given outlet reference,
         * depending on the `stacked` argument.
         *
         * @param outlet The outlet reference
         * @param position the outlet position, `OutletPosition.before`, `OutletPosition.AFTER` or `OutletPosition.REPLACE`
         * @param stacked Indicates whether an array of outlet components is returned
         */
        OutletService.prototype.get = function (outlet, position, stacked) {
            if (position === void 0) { position = exports.OutletPosition.REPLACE; }
            if (stacked === void 0) { stacked = AVOID_STACKED_OUTLETS; }
            var store = this.templatesRefs[position] ||
                this.templatesRefs[exports.OutletPosition.REPLACE];
            var templateRef = store.get(outlet);
            if (templateRef && !stacked) {
                return templateRef[0];
            }
            return templateRef;
        };
        OutletService.prototype.remove = function (outlet, position, value) {
            if (position === void 0) { position = exports.OutletPosition.REPLACE; }
            var store = this.templatesRefs[position] ||
                this.templatesRefs[exports.OutletPosition.REPLACE];
            this.removeValueOrAll(store, outlet, value);
        };
        OutletService.prototype.removeValueOrAll = function (store, outlet, value) {
            var _a;
            if (!value && store.has(outlet)) {
                store.delete(outlet);
            }
            else if (value && store.has(outlet)) {
                var existing = store.get(outlet);
                if ((_a = this.features) === null || _a === void 0 ? void 0 : _a.isLevel('2.1')) {
                    existing = existing.filter(function (val) { return val !== value; });
                }
                else {
                    // deprecated since 2.1, see #8116:
                    existing = existing.filter(function (val) { return val === value; });
                }
                store.set(outlet, existing);
            }
        };
        return OutletService;
    }());
    OutletService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OutletService_Factory() { return new OutletService(); }, token: OutletService, providedIn: "root" });
    OutletService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    OutletService.ctorParameters = function () { return [
        { type: i1.FeatureConfigService }
    ]; };

    var OutletRefDirective = /** @class */ (function () {
        function OutletRefDirective(tpl, outletService, features) {
            this.tpl = tpl;
            this.outletService = outletService;
            this.features = features;
        }
        OutletRefDirective.prototype.ngOnInit = function () {
            this.outletService.add(this.cxOutletRef, this.tpl, this.cxOutletPos);
        };
        OutletRefDirective.prototype.ngOnDestroy = function () {
            var _a;
            if ((_a = this.features) === null || _a === void 0 ? void 0 : _a.isLevel('2.1')) {
                this.outletService.remove(this.cxOutletRef, this.cxOutletPos, this.tpl);
            }
        };
        return OutletRefDirective;
    }());
    OutletRefDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cxOutletRef]',
                },] }
    ];
    OutletRefDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef },
        { type: OutletService },
        { type: i1.FeatureConfigService }
    ]; };
    OutletRefDirective.propDecorators = {
        cxOutletRef: [{ type: i0.Input }],
        cxOutletPos: [{ type: i0.Input }]
    };

    var OutletRefModule = /** @class */ (function () {
        function OutletRefModule() {
        }
        return OutletRefModule;
    }());
    OutletRefModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [OutletRefDirective],
                    exports: [OutletRefDirective],
                },] }
    ];

    var OutletRendererService = /** @class */ (function () {
        function OutletRendererService() {
            this.outletRefs = new rxjs.BehaviorSubject(new Map());
        }
        /**
         * Dynamically render the templates in the specified array
         *
         * @param outlet
         */
        OutletRendererService.prototype.render = function (outlet) {
            if (this.outletRefs.value.size !== 0) {
                this.outletRefs.value.get(outlet).render();
            }
        };
        /**
         * Register outlet to be available to render dynamically
         *
         * @param cxOutlet
         * @param context
         */
        OutletRendererService.prototype.register = function (cxOutlet, context) {
            this.outletRefs.next(this.outletRefs.value.set(cxOutlet, context));
        };
        /**
         * Returns map of outlets
         *
         */
        OutletRendererService.prototype.getOutletRef = function (outlet) {
            return this.outletRefs.asObservable().pipe(operators.map(function (val) { return val.get(outlet); }), operators.filter(function (val) { return Boolean(val); }));
        };
        return OutletRendererService;
    }());
    OutletRendererService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OutletRendererService_Factory() { return new OutletRendererService(); }, token: OutletRendererService, providedIn: "root" });
    OutletRendererService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * The IntersectionService uses the native IntersectionObserver (v2), which
     * can be used to implement pre-loading and deferred loading of DOM content.
     *
     */
    var IntersectionService = /** @class */ (function () {
        function IntersectionService(config) {
            this.config = config;
        }
        /**
         * Returns an Observable that emits only once a boolean value whenever
         * the given element has shown in the view port.
         *
         * The returned observable will only emit the first value. The
         * observable must be cleaned up either way, since the value might never emit; it
         *  depends on whether the element appears in the view port.
         */
        IntersectionService.prototype.isIntersected = function (element, options) {
            return this.intersects(element, options).pipe(operators.first(function (v) { return v === true; }));
        };
        /**
         * Indicates whenever the element intersects the view port. An optional margin
         * is used to intersects before the element shows up in the viewport.
         * A value is emitted each time the element intersects.
         *
         * This is private for now, but could be exposed as a public API
         * to introduce additional (css) render effects to the UI.
         */
        IntersectionService.prototype.intersects = function (element, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var elementVisible$ = new rxjs.Observable(function (observer) {
                var rootMargin = _this.getRootMargin(options);
                var intersectOptions = { rootMargin: rootMargin, threshold: options.threshold };
                var intersectionObserver = new IntersectionObserver(function (entries) {
                    observer.next(entries);
                }, intersectOptions);
                intersectionObserver.observe(element);
                return function () {
                    intersectionObserver.disconnect();
                };
            }).pipe(operators.flatMap(function (entries) { return entries; }), operators.map(function (entry) { return entry.isIntersecting; }), operators.distinctUntilChanged());
            return elementVisible$;
        };
        IntersectionService.prototype.getRootMargin = function (options) {
            if (options === void 0) { options = {}; }
            if (options.rootMargin) {
                return options.rootMargin;
            }
            var layoutConfig = this.config;
            if (layoutConfig.deferredLoading &&
                layoutConfig.deferredLoading.intersectionMargin) {
                return layoutConfig.deferredLoading.intersectionMargin;
            }
        };
        return IntersectionService;
    }());
    IntersectionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IntersectionService_Factory() { return new IntersectionService(i0.ɵɵinject(LayoutConfig)); }, token: IntersectionService, providedIn: "root" });
    IntersectionService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    IntersectionService.ctorParameters = function () { return [
        { type: LayoutConfig }
    ]; };

    /**
     * The defer loading serivce is used to defer loading of DOM elements
     * until the elements are required for the user experience.
     */
    var DeferLoaderService = /** @class */ (function () {
        function DeferLoaderService(platformId, config, intersectionService) {
            this.platformId = platformId;
            this.config = config;
            this.intersectionService = intersectionService;
            this.globalLoadStrategy = config.deferredLoading
                ? config.deferredLoading.strategy
                : i1.DeferLoadingStrategy.INSTANT;
        }
        /**
         * Defer loading till the element intersects the viewport.
         *
         * We evaluate whether we instantly load the element for different reasons:
         * - we run in SSR mode
         * - there's no global strategy given
         * - the global loading strategy is set to INSTANT loading,
         *   and the loading strategy in the given is not set to DEFER
         * - the loading strategy in the given options is set to INSTANT
         */
        DeferLoaderService.prototype.load = function (element, options) {
            if (this.shouldLoadInstantly((options || {}).deferLoading)) {
                return rxjs.of(true);
            }
            else {
                return this.intersectionService.isIntersected(element, options);
            }
        };
        DeferLoaderService.prototype.shouldLoadInstantly = function (elementLoadingStrategy) {
            return (i1$1.isPlatformServer(this.platformId) ||
                elementLoadingStrategy === i1.DeferLoadingStrategy.INSTANT ||
                (elementLoadingStrategy !== i1.DeferLoadingStrategy.DEFER &&
                    this.globalLoadStrategy === i1.DeferLoadingStrategy.INSTANT));
        };
        return DeferLoaderService;
    }());
    DeferLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeferLoaderService_Factory() { return new DeferLoaderService(i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(LayoutConfig), i0.ɵɵinject(IntersectionService)); }, token: DeferLoaderService, providedIn: "root" });
    DeferLoaderService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    DeferLoaderService.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: LayoutConfig },
        { type: IntersectionService }
    ]; };

    var OutletDirective = /** @class */ (function () {
        function OutletDirective(vcr, templateRef, outletService, deferLoaderService, outletRendererService) {
            this.vcr = vcr;
            this.templateRef = templateRef;
            this.outletService = outletService;
            this.deferLoaderService = deferLoaderService;
            this.outletRendererService = outletRendererService;
            this.renderedTemplate = [];
            this.renderedComponents = new Map();
            this.loaded = new i0.EventEmitter(true);
            this.subscription = new rxjs.Subscription();
        }
        OutletDirective.prototype.render = function () {
            this.vcr.clear();
            this.renderedTemplate = [];
            this.renderedComponents.clear();
            this.subscription.unsubscribe();
            this.subscription = new rxjs.Subscription();
            if (this.cxOutletDefer) {
                this.deferLoading();
            }
            else {
                this.build();
            }
        };
        OutletDirective.prototype.ngOnChanges = function (changes) {
            if (changes.cxOutlet) {
                this.render();
                this.outletRendererService.register(this.cxOutlet, this);
            }
        };
        OutletDirective.prototype.deferLoading = function () {
            var _this = this;
            this.loaded.emit(false);
            var hostElement = this.getHostElement(this.vcr.element.nativeElement);
            // Although the deferLoaderService might emit only once, as long as the hostElement
            // isn't being loaded, there's no value being emitted. Therefor we need to clean up
            // the subscription on destroy.
            this.subscription.add(this.deferLoaderService
                .load(hostElement, this.cxOutletDefer)
                .subscribe(function () {
                _this.build();
                _this.loaded.emit(true);
            }));
        };
        OutletDirective.prototype.build = function () {
            this.buildOutlet(exports.OutletPosition.BEFORE);
            this.buildOutlet(exports.OutletPosition.REPLACE);
            this.buildOutlet(exports.OutletPosition.AFTER);
        };
        OutletDirective.prototype.buildOutlet = function (position) {
            var _this = this;
            var templates = (this.outletService.get(this.cxOutlet, position, USE_STACKED_OUTLETS));
            templates = templates === null || templates === void 0 ? void 0 : templates.filter(function (el) { return !_this.renderedTemplate.includes(el); });
            if (!templates && position === exports.OutletPosition.REPLACE) {
                templates = [this.templateRef];
            }
            // Just in case someone extended the `OutletService` and
            // returns a singular object.
            if (!Array.isArray(templates)) {
                templates = [templates];
            }
            var components = [];
            templates.forEach(function (obj) {
                var component = _this.create(obj, position);
                components.push(component);
            });
            this.renderedComponents.set(position, components);
        };
        OutletDirective.prototype.create = function (tmplOrFactory, position) {
            this.renderedTemplate.push(tmplOrFactory);
            if (tmplOrFactory instanceof i0.ComponentFactory) {
                var component = this.vcr.createComponent(tmplOrFactory, undefined, this.getComponentInjector(position));
                return component;
            }
            else if (tmplOrFactory instanceof i0.TemplateRef) {
                var view = this.vcr.createEmbeddedView(tmplOrFactory, {
                    $implicit: this.cxOutletContext,
                });
                // we do not know if content is created dynamically or not
                // so we apply change detection anyway
                view.markForCheck();
                return view;
            }
        };
        /**
         * Returns injector with OutletContextData that can be injected to the component
         * rendered in the outlet
         */
        OutletDirective.prototype.getComponentInjector = function (position) {
            var contextData = {
                reference: this.cxOutlet,
                position: position,
                context: this.cxOutletContext,
            };
            return i0.Injector.create({
                providers: [
                    {
                        provide: OutletContextData,
                        useValue: contextData,
                    },
                ],
                parent: this.vcr.injector,
            });
        };
        /**
         * Returns the closest `HtmlElement`, by iterating over the
         * parent nodes of the given element.
         *
         * We avoid traversing the parent _elements_, as this is blocking
         * ie11 implementations. One of the spare exclusions we make to not
         * supporting ie11.
         *
         * @param element
         */
        OutletDirective.prototype.getHostElement = function (element) {
            if (element instanceof HTMLElement) {
                return element;
            }
            return this.getHostElement(element.parentNode);
        };
        OutletDirective.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return OutletDirective;
    }());
    OutletDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cxOutlet]',
                },] }
    ];
    OutletDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: i0.TemplateRef },
        { type: OutletService },
        { type: DeferLoaderService },
        { type: OutletRendererService }
    ]; };
    OutletDirective.propDecorators = {
        cxOutlet: [{ type: i0.Input }],
        cxOutletContext: [{ type: i0.Input }],
        cxOutletDefer: [{ type: i0.Input }],
        loaded: [{ type: i0.Output }]
    };

    var OutletModule = /** @class */ (function () {
        function OutletModule() {
        }
        return OutletModule;
    }());
    OutletModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [OutletDirective],
                    providers: [OutletService],
                    exports: [OutletDirective],
                },] }
    ];

    var OutletRenderStrategy = /** @class */ (function (_super) {
        __extends(OutletRenderStrategy, _super);
        function OutletRenderStrategy(document, rendererFactory, outletService, componentFactoryResolver, outletRendererService) {
            var _this = _super.call(this, document, rendererFactory) || this;
            _this.document = document;
            _this.rendererFactory = rendererFactory;
            _this.outletService = outletService;
            _this.componentFactoryResolver = componentFactoryResolver;
            _this.outletRendererService = outletRendererService;
            return _this;
        }
        /**
         * Renders the element in the configured outlet
         *
         * @param config
         * @param caller
         * @param vcr
         */
        OutletRenderStrategy.prototype.render = function (config, caller) {
            var _this = this;
            if (this.shouldRender(caller, config)) {
                var template_1 = this.componentFactoryResolver.resolveComponentFactory(config.component);
                this.outletService.add(config.outlet, template_1, config.position ? config.position : exports.OutletPosition.BEFORE);
                this.outletRendererService.render(config.outlet);
                this.renderedCallers.push({ caller: caller });
                return this.outletRendererService.getOutletRef(config.outlet).pipe(operators.map(function (outletDirective) {
                    var components = outletDirective.renderedComponents.get(config.position ? config.position : exports.OutletPosition.BEFORE);
                    return components
                        .reverse()
                        .find(function (component) { return component.componentType === template_1.componentType; });
                }), operators.tap(function (component) {
                    if (config === null || config === void 0 ? void 0 : config.dialogType) {
                        _this.applyClasses(component, config === null || config === void 0 ? void 0 : config.dialogType);
                    }
                }));
            }
        };
        OutletRenderStrategy.prototype.hasMatch = function (config) {
            return Boolean(config.outlet);
        };
        OutletRenderStrategy.prototype.remove = function (caller, config) {
            var template = this.componentFactoryResolver.resolveComponentFactory(config.component);
            this.outletService.remove(config.outlet, config.position ? config.position : exports.OutletPosition.BEFORE, template);
            _super.prototype.remove.call(this, caller, config);
        };
        return OutletRenderStrategy;
    }(LaunchRenderStrategy));
    OutletRenderStrategy.ɵprov = i0.ɵɵdefineInjectable({ factory: function OutletRenderStrategy_Factory() { return new OutletRenderStrategy(i0.ɵɵinject(i1$1.DOCUMENT), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(OutletService), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(OutletRendererService)); }, token: OutletRenderStrategy, providedIn: "root" });
    OutletRenderStrategy.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    OutletRenderStrategy.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1$1.DOCUMENT,] }] },
        { type: i0.RendererFactory2 },
        { type: OutletService },
        { type: i0.ComponentFactoryResolver },
        { type: OutletRendererService }
    ]; };

    var RoutingRenderStrategy = /** @class */ (function (_super) {
        __extends(RoutingRenderStrategy, _super);
        function RoutingRenderStrategy(document, rendererFactory, routingService) {
            var _this = _super.call(this, document, rendererFactory) || this;
            _this.document = document;
            _this.rendererFactory = rendererFactory;
            _this.routingService = routingService;
            return _this;
        }
        /**
         * Navigates to the route configured for the caller
         */
        RoutingRenderStrategy.prototype.render = function (config, _caller) {
            this.routingService.go(config);
        };
        RoutingRenderStrategy.prototype.hasMatch = function (config) {
            return Boolean(config.cxRoute);
        };
        return RoutingRenderStrategy;
    }(LaunchRenderStrategy));
    RoutingRenderStrategy.ɵprov = i0.ɵɵdefineInjectable({ factory: function RoutingRenderStrategy_Factory() { return new RoutingRenderStrategy(i0.ɵɵinject(i1$1.DOCUMENT), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(i1.RoutingService)); }, token: RoutingRenderStrategy, providedIn: "root" });
    RoutingRenderStrategy.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    RoutingRenderStrategy.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1$1.DOCUMENT,] }] },
        { type: i0.RendererFactory2 },
        { type: i1.RoutingService }
    ]; };

    var LaunchDialogModule = /** @class */ (function () {
        function LaunchDialogModule() {
        }
        LaunchDialogModule.forRoot = function () {
            return {
                ngModule: LaunchDialogModule,
                providers: [{ provide: LayoutConfig, useExisting: i1.Config }],
            };
        };
        return LaunchDialogModule;
    }());
    LaunchDialogModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: OutletRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: InlineRenderStrategy,
                            multi: true,
                        },
                        {
                            provide: LaunchRenderStrategy,
                            useExisting: RoutingRenderStrategy,
                            multi: true,
                        },
                    ],
                },] }
    ];

    var AnonymousConsentLaunchDialogService = /** @class */ (function () {
        function AnonymousConsentLaunchDialogService(launchDialogService) {
            this.launchDialogService = launchDialogService;
        }
        AnonymousConsentLaunchDialogService.prototype.openDialog = function (openElement, vcr) {
            var _this = this;
            var component = this.launchDialogService.launch(exports.LAUNCH_CALLER.ANONYMOUS_CONSENT, vcr);
            if (component) {
                return rxjs.combineLatest([
                    component,
                    this.launchDialogService.dialogClose,
                ]).pipe(operators.filter(function (_a) {
                    var _b = __read(_a, 2), close = _b[1];
                    return close && close !== undefined;
                }), operators.tap(function (_a) {
                    var _b = __read(_a, 1), comp = _b[0];
                    openElement === null || openElement === void 0 ? void 0 : openElement.nativeElement.focus();
                    _this.launchDialogService.clear(exports.LAUNCH_CALLER.ANONYMOUS_CONSENT);
                    comp.destroy();
                }), operators.map(function (_a) {
                    var _b = __read(_a, 1), comp = _b[0];
                    return comp;
                }));
            }
        };
        return AnonymousConsentLaunchDialogService;
    }());
    AnonymousConsentLaunchDialogService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AnonymousConsentLaunchDialogService_Factory() { return new AnonymousConsentLaunchDialogService(i0.ɵɵinject(LaunchDialogService)); }, token: AnonymousConsentLaunchDialogService, providedIn: "root" });
    AnonymousConsentLaunchDialogService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    AnonymousConsentLaunchDialogService.ctorParameters = function () { return [
        { type: LaunchDialogService }
    ]; };

    /** The element attribute used to store the focus state */
    var FOCUS_ATTR = 'data-cx-focus';
    /** The element attribute used to store the focus group state */
    var FOCUS_GROUP_ATTR = 'data-cx-focus-group';

    var BaseFocusService = /** @class */ (function () {
        function BaseFocusService() {
        }
        return BaseFocusService;
    }());
    BaseFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function BaseFocusService_Factory() { return new BaseFocusService(); }, token: BaseFocusService, providedIn: "root" });
    BaseFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Abstract directive that provides a common interface for all focus directives:
     * - Block Focus
     * - Persist Focus
     * - Escape Focus
     * - Auto Focus
     * - Tab Focus
     * - Trap Focus
     * - Lock Focus
     */
    var BaseFocusDirective = /** @class */ (function () {
        function BaseFocusDirective(elementRef, service) {
            this.elementRef = elementRef;
            this.service = service;
            /**
             * A default config can be provided for each directive if a specific focus directive
             * is used directly. i.e. `<div cxAutoFocus></div>`
             */
            this.defaultConfig = {};
        }
        BaseFocusDirective.prototype.ngOnInit = function () {
            this.setDefaultConfiguration();
            this.requiredTabindex = -1;
        };
        /**
         * Override the (input) config if it undefined or an empty string, with the
         * `defaultConfig`. The `defaultConfig` might be specified for each directive
         * differently. If a specific directive is used (i.e. `cxAutoFocus`), the
         * specific (inherited) defaultConfig will be used.
         */
        BaseFocusDirective.prototype.setDefaultConfiguration = function () {
            if ((!this.config || this.config === '') && this.defaultConfig) {
                this.config = this.defaultConfig;
            }
        };
        Object.defineProperty(BaseFocusDirective.prototype, "host", {
            /**
             * Helper method to return the host element for the directive
             * given by the `elementRef`.
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseFocusDirective.prototype, "requiredTabindex", {
            /**
             * Force a tabindex on the host element if it is _requried_ to make the element
             * focusable. If the element is focusable by nature or by a given tabindex, the
             * `tabindex` is not applied.
             *
             * Buttons, active links, etc. do no need an explicit tabindex to receive focus.
             */
            set: function (tabindex) {
                if (this.requiresExplicitTabIndex) {
                    this.tabindex = tabindex;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseFocusDirective.prototype, "requiresExplicitTabIndex", {
            /**
             * Returns true if the host element does not have a tabindex defined
             * and it also doesn't get focus by browsers nature (i.e. button or
             * active link).
             */
            get: function () {
                return (this.tabindex === undefined &&
                    ['button', 'input', 'select', 'textarea'].indexOf(this.host.tagName.toLowerCase()) === -1 &&
                    !(this.host.tagName === 'A' &&
                        (this.host.hasAttribute('href') || this.host.hasAttribute('routerlink'))));
            },
            enumerable: false,
            configurable: true
        });
        return BaseFocusDirective;
    }());
    BaseFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    BaseFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: BaseFocusService }
    ]; };
    BaseFocusDirective.propDecorators = {
        tabindex: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.tabindex',] }]
    };

    /**
     * Directive implementation that adds a CSS class to the host element
     * when the moused is used to focus an element. As soon as the keyboard
     * is used, the class is removed.
     *
     * This feature must be explicitly enabled with the `disableMouseFocus` config.
     *
     * The appearance of the visual focus depends on the CSS implementation to
     * begin with. Spartacus styles add a blue border around each focusable element.
     * This can be considered annoying by keyboard users, as they won't need such a
     * strong indication of the selected element.
     */
    var VisibleFocusDirective = /** @class */ (function (_super) {
        __extends(VisibleFocusDirective, _super);
        function VisibleFocusDirective() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.defaultConfig = {
                disableMouseFocus: true,
            };
            /** Controls a css class to hide focus visible CSS rules */
            _this.mouseFocus = false;
            return _this;
        }
        VisibleFocusDirective.prototype.handleMousedown = function () {
            if (this.shouldFocusVisible) {
                this.mouseFocus = true;
            }
        };
        VisibleFocusDirective.prototype.handleKeydown = function (event) {
            if (this.shouldFocusVisible) {
                this.mouseFocus = !this.isNavigating(event);
            }
        };
        Object.defineProperty(VisibleFocusDirective.prototype, "shouldFocusVisible", {
            /**
             * Indicates whether the configurations setup to disable visual focus.
             */
            get: function () {
                var _a;
                return (_a = this.config) === null || _a === void 0 ? void 0 : _a.disableMouseFocus;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Indicates whether the event is used to navigate the storefront. Some keyboard events
         * are used by mouse users to fill a form or interact with the OS or browser.
         */
        VisibleFocusDirective.prototype.isNavigating = function (event) {
            // when the cmd or ctrl keys are used, the user doesn't navigate the storefront
            if (event.metaKey) {
                return false;
            }
            // when the tab key is used, users are for navigating away from the current (form) element
            if (event.code === 'Tab') {
                return true;
            }
            // If the user fill in a form, we don't considering it part of storefront navigation.
            if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) {
                return false;
            }
            return true;
        };
        return VisibleFocusDirective;
    }(BaseFocusDirective));
    VisibleFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    VisibleFocusDirective.propDecorators = {
        mouseFocus: [{ type: i0.HostBinding, args: ['class.mouse-focus',] }],
        handleMousedown: [{ type: i0.HostListener, args: ['mousedown',] }],
        handleKeydown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    // { selector: '[cxBlockFocus]' }
    var BlockFocusDirective = /** @class */ (function (_super) {
        __extends(BlockFocusDirective, _super);
        function BlockFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = { block: true };
            // @Input('cxBlockFocus')
            _this.config = {};
            return _this;
        }
        BlockFocusDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            if (this.config.block) {
                this.tabindex = -1;
            }
        };
        return BlockFocusDirective;
    }(VisibleFocusDirective));
    BlockFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    BlockFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: BaseFocusService }
    ]; };

    var GLOBAL_GROUP = '_g_';
    /**
     * Shared service to persist the focus for an element or a group
     * of elements. The persisted element focus can be used to persist
     * the focus for a DOM tree, so that the focus remains after a repaint
     * or reoccurs when a DOM tree is "unlocked".
     */
    var PersistFocusService = /** @class */ (function (_super) {
        __extends(PersistFocusService, _super);
        function PersistFocusService() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            // this is going to fail as we have sub services. They will al have their own map.
            // We must bring this to a singleton map.
            _this.focus = new Map();
            return _this;
        }
        PersistFocusService.prototype.get = function (group) {
            return this.focus.get(group || GLOBAL_GROUP);
        };
        /**
         * Persist the keyboard focus state for the given key. The focus is stored globally
         * or for the given group.
         */
        PersistFocusService.prototype.set = function (key, group) {
            if (key) {
                this.focus.set(group || GLOBAL_GROUP, key);
            }
        };
        /**
         * Clears the persisted keyboard focus state globally or for the given group.
         */
        PersistFocusService.prototype.clear = function (group) {
            this.focus.delete(group || GLOBAL_GROUP);
        };
        /**
         * Returns the group for the host element based on the configured group or
         * by the `data-cx-focus-group` attribute stored on the host.
         */
        PersistFocusService.prototype.getPersistenceGroup = function (host, config) {
            return (config === null || config === void 0 ? void 0 : config.group) ? config.group : host.getAttribute(FOCUS_GROUP_ATTR);
        };
        return PersistFocusService;
    }(BaseFocusService));
    PersistFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PersistFocusService_Factory() { return new PersistFocusService(); }, token: PersistFocusService, providedIn: "root" });
    PersistFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Directive that provides persistence of the focused state. This is useful
     * when a group of focusable elements got refocused or even recreated. That
     * happens often when the DOM is constructed with an `*ngIf` or `*ngFor`.
     *
     * The focus state is based on a configured _key_, which can be passed in the
     * config input, either by using a string primitive or `PersistFocusConfig.key`:
     *
     * ```html
     * <button cxPersistFocus="myKey"></button>
     * <button cxFocus="myKey"></button>
     * <button [cxFocus]="{{key:'myKey'}"></button>
     * ```
     *
     * The focus state can be part of a focus _group_, so that the state is shared
     * and remember for the given group. In order to detect the persistence for a
     * given element, we store the persistence key as a data attribute (`data-cx-focus`):
     *
     * ```html
     * <button data-cx-focus="myKey"></button>
     * ```
     *
     * Other keyboard focus directives can read the key to understand whether the element
     * should retrieve focus.
     *
     */
    var PersistFocusDirective = /** @class */ (function (_super) {
        __extends(PersistFocusDirective, _super);
        function PersistFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = {};
            /**
             * The persistence key can be passed directly or through the `FocusConfig.key`.
             * While this could be considered a global key, the likeliness of conflicts
             * is very small since the key is cleared when the focus is changed.
             */
            // @Input('cxPersistFocus')
            _this.config = {};
            return _this;
        }
        PersistFocusDirective.prototype.handleFocus = function (event) {
            this.service.set(this.key, this.group);
            event === null || event === void 0 ? void 0 : event.preventDefault();
            event === null || event === void 0 ? void 0 : event.stopPropagation();
        };
        PersistFocusDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this.attr = this.key ? this.key : undefined;
        };
        PersistFocusDirective.prototype.setDefaultConfiguration = function () {
            if (typeof this.config === 'string' && this.config !== '') {
                this.config = { key: this.config };
            }
            _super.prototype.setDefaultConfiguration.call(this);
        };
        /**
         * Focus the element explicitly if it was focused before.
         */
        PersistFocusDirective.prototype.ngAfterViewInit = function () {
            if (this.isPersisted) {
                this.host.focus({ preventScroll: true });
            }
        };
        Object.defineProperty(PersistFocusDirective.prototype, "isPersisted", {
            get: function () {
                return !!this.key && this.service.get(this.group) === this.key;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PersistFocusDirective.prototype, "key", {
            /**
             * Returns the key for the host element, which is used to persist the
             * focus state. This is useful in cases where the DOM is rebuild.
             */
            get: function () {
                var _a;
                return (_a = this.config) === null || _a === void 0 ? void 0 : _a.key;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PersistFocusDirective.prototype, "group", {
            /**
             * returns the persistence group (if any) for the focusable elements.
             */
            get: function () {
                return this.service.getPersistenceGroup(this.host, this.config);
            },
            enumerable: false,
            configurable: true
        });
        return PersistFocusDirective;
    }(BlockFocusDirective));
    PersistFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    PersistFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: PersistFocusService }
    ]; };
    PersistFocusDirective.propDecorators = {
        attr: [{ type: i0.HostBinding, args: ["attr." + FOCUS_ATTR,] }],
        handleFocus: [{ type: i0.HostListener, args: ['focus', ['$event'],] }]
    };

    var SelectFocusUtility = /** @class */ (function () {
        function SelectFocusUtility() {
            /**
             * Query selectors used to query focusable child elements of the host element.
             * The selectors are supplemented with `:not([disabled])` and `:not([hidden])`.
             */
            this.focusableSelectors = [
                'a[href]',
                'button',
                '[tabindex]',
                'input',
                'select',
                'textarea',
            ];
            // like to leave out the following as we don't use it, and make this list exensible.
            //   `[contentEditable=true]`, // very unlikely to suport as we're not a business tool
            //   `iframe`, // we really don't like iframes...
            //   `area[href]`, // very debatable!
            this.focusableSelectorSuffix = ':not([disabled]):not([hidden])';
        }
        SelectFocusUtility.prototype.query = function (host, selector) {
            if (!selector || selector === '') {
                return [];
            }
            return Array.from(host.querySelectorAll(selector));
        };
        SelectFocusUtility.prototype.findFirstFocusable = function (host, config) {
            var _this = this;
            if (config === void 0) { config = { autofocus: true }; }
            var selector = typeof (config === null || config === void 0 ? void 0 : config.autofocus) === 'string' ? config.autofocus : '[autofocus]';
            // fallback to first focusable
            return (this.query(host, selector).find(function (el) { return !_this.isHidden(el); }) ||
                this.findFocusable(host).find(function (el) { return Boolean(el); }));
        };
        /**
         * returns all focusable child elements of the host element. The element selectors
         * are build from the `focusableSelectors`.
         *
         * @param host the `HTMLElement` used to query focusable elements
         * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
         * @param invisible indicates whether hidden focusable elements should be returned
         */
        SelectFocusUtility.prototype.findFocusable = function (host, locked, invisible) {
            var _this = this;
            if (locked === void 0) { locked = false; }
            if (invisible === void 0) { invisible = false; }
            var suffix = this.focusableSelectorSuffix;
            if (!locked) {
                suffix += ":not([tabindex='-1'])";
            }
            var selector = this.focusableSelectors
                .map(function (s) { return (s += suffix); })
                .join(',');
            return this.query(host, selector).filter(function (el) { return !invisible ? !_this.isHidden(el) : Boolean(el); });
        };
        /**
         * Indicates whether the element is hidden by CSS. There are various CSS rules and
         * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
         * of null indicates that the element or any of it's decendants is hidden (`display:none`).
         *
         * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
         * phyisical location on the element itself or any of it's anchestor elements. Those
         * technique require to work with the _computed styles_, which will cause a performance
         * downgrade. We don't do this in the standard implementaton.
         */
        SelectFocusUtility.prototype.isHidden = function (el) {
            return el.offsetParent === null;
        };
        return SelectFocusUtility;
    }());
    SelectFocusUtility.ɵprov = i0.ɵɵdefineInjectable({ factory: function SelectFocusUtility_Factory() { return new SelectFocusUtility(); }, token: SelectFocusUtility, providedIn: "root" });
    SelectFocusUtility.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var EscapeFocusService = /** @class */ (function (_super) {
        __extends(EscapeFocusService, _super);
        function EscapeFocusService(selectFocusUtil) {
            var _this = _super.call(this) || this;
            _this.selectFocusUtil = selectFocusUtil;
            return _this;
        }
        EscapeFocusService.prototype.shouldFocus = function (config) {
            return !!(config === null || config === void 0 ? void 0 : config.focusOnEscape);
        };
        EscapeFocusService.prototype.handleEscape = function (host, config, event) {
            var _a;
            if (this.shouldFocus(config)) {
                if (host !== event.target) {
                    host.focus({ preventScroll: true });
                    event.preventDefault();
                    event.stopPropagation();
                }
                else {
                    if (config === null || config === void 0 ? void 0 : config.focusOnDoubleEscape) {
                        (_a = this.selectFocusUtil
                            .findFirstFocusable(host, { autofocus: true })) === null || _a === void 0 ? void 0 : _a.focus();
                    }
                }
            }
        };
        return EscapeFocusService;
    }(PersistFocusService));
    EscapeFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function EscapeFocusService_Factory() { return new EscapeFocusService(i0.ɵɵinject(SelectFocusUtility)); }, token: EscapeFocusService, providedIn: "root" });
    EscapeFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    EscapeFocusService.ctorParameters = function () { return [
        { type: SelectFocusUtility }
    ]; };

    /**
     * Directive to focus the host element whenever the `escape` key is captured.
     * UiEvents bubble up by nature, which is why the `cxEscGroup` can be used
     * on a tree of elements. Each time the escape key is used, the focus will
     * move up in the DOM tree.
     *
     */
    var EscapeFocusDirective = /** @class */ (function (_super) {
        __extends(EscapeFocusDirective, _super);
        function EscapeFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = { focusOnEscape: true };
            _this.esc = new i0.EventEmitter();
            return _this;
        }
        /**
         * Handles the escape key event.
         * @param event the native keyboard event which contains the escape keydown event
         */
        EscapeFocusDirective.prototype.handleEscape = function (event) {
            if (this.service.shouldFocus(this.config)) {
                this.service.handleEscape(this.host, this.config, event);
            }
            this.esc.emit(this.service.shouldFocus(this.config));
        };
        EscapeFocusDirective.prototype.ngOnInit = function () {
            if (this.service.shouldFocus(this.config)) {
                this.requiredTabindex = -1;
            }
            _super.prototype.ngOnInit.call(this);
        };
        return EscapeFocusDirective;
    }(PersistFocusDirective));
    EscapeFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    EscapeFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: EscapeFocusService }
    ]; };
    EscapeFocusDirective.propDecorators = {
        esc: [{ type: i0.Output }],
        handleEscape: [{ type: i0.HostListener, args: ['keydown.escape', ['$event'],] }]
    };

    var AutoFocusService = /** @class */ (function (_super) {
        __extends(AutoFocusService, _super);
        function AutoFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the first focusable child element of the host element.
         */
        AutoFocusService.prototype.findFirstFocusable = function (host, config) {
            if (config === void 0) { config = { autofocus: true }; }
            if ((config === null || config === void 0 ? void 0 : config.autofocus) === ':host') {
                return host;
            }
            else if (this.hasPersistedFocus(host, config)) {
                return this.getPersisted(host, this.getPersistenceGroup(host, config));
            }
            else {
                return this.selectFocusUtil.findFirstFocusable(host, config) || host;
            }
        };
        /**
         * Indicates whether any of the focusabe child elements is focused.
         */
        AutoFocusService.prototype.hasPersistedFocus = function (host, config) {
            return !!this.getPersisted(host, this.getPersistenceGroup(host, config));
        };
        /**
         * Returns the element that has a persisted focus state.
         *
         * @param host the `HTMLElement` used to query for focusable children
         * @param group the optional group for the persistent state, to separate different focus
         *   groups and remain the persistence
         */
        AutoFocusService.prototype.getPersisted = function (host, group) {
            if (!this.get(group)) {
                return;
            }
            var focussed = Array.from(host.querySelectorAll("[" + FOCUS_ATTR + "='" + this.get(group) + "']"));
            return focussed.length > 0 ? focussed[0] : null;
        };
        return AutoFocusService;
    }(EscapeFocusService));
    AutoFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AutoFocusService_Factory() { return new AutoFocusService(i0.ɵɵinject(SelectFocusUtility)); }, token: AutoFocusService, providedIn: "root" });
    AutoFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Directive that focus the first nested _focusable_ element based on state and configuration:
     *
     * 1. focusable element that was left in a focused state (aka _persisted_ focus)
     * 2. focusable element selected by configured CSS selector (i.e. 'button[type=submit]')
     * 3. focusable element marked with the native HTML5 `autofocus` attribute
     * 4. first focusable element
     * 5. the host element, in case the configured CSS selector is `:host`.
     *
     * Example configurations:
     *
     * `<div cxAutoFocus>[...]</div>`
     *
     * `<div [cxAutoFocus]="{autofocus: false}">[...]</div>`
     *
     * `<div [cxAutoFocus]="{autofocus: 'button.active'}">[...]</div>`
     *
     * `<div [cxAutoFocus]="{autofocus: ':host'}">[...]</div>`
     *
     */
    var AutoFocusDirective = /** @class */ (function (_super) {
        __extends(AutoFocusDirective, _super);
        function AutoFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            /** The AutoFocusDirective will be using autofocus by default  */
            _this.defaultConfig = { autofocus: true };
            return _this;
        }
        /**
         * Focus the element explicitly if it was focussed before.
         */
        AutoFocusDirective.prototype.ngAfterViewInit = function () {
            if (this.shouldAutofocus) {
                this.handleFocus();
            }
            if (!this.shouldAutofocus || this.hasPersistedFocus) {
                _super.prototype.ngAfterViewInit.call(this);
            }
        };
        /**
         * Mimic the focus without setting the actual focus on the host. The first
         * focusable child element will be focussed.
         */
        AutoFocusDirective.prototype.handleFocus = function (event) {
            var _a;
            if (this.shouldAutofocus) {
                if (!(event === null || event === void 0 ? void 0 : event.target) || event.target === this.host) {
                    (_a = this.firstFocusable) === null || _a === void 0 ? void 0 : _a.focus();
                }
                else {
                    event.target.focus();
                }
            }
            _super.prototype.handleFocus.call(this, event);
        };
        Object.defineProperty(AutoFocusDirective.prototype, "hasPersistedFocus", {
            /**
             * Helper function to get the first focusable child element
             */
            get: function () {
                return this.service.hasPersistedFocus(this.host, this.config);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoFocusDirective.prototype, "shouldAutofocus", {
            /**
             * Helper function to indicate whether we should use autofocus for the
             * child elements.
             */
            get: function () {
                var _a;
                return !!((_a = this.config) === null || _a === void 0 ? void 0 : _a.autofocus);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoFocusDirective.prototype, "firstFocusable", {
            /**
             * Helper function to get the first focusable child element.
             *
             * We keep this private to not polute the API.
             */
            get: function () {
                return this.service.findFirstFocusable(this.host, this.config);
            },
            enumerable: false,
            configurable: true
        });
        return AutoFocusDirective;
    }(EscapeFocusDirective));
    AutoFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    AutoFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: AutoFocusService }
    ]; };

    var TabFocusService = /** @class */ (function (_super) {
        __extends(TabFocusService, _super);
        function TabFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Moves to the next (or previous) tab.
         */
        TabFocusService.prototype.moveTab = function (host, config, increment, event) {
            if (config === null || config === void 0 ? void 0 : config.tab) {
                var next = config.tab === 'scroll'
                    ? this.findNextScrollable(host, config, increment)
                    : this.findNext(host, config, increment);
                next === null || next === void 0 ? void 0 : next.focus();
                event.preventDefault();
                event.stopPropagation();
            }
        };
        /**
         * builds out virtual slides out of the full scrollable area, to allow
         * for maximum flexibility for the underlying layout without using hardcoded
         * slide sizes.
         */
        TabFocusService.prototype.findNextScrollable = function (host, config, increment) {
            var _a;
            var active = this.getActiveChild(host, config);
            if (!active) {
                return;
            }
            // slide count
            var virtualSlideCount = Math.round(host.scrollWidth / host.clientWidth);
            // find current virtual slide
            var currentVirtualSlide = Math.round(active.offsetLeft / (host.scrollWidth / virtualSlideCount));
            var nextVirtualSlide = currentVirtualSlide + increment;
            if (increment === 1 /* NEXT */ &&
                nextVirtualSlide >= virtualSlideCount) {
                nextVirtualSlide = 0;
            }
            if (increment === -1 /* PREV */ && nextVirtualSlide < 0) {
                nextVirtualSlide = virtualSlideCount - 1;
            }
            var firstItemOnNextSlide = (_a = this.getChildren(host, config)) === null || _a === void 0 ? void 0 : _a.find(function (tab) { return tab.offsetLeft >=
                (host.scrollWidth / virtualSlideCount) * nextVirtualSlide; });
            return firstItemOnNextSlide;
        };
        TabFocusService.prototype.findNext = function (host, config, increment) {
            var _this = this;
            var childs = this.getChildren(host, config);
            var activeIndex = childs === null || childs === void 0 ? void 0 : childs.findIndex(function (c) { return c === _this.getActiveChild(host, config); });
            if (!activeIndex || activeIndex === -1) {
                activeIndex = 0;
            }
            activeIndex += increment;
            if (increment === 1 /* NEXT */ && activeIndex >= (childs === null || childs === void 0 ? void 0 : childs.length)) {
                activeIndex = childs.length - 1;
            }
            if (increment === -1 /* PREV */ && activeIndex < 0) {
                activeIndex = 0;
            }
            return childs ? childs[activeIndex] : undefined;
        };
        /**
         * Returns the active focusable child element. If there's no active
         * focusable child element, the first focusable child is returned.
         */
        TabFocusService.prototype.getActiveChild = function (host, config) {
            var _this = this;
            var persisted = this.getPersisted(host, config === null || config === void 0 ? void 0 : config.group);
            if (persisted) {
                return persisted;
            }
            var children = this.getChildren(host, config);
            var index = children.findIndex(function (tab) { return _this.isActive(tab); });
            if (!index || index === -1) {
                index = 0;
            }
            return children[index];
        };
        TabFocusService.prototype.getChildren = function (host, config) {
            if (typeof config.tab === 'string' && config.tab !== 'scroll') {
                return this.selectFocusUtil.query(host, config.tab);
            }
            else {
                return this.findFocusable(host, true);
            }
        };
        /**
         * Returns all focusable child elements of the host element.
         *
         * @param host The host element is used to query child focusable elements.
         * @param locked Indicates if locked elements (tabindex=-1) should be returned, defaults to false.
         * @param invisible Indicates if invisible child elements should be returned, defaults to false.
         */
        TabFocusService.prototype.findFocusable = function (host, locked, invisible) {
            if (locked === void 0) { locked = false; }
            if (invisible === void 0) { invisible = false; }
            return this.selectFocusUtil.findFocusable(host, locked, invisible);
        };
        TabFocusService.prototype.isActive = function (el) {
            var child = document.activeElement;
            var selector = child.tagName;
            return (el === child ||
                !!Array.from(el.querySelectorAll(selector)).find(function (e) { return e === child; }));
        };
        return TabFocusService;
    }(AutoFocusService));
    TabFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TabFocusService_Factory() { return new TabFocusService(i0.ɵɵinject(SelectFocusUtility)); }, token: TabFocusService, providedIn: "root" });
    TabFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Directive to move the focus of ("locked") child elements. This is useful
     * for a nested list of tabs, carousel slides or any group of elements that
     * requires horizontal navigation.
     */
    var TabFocusDirective = /** @class */ (function (_super) {
        __extends(TabFocusDirective, _super);
        function TabFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            /** `tab` defaults to true if the directive `cxTabFocus` is used. */
            _this.defaultConfig = { tab: true };
            // @Input('cxTabFocus')
            _this.config = {};
            return _this;
        }
        TabFocusDirective.prototype.handleNextTab = function (event) {
            var _a;
            if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
                this.service.moveTab(this.host, this.config, 1 /* NEXT */, event);
            }
        };
        TabFocusDirective.prototype.handlePreviousTab = function (event) {
            var _a;
            if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
                this.service.moveTab(this.host, this.config, -1 /* PREV */, event);
            }
        };
        return TabFocusDirective;
    }(AutoFocusDirective));
    TabFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    TabFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: TabFocusService }
    ]; };
    TabFocusDirective.propDecorators = {
        handleNextTab: [{ type: i0.HostListener, args: ['keydown.arrowRight', ['$event'],] }],
        handlePreviousTab: [{ type: i0.HostListener, args: ['keydown.arrowLeft', ['$event'],] }]
    };

    var TrapFocusService = /** @class */ (function (_super) {
        __extends(TrapFocusService, _super);
        function TrapFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Indicates whether any of the child elements of the host are focusable.
         *
         * @param host `HTMLElement` that is used to query the focusable elements.
         */
        TrapFocusService.prototype.hasFocusableChildren = function (host) {
            return this.findFocusable(host).length > 0;
        };
        /**
         * Focus the next or previous element of all available focusable elements.
         * The focus is _trapped_ in case there's no next or previous available element.
         * The focus will automatically move the start or end of the list.
         */
        TrapFocusService.prototype.moveFocus = function (host, config, increment, event) {
            var focusable = this.findFocusable(host);
            var index = focusable.findIndex(function (v) { return v === event.target; }) + increment;
            var shouldMoveFocus = (index >= 0 && index < focusable.length) ||
                (index < 0 && this.getTrapStart(config.trap)) ||
                (index >= focusable.length && this.getTrapEnd(config.trap));
            if (shouldMoveFocus) {
                if (index >= focusable.length) {
                    index = 0;
                }
                if (index < 0) {
                    index = focusable.length - 1;
                }
                event.preventDefault();
                event.stopPropagation();
                var el = focusable[index];
                el.focus();
            }
        };
        TrapFocusService.prototype.getTrapStart = function (trap) {
            return trap === true || trap === 'start';
        };
        TrapFocusService.prototype.getTrapEnd = function (trap) {
            return trap === true || trap === 'end';
        };
        return TrapFocusService;
    }(TabFocusService));
    TrapFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TrapFocusService_Factory() { return new TrapFocusService(i0.ɵɵinject(SelectFocusUtility)); }, token: TrapFocusService, providedIn: "root" });
    TrapFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Directive that keeps the focus inside the focussable child elements,
     * also known as a _focus trap_.
     */
    var TrapFocusDirective = /** @class */ (function (_super) {
        __extends(TrapFocusDirective, _super);
        function TrapFocusDirective(elementRef, service) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.defaultConfig = { trap: true };
            // @Input('cxTrapFocus')
            _this.config = {};
            _this.handleTrapDown = function (event) {
                if (!!_this.config.trap) {
                    _this.moveFocus(event, 1 /* NEXT */);
                }
            };
            _this.handleTrapUp = function (event) {
                if (!!_this.config.trap) {
                    _this.moveFocus(event, -1 /* PREV */);
                }
            };
            return _this;
        }
        /**
         * Moves the focus of the element reference up or down, depending on the increment.
         * The focus of the element is trapped to avoid it from going out of the group.
         *
         * @param event UIEvent that is used to get the target element. The event is blocked
         *   from standard execution and further bubbling.
         * @param increment indicates whether the next or previous is focussed.
         */
        TrapFocusDirective.prototype.moveFocus = function (event, increment) {
            if (this.service.hasFocusableChildren(this.host)) {
                this.service.moveFocus(this.host, this.config, increment, event);
            }
        };
        return TrapFocusDirective;
    }(TabFocusDirective));
    TrapFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    TrapFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: TrapFocusService }
    ]; };
    TrapFocusDirective.propDecorators = {
        handleTrapDown: [{ type: i0.HostListener, args: ['keydown.arrowdown', ['$event'],] }, { type: i0.HostListener, args: ['keydown.tab', ['$event'],] }],
        handleTrapUp: [{ type: i0.HostListener, args: ['keydown.arrowup', ['$event'],] }, { type: i0.HostListener, args: ['keydown.shift.tab', ['$event'],] }]
    };

    var LockFocusService = /** @class */ (function (_super) {
        __extends(LockFocusService, _super);
        function LockFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return LockFocusService;
    }(TrapFocusService));
    LockFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LockFocusService_Factory() { return new LockFocusService(i0.ɵɵinject(SelectFocusUtility)); }, token: LockFocusService, providedIn: "root" });
    LockFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Focusable elements exclude hidden elements by default, but this contradicts with
     * unlocking (hidden) elements.
     */
    var UNLOCK_HIDDEN_ELEMENTS = true;
    /**
     * Directive that adds persistence for focussed element in case
     * the elements are being rebuild. This happens often when change
     * detection kicks in because of new data set from the backend.
     */
    var LockFocusDirective = /** @class */ (function (_super) {
        __extends(LockFocusDirective, _super);
        function LockFocusDirective(elementRef, service, renderer) {
            var _this = _super.call(this, elementRef, service) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.renderer = renderer;
            _this.defaultConfig = { lock: true };
            // @Input('cxLockFocus')
            _this.config = {};
            /**
             * Emits an event when the host is unlocked.
             */
            _this.unlock = new i0.EventEmitter();
            return _this;
        }
        /**
         * When the user selects enter or space, the focusable childs are
         * unlocked, which means that the tabindex is set to 0.
         */
        LockFocusDirective.prototype.handleEnter = function (event) {
            if (this.shouldLock && this.host === event.target) {
                this.unlockFocus(event);
                event.preventDefault();
                event.stopPropagation();
            }
        };
        /**
         * In case any of the children elements is touched by the mouse,
         * we unlock the group to not break the mouse-experience.
         */
        LockFocusDirective.prototype.handleClick = function (event) {
            if (this.shouldLock && this.isLocked) {
                this.unlockFocus(event);
                event.stopPropagation();
            }
        };
        LockFocusDirective.prototype.lockFocus = function () {
            this.addTabindexToChildren(-1);
        };
        LockFocusDirective.prototype.unlockFocus = function (event) {
            var _this = this;
            this.unlock.emit(true);
            this.addTabindexToChildren(0);
            // we focus the host if the event was triggered from a child
            if ((event === null || event === void 0 ? void 0 : event.target) === this.host) {
                // we wait a few milliseconds, mainly because firefox will otherwise apply
                // the mouse event on the new focused child element
                setTimeout(function () {
                    _super.prototype.handleFocus.call(_this, event);
                }, 100);
            }
        };
        LockFocusDirective.prototype.ngOnInit = function () {
            var _a, _b;
            _super.prototype.ngOnInit.call(this);
            this.shouldLock = (_a = this.config) === null || _a === void 0 ? void 0 : _a.lock;
            if (this.shouldLock) {
                this.tabindex = 0;
                // Locked elements will be set to `autofocus` by default if it's not
                // been configured. This will ensure that autofocus kicks in upon unlock.
                if (!this.config.hasOwnProperty('autofocus')) {
                    this.config.autofocus = true;
                }
                // Locked elements will be set to `focusOnEscape` by default if it's not
                // been configured. This will ensure that  the host gets locked again when
                // `escape` is pressed.
                if (!this.config.hasOwnProperty('focusOnEscape')) {
                    this.config.focusOnEscape = !(((_b = this.config) === null || _b === void 0 ? void 0 : _b.focusOnEscape) === false);
                }
            }
        };
        LockFocusDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.shouldLock) {
                /**
                 * If the component hosts a group of focusable children elements,
                 * we persist the group key to the children, so that they can taken this
                 * into account when they persist their focus state.
                 */
                if (!!this.group) {
                    this.service.findFocusable(this.host).forEach(function (el) {
                        // we must do this in after view init as
                        return _this.renderer.setAttribute(el, FOCUS_GROUP_ATTR, _this.group);
                    });
                }
                if (this.shouldAutofocus) {
                    this.handleFocus();
                }
            }
            _super.prototype.ngAfterViewInit.call(this);
        };
        LockFocusDirective.prototype.handleFocus = function (event) {
            var _this = this;
            if (this.shouldLock) {
                if (this.shouldUnlockAfterAutofocus(event)) {
                    // Delay unlocking in case the host is using `ChangeDetectionStrategy.Default`
                    setTimeout(function () { return _this.unlockFocus(event); });
                }
                else {
                    setTimeout(function () { return _this.lockFocus(); });
                    event === null || event === void 0 ? void 0 : event.stopPropagation();
                    return;
                }
            }
            _super.prototype.handleFocus.call(this, event);
        };
        LockFocusDirective.prototype.handleEscape = function (event) {
            if (this.shouldLock) {
                this.service.clear(this.config.group);
            }
            _super.prototype.handleEscape.call(this, event);
        };
        /**
         * When the handleFocus is called without an actual event, it's coming from Autofocus.
         * In this case we unlock the focusable children in case there's a focusable child that
         * was unlocked before.
         *
         * We keep this private to not polute the API.
         */
        LockFocusDirective.prototype.shouldUnlockAfterAutofocus = function (event) {
            return !event && this.service.hasPersistedFocus(this.host, this.config);
        };
        /**
         * Add the tabindex attribute to the focusable children elements
         */
        LockFocusDirective.prototype.addTabindexToChildren = function (i) {
            var _this = this;
            if (i === void 0) { i = 0; }
            if (this.shouldLock) {
                this.isLocked = i === -1;
                if (!(this.hasFocusableChildren && i === 0) || i === 0) {
                    this.focusable.forEach(function (el) { return _this.renderer.setAttribute(el, 'tabindex', i.toString()); });
                }
            }
        };
        Object.defineProperty(LockFocusDirective.prototype, "hasFocusableChildren", {
            /**
             * Utility method, returns all focusable children for the host element.
             *
             * We keep this private to not polute the API.
             */
            get: function () {
                return this.service.hasFocusableChildren(this.host);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LockFocusDirective.prototype, "focusable", {
            /**
             * Returns the focusable children of the host element. If the host element
             * is configured to be locked, the query is restricted to child elements
             * with a tabindex !== `-1`.
             *
             * We keep this private to not polute the API.
             */
            get: function () {
                return this.service.findFocusable(this.host, this.shouldLock, UNLOCK_HIDDEN_ELEMENTS);
            },
            enumerable: false,
            configurable: true
        });
        return LockFocusDirective;
    }(TrapFocusDirective));
    LockFocusDirective.decorators = [
        { type: i0.Directive }
    ];
    LockFocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: LockFocusService },
        { type: i0.Renderer2 }
    ]; };
    LockFocusDirective.propDecorators = {
        shouldLock: [{ type: i0.HostBinding, args: ['class.focus-lock',] }],
        isLocked: [{ type: i0.HostBinding, args: ['class.is-locked',] }],
        unlock: [{ type: i0.Output }],
        handleEnter: [{ type: i0.HostListener, args: ['keydown.enter', ['$event'],] }, { type: i0.HostListener, args: ['keydown.space', ['$event'],] }],
        handleClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
    };

    var KeyboardFocusService = /** @class */ (function (_super) {
        __extends(KeyboardFocusService, _super);
        function KeyboardFocusService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return KeyboardFocusService;
    }(LockFocusService));
    KeyboardFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function KeyboardFocusService_Factory() { return new KeyboardFocusService(i0.ɵɵinject(SelectFocusUtility)); }, token: KeyboardFocusService, providedIn: "root" });
    KeyboardFocusService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var FocusDirective = /** @class */ (function (_super) {
        __extends(FocusDirective, _super);
        function FocusDirective(elementRef, service, renderer) {
            var _this = _super.call(this, elementRef, service, renderer) || this;
            _this.elementRef = elementRef;
            _this.service = service;
            _this.renderer = renderer;
            _this.defaultConfig = {};
            // tslint:disable-next-line: no-input-rename
            _this.config = {};
            return _this;
        }
        return FocusDirective;
    }(LockFocusDirective));
    FocusDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cxFocus]',
                },] }
    ];
    FocusDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: KeyboardFocusService },
        { type: i0.Renderer2 }
    ]; };
    FocusDirective.propDecorators = {
        config: [{ type: i0.Input, args: ['cxFocus',] }]
    };

    var directives = [
        // PersistFocusDirective,
        // VisibleFocusDirective,
        // BlockFocusDirective,
        // AutoFocusDirective,
        // EscapeFocusDirective,
        // LockFocusDirective,
        // TrapFocusDirective,
        // TabFocusDirective,
        FocusDirective,
    ];
    var KeyboardFocusModule = /** @class */ (function () {
        function KeyboardFocusModule() {
        }
        return KeyboardFocusModule;
    }());
    KeyboardFocusModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: __spread(directives),
                    exports: __spread(directives),
                },] }
    ];

    // given that we're likely going to refactor the directives, we're
    // export * from './autofocus/index';
    // export * from './base/index';
    // export * from './block/index';
    // export * from './escape/index';
    // export * from './lock/index';
    // export * from './persist/index';
    // export * from './tab/index';
    // export * from './trap/index';
    // export * from './visible/index';
    // export * from './keyboard-focus.model';

    var AnonymousConsentManagementBannerComponent = /** @class */ (function () {
        function AnonymousConsentManagementBannerComponent(anonymousConsentsService, anonymousConsentLaunchDialogService, vcr) {
            this.anonymousConsentsService = anonymousConsentsService;
            this.anonymousConsentLaunchDialogService = anonymousConsentLaunchDialogService;
            this.vcr = vcr;
            this.subscriptions = new rxjs.Subscription();
            this.bannerVisible$ = this.anonymousConsentsService.isBannerVisible();
        }
        AnonymousConsentManagementBannerComponent.prototype.viewDetails = function () {
            this.hideBanner();
            var dialog = this.anonymousConsentLaunchDialogService.openDialog(null, this.vcr);
            if (dialog) {
                this.subscriptions.add(dialog.subscribe());
            }
        };
        AnonymousConsentManagementBannerComponent.prototype.allowAll = function () {
            var _this = this;
            this.subscriptions.add(this.anonymousConsentsService
                .giveAllConsents()
                .pipe(operators.tap(function () { return _this.hideBanner(); }))
                .subscribe());
        };
        AnonymousConsentManagementBannerComponent.prototype.hideBanner = function () {
            this.anonymousConsentsService.toggleBannerDismissed(true);
        };
        AnonymousConsentManagementBannerComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return AnonymousConsentManagementBannerComponent;
    }());
    AnonymousConsentManagementBannerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-anonymous-consent-management-banner',
                    template: "<ng-container *ngIf=\"bannerVisible$ | async as bannerVisible\">\n  <div\n    [ngClass]=\"{ 'anonymous-consent-banner-hidden': !bannerVisible }\"\n    class=\"anonymous-consent-banner\"\n  >\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-lg-8 col-xs-12\">\n          <div class=\"cx-banner-title\">\n            {{ 'anonymousConsents.banner.title' | cxTranslate }}\n          </div>\n          <div class=\"cx-banner-description\">\n            {{ 'anonymousConsents.banner.description' | cxTranslate }}\n          </div>\n        </div>\n\n        <div class=\"col-lg-4 col-xs-12 cx-banner-buttons\">\n          <button class=\"btn btn-action\" (click)=\"viewDetails()\">\n            {{ 'anonymousConsents.banner.viewDetails' | cxTranslate }}\n          </button>\n          <button class=\"btn btn-primary\" (click)=\"allowAll()\">\n            {{ 'anonymousConsents.banner.allowAll' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n"
                },] }
    ];
    AnonymousConsentManagementBannerComponent.ctorParameters = function () { return [
        { type: i1.AnonymousConsentsService },
        { type: AnonymousConsentLaunchDialogService },
        { type: i0.ViewContainerRef }
    ]; };

    (function (ICON_TYPE) {
        ICON_TYPE["STAR"] = "STAR";
        ICON_TYPE["SEARCH"] = "SEARCH";
        ICON_TYPE["CART"] = "CART";
        ICON_TYPE["INFO"] = "INFO";
        ICON_TYPE["GRID"] = "GRID";
        ICON_TYPE["LIST"] = "LIST";
        ICON_TYPE["CARET_DOWN"] = "CARET_DOWN";
        ICON_TYPE["CARET_LEFT"] = "CARET_LEFT";
        ICON_TYPE["CARET_RIGHT"] = "CARET_RIGHT";
        ICON_TYPE["CLOSE"] = "CLOSE";
        ICON_TYPE["ERROR"] = "ERROR";
        ICON_TYPE["WARNING"] = "WARNING";
        ICON_TYPE["SUCCESS"] = "SUCCESS";
        ICON_TYPE["VISA"] = "VISA";
        ICON_TYPE["MASTER_CARD"] = "MASTER_CARD";
        ICON_TYPE["AMEX"] = "AMEX";
        ICON_TYPE["DINERS_CLUB"] = "DINERS_CLUB";
        ICON_TYPE["CREDIT_CARD"] = "CREDIT_CARD";
        ICON_TYPE["EXPAND"] = "EXPAND";
        ICON_TYPE["COLLAPSE"] = "COLLAPSE";
        ICON_TYPE["RESET"] = "RESET";
        ICON_TYPE["CIRCLE"] = "CIRCLE";
        ICON_TYPE["HEART"] = "HEART";
        ICON_TYPE["EMPTY_HEART"] = "EMPTY_HEART";
        ICON_TYPE["FILTER"] = "FILTER";
        ICON_TYPE["PENCIL"] = "PENCIL";
        ICON_TYPE["CLOCK"] = "CLOCK";
        ICON_TYPE["TRASH"] = "TRASH";
        ICON_TYPE["ACTIVE"] = "ACTIVE";
        ICON_TYPE["SORT_DOWN"] = "SORT_DOWN";
        ICON_TYPE["SORT"] = "SORT";
        ICON_TYPE["ON"] = "ON";
        ICON_TYPE["OFF"] = "OFF";
        ICON_TYPE["LINK_OUT"] = "LINK_OUT";
    })(exports.ICON_TYPE || (exports.ICON_TYPE = {}));
    var IconConfig = /** @class */ (function () {
        function IconConfig() {
        }
        return IconConfig;
    }());
    IconConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function IconConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: IconConfig, providedIn: "root" });
    IconConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];
    (function (IconResourceType) {
        /**
         * An svg based icon requires an SVG resource that must be loaded,
         * this is typically a sprite svg file.
         */
        IconResourceType["SVG"] = "svg";
        /**
         * A font based ICON might require an additional CSS file to be loaded.
         */
        IconResourceType["LINK"] = "link";
        /**
         * Text based icons will simply add the ICON string to the DOM. Text icons do not need an image
         * or CSS pseudo class (i.e. :before), as the text itself is the icon (i.e. +)
         */
        IconResourceType["TEXT"] = "text";
    })(exports.IconResourceType || (exports.IconResourceType = {}));

    var fontawesomeIconConfig = {
        icon: {
            symbols: {
                SEARCH: 'fas fa-search',
                CART: 'fas fa-shopping-cart',
                INFO: 'fas fa-info-circle',
                STAR: 'fas fa-star',
                GRID: 'fas fa-th-large',
                LIST: 'fas fa-bars',
                CARET_DOWN: 'fas fa-angle-down',
                CARET_RIGHT: 'fas fa-angle-right',
                CARET_LEFT: 'fas fa-angle-left',
                ERROR: 'fas fa-exclamation-circle',
                WARNING: 'fas fa-exclamation-triangle',
                SUCCESS: 'fas fa-check-circle',
                CLOSE: 'fas fa-times',
                VISA: 'fab fa-cc-visa',
                MASTER_CARD: 'fab fa-cc-mastercard',
                AMEX: 'fab fa-cc-amex',
                DINERS_CLUB: 'fab fa-cc-diners-club',
                CREDIT_CARD: 'fas fa-credit-card',
                COLLAPSE: 'fas fa-minus',
                EXPAND: 'fas fa-plus',
                RESET: 'fas fa-times-circle',
                CIRCLE: 'fas fa-circle',
                HEART: 'fas fa-heart',
                EMPTY_HEART: 'far fa-heart',
                FILTER: 'fas fa-filter',
                PENCIL: 'fas fa-pencil-alt',
                CLOCK: 'far fa-clock',
                TRASH: 'fas fa-trash',
                ACTIVE: 'fas fa-check',
                ON: 'fas fa-toggle-on',
                OFF: 'fas fa-toggle-off',
                LINK_OUT: 'fas fa-external-link-alt',
                SORT_DOWN: 'fas fa-sort-down',
                SORT: 'fas fa-sort',
            },
            resources: [
                {
                    type: exports.IconResourceType.LINK,
                    url: 'https://use.fontawesome.com/releases/v5.8.1/css/all.css',
                },
            ],
        },
    };

    var IconLoaderService = /** @class */ (function () {
        function IconLoaderService(winRef, iconConfig, sanitizer) {
            this.winRef = winRef;
            this.iconConfig = iconConfig;
            this.sanitizer = sanitizer;
            this.loadedResources = [];
        }
        /**
         * Returns an html fragment which can be added to the DOM in a safe way.
         */
        IconLoaderService.prototype.getHtml = function (type) {
            if (this.isResourceType(type, exports.IconResourceType.SVG)) {
                return this.sanitizer.bypassSecurityTrustHtml("<svg><use xlink:href=\"" + this.getSvgPath(type) + "\"></use></svg>");
            }
            if (this.isResourceType(type, exports.IconResourceType.TEXT)) {
                return this.sanitizer.bypassSecurityTrustHtml(this.getSymbol(type));
            }
        };
        /**
         * Return the direction for which the icon should mirror (ltr vs rtl). The icon direction
         * is configurable, but optional, as only a few icons should be flipped for rtl direction.
         */
        IconLoaderService.prototype.getFlipDirection = function (type) {
            var _a, _b;
            return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.flipDirection) === null || _b === void 0 ? void 0 : _b[type];
        };
        /**
         *
         * Returns the symbol class(es) for the icon type.
         */
        IconLoaderService.prototype.getStyleClasses = function (iconType) {
            return this.getSymbol(iconType) || '';
        };
        /**
         * Indicates whether the given `ICON_TYPE` is configured for
         * the given `IconResourceType`.
         */
        IconLoaderService.prototype.isResourceType = function (iconType, resourceType) {
            return (this.config.resources &&
                !!this.config.resources.find(function (res) { return res.types && res.type === resourceType && res.types.includes(iconType); }));
        };
        /**
         * Returns the path to the svg link. The link supports path names
         * as well, if the config a[[s been setup to support a svg file path.
         * Additionally, the icon prefix will be taken into account to prefix the
         * icon IDs in the SVG.
         */
        IconLoaderService.prototype.getSvgPath = function (iconType) {
            var svgResource = this.config.resources.find(function (res) { return res.type === exports.IconResourceType.SVG &&
                res.types &&
                res.types.includes(iconType); });
            if (svgResource) {
                return svgResource.url
                    ? svgResource.url + "#" + this.getSymbol(iconType)
                    : "#" + this.getSymbol(iconType);
            }
        };
        /**
         * Loads the resource url (if any) for the given icon.
         * The icon will only be loaded once.
         *
         * NOTE: this is not working when the shadow is used as there's
         * no head element available and the link must be loaded for every
         * web component.
         */
        IconLoaderService.prototype.addLinkResource = function (iconType) {
            var resource = this.findResource(iconType, exports.IconResourceType.LINK);
            if (resource &&
                resource.url &&
                !this.loadedResources.includes(resource.url)) {
                this.loadedResources.push(resource.url);
                var head = this.winRef.document.getElementsByTagName('head')[0];
                var link = this.winRef.document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = resource.url;
                head.appendChild(link);
            }
        };
        IconLoaderService.prototype.findResource = function (iconType, resourceType) {
            if (!this.config.resources) {
                return;
            }
            var resource = this.config.resources.find(function (res) { return res.type === resourceType && res.types && res.types.includes(iconType); });
            // no specific resource found, let's try to find a one-size-fits-all resource
            if (!resource) {
                resource = this.config.resources.find(function (res) { return (res.type === resourceType && !res.types) || res.types === []; });
            }
            return resource;
        };
        IconLoaderService.prototype.getSymbol = function (iconType) {
            if (this.config && this.config.symbols && this.config.symbols[iconType]) {
                return this.config.symbols[iconType];
            }
        };
        Object.defineProperty(IconLoaderService.prototype, "config", {
            get: function () {
                return this.iconConfig.icon;
            },
            enumerable: false,
            configurable: true
        });
        return IconLoaderService;
    }());
    IconLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IconLoaderService_Factory() { return new IconLoaderService(i0.ɵɵinject(i1.WindowRef), i0.ɵɵinject(IconConfig), i0.ɵɵinject(i1$2.DomSanitizer)); }, token: IconLoaderService, providedIn: "root" });
    IconLoaderService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    IconLoaderService.ctorParameters = function () { return [
        { type: i1.WindowRef },
        { type: IconConfig },
        { type: i1$2.DomSanitizer }
    ]; };

    /**
     * The ltr and rtl directions can be used to configure the storefront for a certain direction, both statically
     * or dynamically.
     *
     * The HTML5 "auto" value is not supported in Spartacus, as it's considered to be too fragile for the global
     * direction.
     */
    (function (DirectionMode) {
        /**
         * Indicates Left to Right direction.
         */
        DirectionMode["LTR"] = "ltr";
        /**
         * Indicates Right to Left direction.
         */
        DirectionMode["RTL"] = "rtl";
    })(exports.DirectionMode || (exports.DirectionMode = {}));

    /**
     *
     * The icon component can be added in different ways:
     *
     * With the component selector:
     * `<cx-icon type="SEARCH"></cx-icon>`
     *
     * With the attribute selector:
     * `<span cxIcon="STAR"></span>`
     *
     * Additionally, content can be projected to the icon:
     *
     * `<button cxIcon="HAPPY">happy label</button>`
     *
     * The above button would become (based on a TEXT resource type):
     * `<button>😊happy label</button>`
     *
     * While the content is projected, the icon itself doesn't require an
     * additional DOM node which is an advantage over the component selector.
     */
    var IconComponent = /** @class */ (function () {
        function IconComponent(iconLoader, elementRef, renderer) {
            this.iconLoader = iconLoader;
            this.elementRef = elementRef;
            this.renderer = renderer;
        }
        Object.defineProperty(IconComponent.prototype, "cxIcon", {
            /**
             * The cxIcon directive is bound to the icon type. You can feed the `ICON_TYPE` to
             * accomplish a configurable button in the UI.
             */
            set: function (type) {
                this.setIcon(type);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(IconComponent.prototype, "type", {
            /**
             * The type input parameter is bound to the icon type. You can feed the `ICON_TYPE` to
             * accomplish a configurable button in the UI.
             */
            set: function (type) {
                this.setIcon(type);
            },
            enumerable: false,
            configurable: true
        });
        IconComponent.prototype.setIcon = function (type) {
            if (!type || type === '') {
                return;
            }
            this.icon = this.iconLoader.getHtml(type);
            this.addStyleClasses(type);
            this.iconLoader.addLinkResource(type);
            this.flipIcon(type);
        };
        /**
         * The icons supports flipping for some icons to support rtl and ltr directions.
         */
        IconComponent.prototype.flipIcon = function (type) {
            // TODO: this can be dropped with the next major release.
            if (!this.iconLoader.getFlipDirection) {
                return;
            }
            var iconDirection = this.iconLoader.getFlipDirection(type);
            this.flipAtLtr = iconDirection === exports.DirectionMode.LTR;
            this.flipAtRtl = iconDirection === exports.DirectionMode.RTL;
        };
        /**
         * Adds the style classes and the link resource (if available).
         */
        IconComponent.prototype.addStyleClasses = function (type) {
            var _this = this;
            var _a, _b, _c;
            this.renderer.addClass(this.host, 'cx-icon');
            (_a = this.styleClasses) === null || _a === void 0 ? void 0 : _a.forEach(function (cls) { return _this.renderer.removeClass(_this.host, cls); });
            this.styleClasses = (_b = this.iconLoader.getStyleClasses(type)) === null || _b === void 0 ? void 0 : _b.split(' ');
            (_c = this.styleClasses) === null || _c === void 0 ? void 0 : _c.forEach(function (cls) {
                if (cls !== '') {
                    _this.renderer.addClass(_this.host, cls);
                }
            });
        };
        Object.defineProperty(IconComponent.prototype, "host", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        return IconComponent;
    }());
    IconComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-icon,[cxIcon]',
                    template: "<i [outerHTML]=\"icon\"></i><ng-content></ng-content>\n"
                },] }
    ];
    IconComponent.ctorParameters = function () { return [
        { type: IconLoaderService },
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    IconComponent.propDecorators = {
        cxIcon: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        flipAtRtl: [{ type: i0.HostBinding, args: ['class.flip-at-rtl',] }],
        flipAtLtr: [{ type: i0.HostBinding, args: ['class.flip-at-ltr',] }]
    };

    var defaultIconConfig = {
        icon: {
            flipDirection: {
                CARET_RIGHT: exports.DirectionMode.RTL,
                CARET_LEFT: exports.DirectionMode.RTL,
            },
        },
    };

    var IconModule = /** @class */ (function () {
        function IconModule() {
        }
        return IconModule;
    }());
    IconModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [IconComponent],
                    imports: [i1$1.CommonModule],
                    providers: [
                        i1.provideDefaultConfig(defaultIconConfig),
                        // TODO: move the opinionated fontawesome config to a recipe
                        i1.provideDefaultConfig(fontawesomeIconConfig),
                    ],
                    exports: [IconComponent],
                },] }
    ];

    var AnonymousConsentDialogComponent = /** @class */ (function () {
        function AnonymousConsentDialogComponent(config, anonymousConsentsService, el, launchDialogService) {
            this.config = config;
            this.anonymousConsentsService = anonymousConsentsService;
            this.el = el;
            this.launchDialogService = launchDialogService;
            this.role = 'dialog';
            this.modal = true;
            this.subscriptions = new rxjs.Subscription();
            this.showLegalDescription = true;
            this.iconTypes = exports.ICON_TYPE;
            this.requiredConsents = [];
            this.focusConfig = {
                trap: true,
                block: true,
                autofocus: 'input[type="checkbox"]',
                focusOnEscape: true,
            };
            if (Boolean(this.config.anonymousConsents)) {
                this.showLegalDescription = this.config.anonymousConsents.showLegalDescriptionInDialog;
                if (Boolean(this.config.anonymousConsents.requiredConsents)) {
                    this.requiredConsents = this.config.anonymousConsents.requiredConsents;
                }
            }
        }
        AnonymousConsentDialogComponent.prototype.handleClick = function (event) {
            // Close on click outside the dialog window
            if (event.target.tagName === this.el.nativeElement.tagName) {
                this.close('Cross click');
            }
        };
        AnonymousConsentDialogComponent.prototype.ngOnInit = function () {
            this.templates$ = this.anonymousConsentsService.getTemplates();
            this.consents$ = this.anonymousConsentsService.getConsents();
            this.loading$ = this.anonymousConsentsService.getLoadTemplatesLoading();
        };
        AnonymousConsentDialogComponent.prototype.close = function (reason) {
            this.launchDialogService.closeDialog(reason);
        };
        AnonymousConsentDialogComponent.prototype.rejectAll = function () {
            var _this = this;
            this.subscriptions.add(rxjs.combineLatest([this.templates$, this.consents$])
                .pipe(operators.take(1), operators.distinctUntilChanged(), operators.tap(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], consents = _b[1];
                return templates.forEach(function (template) {
                    var consent = _this.getCorrespondingConsent(template, consents);
                    if (_this.anonymousConsentsService.isConsentGiven(consent)) {
                        if (_this.isRequiredConsent(template)) {
                            return;
                        }
                        _this.anonymousConsentsService.withdrawConsent(template.id);
                    }
                });
            }))
                .subscribe());
            this.close('rejectAll');
        };
        AnonymousConsentDialogComponent.prototype.allowAll = function () {
            var _this = this;
            this.subscriptions.add(rxjs.combineLatest([this.templates$, this.consents$])
                .pipe(operators.take(1), operators.distinctUntilChanged(), operators.tap(function (_a) {
                var _b = __read(_a, 2), templates = _b[0], consents = _b[1];
                return templates.forEach(function (template) {
                    var consent = _this.getCorrespondingConsent(template, consents);
                    if ((consent && consent.consentState == null) ||
                        _this.anonymousConsentsService.isConsentWithdrawn(consent)) {
                        if (_this.isRequiredConsent(template)) {
                            return;
                        }
                        _this.anonymousConsentsService.giveConsent(template.id);
                    }
                });
            }))
                .subscribe());
            this.close('allowAll');
        };
        AnonymousConsentDialogComponent.prototype.isRequiredConsent = function (template) {
            return (Boolean(this.config.anonymousConsents) &&
                Boolean(this.config.anonymousConsents.requiredConsents) &&
                this.config.anonymousConsents.requiredConsents.includes(template.id));
        };
        AnonymousConsentDialogComponent.prototype.onConsentChange = function (_a) {
            var given = _a.given, template = _a.template;
            if (given) {
                this.anonymousConsentsService.giveConsent(template.id);
            }
            else {
                this.anonymousConsentsService.withdrawConsent(template.id);
            }
        };
        AnonymousConsentDialogComponent.prototype.getCorrespondingConsent = function (template, consents) {
            var e_1, _a;
            if (consents === void 0) { consents = []; }
            try {
                for (var consents_1 = __values(consents), consents_1_1 = consents_1.next(); !consents_1_1.done; consents_1_1 = consents_1.next()) {
                    var consent = consents_1_1.value;
                    if (template.id === consent.templateCode) {
                        return consent;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (consents_1_1 && !consents_1_1.done && (_a = consents_1.return)) _a.call(consents_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        };
        AnonymousConsentDialogComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return AnonymousConsentDialogComponent;
    }());
    AnonymousConsentDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-anonymous-consent-dialog',
                    template: "<div\n  class=\"cx-anonymous-consent-dialog\"\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n>\n  <div class=\"cx-dialog-content\">\n    <div *ngIf=\"loading$ | async; else dialogBody\">\n      <cx-spinner></cx-spinner>\n    </div>\n    <ng-template #dialogBody>\n      <div class=\"cx-dialog-header\">\n        <h3>\n          {{ 'anonymousConsents.dialog.title' | cxTranslate }}\n        </h3>\n        <button\n          type=\"button\"\n          class=\"close\"\n          aria-label=\"Close\"\n          (click)=\"close('Cross click')\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n      <!-- Separator -->\n      <div class=\"cx-dialog-description\" *ngIf=\"showLegalDescription\">\n        {{ 'anonymousConsents.dialog.legalDescription' | cxTranslate }}\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n      </div>\n      <!-- Actions -->\n      <div class=\"cx-dialog-buttons\">\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"rejectAll()\">{{\n          'anonymousConsents.dialog.clearAll' | cxTranslate\n        }}</a>\n        <a tabindex=\"0\" class=\"btn-link cx-action-link\" (click)=\"allowAll()\">{{\n          'anonymousConsents.dialog.selectAll' | cxTranslate\n        }}</a>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"cx-dialog-body\" *ngIf=\"templates$ | async as templates\">\n        <ng-container *ngIf=\"consents$ | async as consents\">\n          <div\n            class=\"cx-dialog-row col-sm-12 col-md-6\"\n            *ngFor=\"let template of templates\"\n          >\n            <cx-consent-management-form\n              [consentTemplate]=\"template\"\n              [requiredConsents]=\"requiredConsents\"\n              [consent]=\"getCorrespondingConsent(template, consents)\"\n              (consentChanged)=\"onConsentChange($event)\"\n            ></cx-consent-management-form>\n          </div>\n        </ng-container>\n      </div>\n    </ng-template>\n  </div>\n</div>\n"
                },] }
    ];
    AnonymousConsentDialogComponent.ctorParameters = function () { return [
        { type: i1.AnonymousConsentsConfig },
        { type: i1.AnonymousConsentsService },
        { type: i0.ElementRef },
        { type: LaunchDialogService }
    ]; };
    AnonymousConsentDialogComponent.propDecorators = {
        role: [{ type: i0.HostBinding, args: ['attr.role',] }],
        modal: [{ type: i0.HostBinding, args: ['attr.aria-modal',] }],
        handleClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
    };

    var defaultAnonymousConsentLayoutConfig = {
        launch: {
            ANONYMOUS_CONSENT: {
                inline: true,
                component: AnonymousConsentDialogComponent,
                dialogType: exports.DIALOG_TYPE.DIALOG,
            },
        },
    };

    var AnonymousConsentOpenDialogComponent = /** @class */ (function () {
        function AnonymousConsentOpenDialogComponent(vcr, anonymousConsentLaunchDialogService) {
            this.vcr = vcr;
            this.anonymousConsentLaunchDialogService = anonymousConsentLaunchDialogService;
        }
        AnonymousConsentOpenDialogComponent.prototype.openDialog = function () {
            var dialog = this.anonymousConsentLaunchDialogService.openDialog(this.openElement, this.vcr);
            if (dialog) {
                dialog.pipe(operators.take(1)).subscribe();
            }
        };
        return AnonymousConsentOpenDialogComponent;
    }());
    AnonymousConsentOpenDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-anonymous-consent-open-dialog',
                    template: "<button #open class=\"btn btn-link\" (click)=\"openDialog()\">\n  {{ 'anonymousConsents.preferences' | cxTranslate }}\n</button>\n"
                },] }
    ];
    AnonymousConsentOpenDialogComponent.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: AnonymousConsentLaunchDialogService }
    ]; };
    AnonymousConsentOpenDialogComponent.propDecorators = {
        openElement: [{ type: i0.ViewChild, args: ['open',] }]
    };

    var AnonymousConsentManagementBannerModule = /** @class */ (function () {
        function AnonymousConsentManagementBannerModule() {
        }
        return AnonymousConsentManagementBannerModule;
    }());
    AnonymousConsentManagementBannerModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        i1.FeaturesConfigModule,
                        KeyboardFocusModule,
                    ],
                    providers: [
                        i1.provideConfig(defaultAnonymousConsentLayoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                AnonymousConsentManagementBannerComponent: {
                                    component: AnonymousConsentManagementBannerComponent,
                                    deferLoading: i1.DeferLoadingStrategy.INSTANT,
                                },
                                AnonymousConsentOpenDialogComponent: {
                                    component: AnonymousConsentOpenDialogComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [
                        AnonymousConsentManagementBannerComponent,
                        AnonymousConsentOpenDialogComponent,
                    ],
                    exports: [
                        AnonymousConsentManagementBannerComponent,
                        AnonymousConsentOpenDialogComponent,
                    ],
                    entryComponents: [
                        AnonymousConsentManagementBannerComponent,
                        AnonymousConsentOpenDialogComponent,
                    ],
                },] }
    ];

    // TODO: Improve a11y with better text appropriate to usage (example: loading cart spinner)
    var SpinnerComponent = /** @class */ (function () {
        function SpinnerComponent() {
        }
        return SpinnerComponent;
    }());
    SpinnerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-spinner',
                    template: "<div class=\"loader-container\">\n  <div class=\"loader\">{{ 'spinner.loading' | cxTranslate }}</div>\n</div>\n"
                },] }
    ];
    SpinnerComponent.ctorParameters = function () { return []; };

    var SpinnerModule = /** @class */ (function () {
        function SpinnerModule() {
        }
        return SpinnerModule;
    }());
    SpinnerModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule],
                    declarations: [SpinnerComponent],
                    exports: [SpinnerComponent],
                },] }
    ];

    var ConsentManagementFormComponent = /** @class */ (function () {
        function ConsentManagementFormComponent() {
            this.consentGiven = false;
            this.requiredConsents = [];
            this.consentChanged = new i0.EventEmitter();
        }
        ConsentManagementFormComponent.prototype.ngOnInit = function () {
            if (this.consent) {
                this.consentGiven = Boolean(this.consent.consentState === i1.ANONYMOUS_CONSENT_STATUS.GIVEN);
            }
            else {
                if (this.consentTemplate && this.consentTemplate.currentConsent) {
                    if (this.consentTemplate.currentConsent.consentWithdrawnDate) {
                        this.consentGiven = false;
                    }
                    else if (this.consentTemplate.currentConsent.consentGivenDate) {
                        this.consentGiven = true;
                    }
                }
            }
        };
        ConsentManagementFormComponent.prototype.onConsentChange = function () {
            this.consentGiven = !this.consentGiven;
            this.consentChanged.emit({
                given: this.consentGiven,
                template: this.consentTemplate,
            });
        };
        ConsentManagementFormComponent.prototype.isRequired = function (templateId) {
            return this.requiredConsents.includes(templateId);
        };
        return ConsentManagementFormComponent;
    }());
    ConsentManagementFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-consent-management-form',
                    template: "<div class=\"form-check\">\n  <label>\n    <input\n      type=\"checkbox\"\n      class=\"form-check-input\"\n      (change)=\"onConsentChange()\"\n      [checked]=\"consentGiven\"\n      [disabled]=\"isRequired(consentTemplate?.id)\"\n    />\n    <span class=\"form-check-label cx-be-bold\">\n      {{ consentTemplate?.name }}\n    </span>\n    <br />\n    <span class=\"form-check-label\">\n      {{ consentTemplate?.description }}\n    </span>\n  </label>\n</div>\n"
                },] }
    ];
    ConsentManagementFormComponent.ctorParameters = function () { return []; };
    ConsentManagementFormComponent.propDecorators = {
        consentTemplate: [{ type: i0.Input }],
        requiredConsents: [{ type: i0.Input }],
        consent: [{ type: i0.Input }],
        consentChanged: [{ type: i0.Output }]
    };

    var ConsentManagementComponent = /** @class */ (function () {
        function ConsentManagementComponent(userConsentService, globalMessageService, anonymousConsentsConfig, anonymousConsentsService, authService) {
            this.userConsentService = userConsentService;
            this.globalMessageService = globalMessageService;
            this.anonymousConsentsConfig = anonymousConsentsConfig;
            this.anonymousConsentsService = anonymousConsentsService;
            this.authService = authService;
            this.subscriptions = new rxjs.Subscription();
            this.allConsentsLoading = new rxjs.BehaviorSubject(false);
            this.requiredConsents = [];
        }
        ConsentManagementComponent.prototype.ngOnInit = function () {
            this.loading$ = rxjs.combineLatest([
                this.userConsentService.getConsentsResultLoading(),
                this.userConsentService.getGiveConsentResultLoading(),
                this.userConsentService.getWithdrawConsentResultLoading(),
                this.authService.isUserLoggedIn(),
                this.allConsentsLoading,
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 5), consentLoading = _b[0], giveConsentLoading = _b[1], withdrawConsentLoading = _b[2], isUserLoggedIn = _b[3], allConsentsLoading = _b[4];
                return consentLoading ||
                    giveConsentLoading ||
                    withdrawConsentLoading ||
                    !isUserLoggedIn ||
                    allConsentsLoading;
            }));
            this.consentListInit();
            this.giveConsentInit();
            this.withdrawConsentInit();
        };
        ConsentManagementComponent.prototype.consentListInit = function () {
            var _this = this;
            this.templateList$ = this.userConsentService.getConsents().pipe(operators.withLatestFrom(this.anonymousConsentsService.getTemplates(), this.authService.isUserLoggedIn()), operators.filter(function (_a) {
                var _b = __read(_a, 3), _templateList = _b[0], _anonymousTemplates = _b[1], isUserLoggedIn = _b[2];
                return isUserLoggedIn;
            }), operators.tap(function (_a) {
                var _b = __read(_a, 2), templateList = _b[0], _anonymousTemplates = _b[1];
                if (!_this.consentsExists(templateList)) {
                    _this.userConsentService.loadConsents();
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), templateList = _b[0], anonymousTemplates = _b[1];
                if (Boolean(_this.anonymousConsentsConfig.anonymousConsents)) {
                    if (Boolean(_this.anonymousConsentsConfig.anonymousConsents.requiredConsents)) {
                        _this.requiredConsents = _this.anonymousConsentsConfig.anonymousConsents.requiredConsents;
                    }
                    if (Boolean(_this.anonymousConsentsConfig.anonymousConsents
                        .consentManagementPage)) {
                        return _this.hideAnonymousConsents(templateList, anonymousTemplates);
                    }
                }
                return templateList;
            }));
        };
        ConsentManagementComponent.prototype.hideAnonymousConsents = function (templateList, anonymousTemplates) {
            if (anonymousTemplates === void 0) { anonymousTemplates = []; }
            var hideTemplateIds = [];
            if (!this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                .showAnonymousConsents) {
                hideTemplateIds = anonymousTemplates.map(function (template) { return template.id; });
                return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
            }
            if (Boolean(this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                .hideConsents) &&
                this.anonymousConsentsConfig.anonymousConsents.consentManagementPage
                    .hideConsents.length > 0) {
                hideTemplateIds = this.anonymousConsentsConfig.anonymousConsents
                    .consentManagementPage.hideConsents;
            }
            return this.userConsentService.filterConsentTemplates(templateList, hideTemplateIds);
        };
        ConsentManagementComponent.prototype.giveConsentInit = function () {
            var _this = this;
            this.userConsentService.resetGiveConsentProcessState();
            this.subscriptions.add(this.userConsentService
                .getGiveConsentResultSuccess()
                .subscribe(function (success) { return _this.onConsentGivenSuccess(success); }));
        };
        ConsentManagementComponent.prototype.withdrawConsentInit = function () {
            var _this = this;
            this.userConsentService.resetWithdrawConsentProcessState();
            this.subscriptions.add(this.userConsentService
                .getWithdrawConsentResultLoading()
                .pipe(operators.skipWhile(Boolean), operators.withLatestFrom(this.userConsentService.getWithdrawConsentResultSuccess()), operators.map(function (_a) {
                var _b = __read(_a, 2), withdrawalSuccess = _b[1];
                return withdrawalSuccess;
            }), operators.tap(function (withdrawalSuccess) {
                if (withdrawalSuccess) {
                    _this.userConsentService.loadConsents();
                }
            }))
                .subscribe(function (withdrawalSuccess) { return _this.onConsentWithdrawnSuccess(withdrawalSuccess); }));
        };
        ConsentManagementComponent.prototype.consentsExists = function (templateList) {
            return Boolean(templateList) && templateList.length > 0;
        };
        ConsentManagementComponent.prototype.onConsentChange = function (_a) {
            var given = _a.given, template = _a.template;
            if (given) {
                this.userConsentService.giveConsent(template.id, template.version);
            }
            else {
                this.userConsentService.withdrawConsent(template.currentConsent.code);
            }
        };
        ConsentManagementComponent.prototype.onConsentGivenSuccess = function (success) {
            if (success) {
                this.userConsentService.resetGiveConsentProcessState();
                this.globalMessageService.add({ key: 'consentManagementForm.message.success.given' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
        };
        ConsentManagementComponent.prototype.onConsentWithdrawnSuccess = function (success) {
            if (success) {
                this.userConsentService.resetWithdrawConsentProcessState();
                this.globalMessageService.add({ key: 'consentManagementForm.message.success.withdrawn' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
        };
        ConsentManagementComponent.prototype.rejectAll = function (templates) {
            var _this = this;
            if (templates === void 0) { templates = []; }
            var consentsToWithdraw = [];
            templates.forEach(function (template) {
                if (_this.userConsentService.isConsentGiven(template.currentConsent)) {
                    if (_this.isRequiredConsent(template)) {
                        return;
                    }
                    consentsToWithdraw.push(template);
                }
            });
            this.allConsentsLoading.next(true);
            this.subscriptions.add(this.setupWithdrawalStream(consentsToWithdraw)
                .pipe(operators.tap(function (_timesLoaded) { return _this.allConsentsLoading.next(false); }))
                .subscribe());
        };
        ConsentManagementComponent.prototype.setupWithdrawalStream = function (consentsToWithdraw) {
            var _this = this;
            if (consentsToWithdraw === void 0) { consentsToWithdraw = []; }
            var loading$ = rxjs.concat(this.userConsentService.getWithdrawConsentResultLoading()).pipe(operators.distinctUntilChanged(), operators.filter(function (loading) { return !loading; }));
            var count$ = loading$.pipe(operators.scan(function (acc, _value) { return acc + 1; }, -1));
            var withdraw$ = count$.pipe(operators.tap(function (i) {
                if (i < consentsToWithdraw.length) {
                    _this.userConsentService.withdrawConsent(consentsToWithdraw[i].currentConsent.code);
                }
            }));
            var checkTimesLoaded$ = withdraw$.pipe(operators.filter(function (timesLoaded) { return timesLoaded === consentsToWithdraw.length; }));
            return checkTimesLoaded$;
        };
        ConsentManagementComponent.prototype.allowAll = function (templates) {
            var _this = this;
            if (templates === void 0) { templates = []; }
            var consentsToGive = [];
            templates.forEach(function (template) {
                if (_this.userConsentService.isConsentWithdrawn(template.currentConsent)) {
                    if (_this.isRequiredConsent(template)) {
                        return;
                    }
                    consentsToGive.push(template);
                }
            });
            this.allConsentsLoading.next(true);
            this.subscriptions.add(this.setupGiveStream(consentsToGive)
                .pipe(operators.tap(function (_timesLoaded) { return _this.allConsentsLoading.next(false); }))
                .subscribe());
        };
        ConsentManagementComponent.prototype.setupGiveStream = function (consentsToGive) {
            var _this = this;
            if (consentsToGive === void 0) { consentsToGive = []; }
            var loading$ = rxjs.concat(this.userConsentService.getGiveConsentResultLoading()).pipe(operators.distinctUntilChanged(), operators.filter(function (loading) { return !loading; }));
            var count$ = loading$.pipe(operators.scan(function (acc, _value) { return acc + 1; }, -1));
            var giveConsent$ = count$.pipe(operators.tap(function (i) {
                if (i < consentsToGive.length) {
                    _this.userConsentService.giveConsent(consentsToGive[i].id, consentsToGive[i].version);
                }
            }));
            var checkTimesLoaded$ = giveConsent$.pipe(operators.filter(function (timesLoaded) { return timesLoaded === consentsToGive.length; }));
            return checkTimesLoaded$;
        };
        ConsentManagementComponent.prototype.isRequiredConsent = function (template) {
            return (Boolean(this.anonymousConsentsConfig.anonymousConsents) &&
                Boolean(this.anonymousConsentsConfig.anonymousConsents.requiredConsents) &&
                this.anonymousConsentsConfig.anonymousConsents.requiredConsents.includes(template.id));
        };
        ConsentManagementComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
            this.allConsentsLoading.unsubscribe();
            this.userConsentService.resetGiveConsentProcessState();
            this.userConsentService.resetWithdrawConsentProcessState();
        };
        return ConsentManagementComponent;
    }());
    ConsentManagementComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-consent-management',
                    template: "<div *ngIf=\"loading$ | async; else consentManagementForm\">\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</div>\n\n<ng-template #consentManagementForm>\n  <ng-container *ngIf=\"templateList$ | async as templateList\">\n    <div class=\"cx-consent-action-links\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"rejectAll(templateList)\"\n        >\n          {{ 'consentManagementForm.clearAll' | cxTranslate }}\n        </button>\n        <button\n          tabindex=\"0\"\n          class=\"btn btn-link cx-action-link\"\n          (click)=\"allowAll(templateList)\"\n        >\n          {{ 'consentManagementForm.selectAll' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div class=\"cx-consent-toggles\">\n      <div class=\"col-sm-12 col-md-8 col-lg-6\">\n        <cx-consent-management-form\n          *ngFor=\"let consentTemplate of templateList\"\n          [consentTemplate]=\"consentTemplate\"\n          [requiredConsents]=\"requiredConsents\"\n          (consentChanged)=\"onConsentChange($event)\"\n        ></cx-consent-management-form>\n      </div>\n    </div>\n  </ng-container>\n</ng-template>\n"
                },] }
    ];
    ConsentManagementComponent.ctorParameters = function () { return [
        { type: i1.UserConsentService },
        { type: i1.GlobalMessageService },
        { type: i1.AnonymousConsentsConfig },
        { type: i1.AnonymousConsentsService },
        { type: i1.AuthService }
    ]; };

    var ConsentManagementModule = /** @class */ (function () {
        function ConsentManagementModule() {
        }
        return ConsentManagementModule;
    }());
    ConsentManagementModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        SpinnerModule,
                        i1.I18nModule,
                        IconModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ConsentManagementComponent: {
                                    component: ConsentManagementComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ConsentManagementComponent, ConsentManagementFormComponent],
                    exports: [ConsentManagementComponent, ConsentManagementFormComponent],
                    entryComponents: [ConsentManagementComponent],
                },] }
    ];

    var AnonymousConsentsDialogModule = /** @class */ (function () {
        function AnonymousConsentsDialogModule() {
        }
        return AnonymousConsentsDialogModule;
    }());
    AnonymousConsentsDialogModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        IconModule,
                        SpinnerModule,
                        ConsentManagementModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [AnonymousConsentDialogComponent],
                    entryComponents: [AnonymousConsentDialogComponent],
                    exports: [AnonymousConsentDialogComponent],
                },] }
    ];

    var CardComponent = /** @class */ (function () {
        function CardComponent() {
            this.iconTypes = exports.ICON_TYPE;
            this.deleteCard = new i0.EventEmitter();
            this.setDefaultCard = new i0.EventEmitter();
            this.sendCard = new i0.EventEmitter();
            this.editCard = new i0.EventEmitter();
            this.cancelCard = new i0.EventEmitter();
            this.border = false;
            this.editMode = false;
            this.isDefault = false;
            this.fitToContainer = false;
        }
        // ACTIONS
        CardComponent.prototype.setEditMode = function () {
            this.editMode = true;
        };
        CardComponent.prototype.cancelEdit = function () {
            this.editMode = false;
            this.cancelCard.emit(5);
        };
        CardComponent.prototype.delete = function () {
            this.deleteCard.emit(1);
        };
        CardComponent.prototype.setDefault = function () {
            this.isDefault = true;
            this.setDefaultCard.emit(2);
        };
        CardComponent.prototype.send = function () {
            this.sendCard.emit(3);
        };
        CardComponent.prototype.edit = function () {
            this.editCard.emit(4);
        };
        CardComponent.prototype.ngOnInit = function () { };
        return CardComponent;
    }());
    CardComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-card',
                    template: "<div\n  *ngIf=\"content\"\n  class=\"cx-card\"\n  [class.cx-card-border]=\"border\"\n  [class.cx-card-fit-to-container]=\"fitToContainer\"\n>\n  <!-- Card Header -->\n  <div *ngIf=\"content.header && !editMode\" class=\"card-header\">\n    {{ content.header }}\n  </div>\n  <!-- Card Body -->\n  <div class=\"card-body cx-card-body\" [class.cx-card-delete]=\"editMode\">\n    <!-- Edit message -->\n    <div *ngIf=\"editMode\" class=\"cx-card-delete-msg\">\n      {{ content.deleteMsg }}\n    </div>\n    <!-- Card title -->\n    <h4 *ngIf=\"content.title\" class=\"cx-card-title\">\n      {{ content.title }}\n    </h4>\n    <!-- Card Content -->\n    <div class=\"cx-card-container\">\n      <!-- Card Label -->\n      <div class=\"cx-card-label-container\">\n        <div *ngIf=\"content.textBold\" class=\"cx-card-label-bold\">\n          {{ content.textBold }}\n        </div>\n        <div *ngFor=\"let line of content.text\">\n          <div class=\"cx-card-label\">{{ line }}</div>\n        </div>\n        <div class=\"cx-card-paragraph\" *ngFor=\"let item of content.paragraphs\">\n          <div class=\"cx-card-paragraph-title\">{{ item.title }}</div>\n          <div *ngFor=\"let text of item.text\">\n            <div class=\"cx-card-paragraph-text\">{{ text }}</div>\n          </div>\n        </div>\n      </div>\n      <!-- Image -->\n      <div *ngIf=\"content.img\" class=\"cx-card-img-container\">\n        <cx-icon [type]=\"content.img\"></cx-icon>\n      </div>\n    </div>\n    <!-- Edit Mode Actions -->\n    <div *ngIf=\"editMode\" class=\"row cx-card-body-delete\">\n      <div class=\"col-md-6\">\n        <button class=\"btn btn-block btn-secondary\" (click)=\"cancelEdit()\">\n          {{ 'common.cancel' | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-6\">\n        <button class=\"btn btn-block btn-primary\" (click)=\"delete()\">\n          {{ 'common.delete' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n    <!-- Actions -->\n    <div *ngIf=\"content.actions && !editMode\" class=\"cx-card-actions\">\n      <div *ngFor=\"let action of content.actions\">\n        <div [ngSwitch]=\"action.event\">\n          <a\n            *ngSwitchCase=\"'delete'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"delete()\"\n            (keydown.enter)=\"delete()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'default'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"setDefault()\"\n            (keydown.enter)=\"setDefault()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'send'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"send()\"\n            (keydown.enter)=\"send()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchCase=\"'edit'\"\n            class=\"cx-card-link card-link btn-link cx-action-link\"\n            (click)=\"edit()\"\n            (keydown.enter)=\"edit()\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n          <a\n            *ngSwitchDefault\n            href=\"{{ action.link }}\"\n            class=\"card-link btn-link cx-action-link\"\n            tabindex=\"0\"\n            >{{ action.name }}</a\n          >\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    CardComponent.ctorParameters = function () { return []; };
    CardComponent.propDecorators = {
        deleteCard: [{ type: i0.Output }],
        setDefaultCard: [{ type: i0.Output }],
        sendCard: [{ type: i0.Output }],
        editCard: [{ type: i0.Output }],
        cancelCard: [{ type: i0.Output }],
        border: [{ type: i0.Input }],
        editMode: [{ type: i0.Input }],
        isDefault: [{ type: i0.Input }],
        content: [{ type: i0.Input }],
        fitToContainer: [{ type: i0.Input }]
    };

    var CardModule = /** @class */ (function () {
        function CardModule() {
        }
        return CardModule;
    }());
    CardModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule, IconModule],
                    declarations: [CardComponent],
                    exports: [CardComponent],
                },] }
    ];

    var CarouselService = /** @class */ (function () {
        function CarouselService(winRef) {
            this.winRef = winRef;
        }
        /**
         * The number of items per slide is calculated by the help of
         * the item width and the available width of the host element.
         * This appoach makes it possible to place the carousel in different
         * layouts. Instead of using the page breakpoints, the host size is
         * taken into account.
         *
         * Since there's no element resize API available, we use the
         * window `resize` event, so that we can adjust the number of items
         * whenever the window got resized.
         */
        CarouselService.prototype.getItemsPerSlide = function (nativeElement, itemWidth) {
            var _this = this;
            return this.winRef.resize$.pipe(operators.map(function () { return nativeElement.clientWidth; }), operators.map(function (totalWidth) { return _this.calculateItems(totalWidth, itemWidth); }));
        };
        /**
         * Calculates the number of items per given hostSize.  calculated based on the given
         * intended size in pixels or percentages. The
         *
         * @param availableWidth The available width in pixels for the carousel items.
         * @param itemWidth The width per carousel item, in px or percentage.
         */
        CarouselService.prototype.calculateItems = function (availableWidth, itemWidth) {
            var calculatedItems = 0;
            if (itemWidth.endsWith('px')) {
                var num = itemWidth.substring(0, itemWidth.length - 2);
                calculatedItems = availableWidth / num;
            }
            if (itemWidth.endsWith('%')) {
                var perc = itemWidth.substring(0, itemWidth.length - 1);
                calculatedItems =
                    availableWidth / (availableWidth * (perc / 100));
            }
            return Math.floor(calculatedItems) || 1;
        };
        return CarouselService;
    }());
    CarouselService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CarouselService_Factory() { return new CarouselService(i0.ɵɵinject(i1.WindowRef)); }, token: CarouselService, providedIn: "root" });
    CarouselService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CarouselService.ctorParameters = function () { return [
        { type: i1.WindowRef }
    ]; };

    /**
     * Generic carousel component that can be used to render any carousel items,
     * such as products, images, banners, or any component. Carousel items are
     * rendered in so-called carousel slides, and the previous/next buttons as well as
     * the indicator-buttons can used to navigate the slides.
     *
     * The component uses an array of Observables (`items$`) as an input, to allow
     * for lazy loading of items.
     *
     * The number of items per slide is calculated with the `itemWidth`, which can given
     * in pixels or percentage.
     *
     * To allow for flexible rendering of items, the rendering is delegated to the
     * given `template`. This allows for maximum flexibility.
     */
    var CarouselComponent = /** @class */ (function () {
        function CarouselComponent(el, service) {
            this.el = el;
            this.service = service;
            /**
             * Specifies the minimum size of the carousel item, either in px or %.
             * This value is used for the calculation of numbers per carousel, so that
             * the number of carousel items is dynamic. The calculation uses the `itemWidth`
             * and the host element `clientWidth`, so that the carousel is reusable in
             * different layouts (for example in a 50% grid).
             */
            this.itemWidth = '300px';
            /**
             * Indicates whether the visual indicators are used.
             */
            this.hideIndicators = false;
            this.indicatorIcon = exports.ICON_TYPE.CIRCLE;
            this.previousIcon = exports.ICON_TYPE.CARET_LEFT;
            this.nextIcon = exports.ICON_TYPE.CARET_RIGHT;
        }
        Object.defineProperty(CarouselComponent.prototype, "setItems", {
            set: function (inputItems) {
                this.items = inputItems;
                //Reset slider when changing products
                this.activeSlide = 0;
            },
            enumerable: false,
            configurable: true
        });
        CarouselComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.template && i0.isDevMode()) {
                console.error('No template reference provided to render the carousel items for the `cx-carousel`');
                return;
            }
            this.size$ = this.service
                .getItemsPerSlide(this.el.nativeElement, this.itemWidth)
                .pipe(operators.tap(function () { return (_this.activeSlide = 0); }));
        };
        return CarouselComponent;
    }());
    CarouselComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-carousel',
                    template: "<ng-container *ngIf=\"items?.length > 0 && (size$ | async) as size\">\n  <h3 *ngIf=\"title\">{{ title }}</h3>\n\n  <div class=\"carousel-panel\" [ngClass]=\"'size-' + size\">\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"previous\"\n      (click)=\"activeSlide = activeSlide - size\"\n      [disabled]=\"activeSlide === 0\"\n    >\n      <cx-icon [type]=\"previousIcon\"></cx-icon>\n    </button>\n\n    <div class=\"slides\">\n      <ng-container *ngFor=\"let _ of items; let i = index\">\n        <div\n          class=\"slide\"\n          *ngIf=\"i % size === 0\"\n          [class.active]=\"i === activeSlide\"\n        >\n          <ng-container\n            *ngFor=\"let item of items | slice: i:i + size; let j = index\"\n          >\n            <div\n              *ngIf=\"item | async as data\"\n              class=\"item\"\n              [class.active]=\"i === activeSlide\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"template; context: { item: data }\"\n              ></ng-container>\n            </div>\n          </ng-container>\n        </div>\n      </ng-container>\n    </div>\n\n    <button\n      *ngIf=\"size < items.length\"\n      class=\"next\"\n      (click)=\"activeSlide = activeSlide + size\"\n      tabindex=\"-1\"\n      [disabled]=\"activeSlide > items.length - size - 1\"\n    >\n      <cx-icon [type]=\"nextIcon\"></cx-icon>\n    </button>\n  </div>\n\n  <div *ngIf=\"!hideIndicators && size < items.length\" class=\"indicators\">\n    <ng-container *ngFor=\"let _ of items; let i = index\">\n      <button\n        *ngIf=\"i % size === 0\"\n        (focus)=\"activeSlide = i\"\n        [disabled]=\"i === activeSlide\"\n        tabindex=\"-1\"\n      >\n        <cx-icon [type]=\"indicatorIcon\"></cx-icon>\n      </button>\n    </ng-container>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CarouselComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: CarouselService }
    ]; };
    CarouselComponent.propDecorators = {
        title: [{ type: i0.Input }],
        setItems: [{ type: i0.Input, args: ['items',] }],
        template: [{ type: i0.Input }],
        itemWidth: [{ type: i0.Input }],
        hideIndicators: [{ type: i0.Input }],
        indicatorIcon: [{ type: i0.Input }],
        previousIcon: [{ type: i0.Input }],
        nextIcon: [{ type: i0.Input }]
    };

    /**
     * The `BreakpointService` resolves the various screen sizes that are used in
     * the storefront. The screen sizes are globally configurable based on your
     * layout requirements. You can adjust the screen sizes by setting the minimum
     * and/or maximum size for a breakpoint, as well as extending the configuration
     * with new screens.
     *
     * By default, the `BreakpointService` is based on the breakpoints from the
     * Bootstrap ui library:
     * - `xs`: 0 - 576px
     * - `sm`: 576px - 768px
     * - `md`: 768px - 992px
     * - `lg`: 992px - 1200px
     * - `xl`: > 1200px
     */
    var BreakpointService = /** @class */ (function () {
        function BreakpointService(winRef, layoutConfig, platform) {
            var _this = this;
            this.winRef = winRef;
            this.layoutConfig = layoutConfig;
            this.platform = platform;
            this.breakpoint$ = i1$1.isPlatformBrowser(this.platform)
                ? this.winRef.resize$.pipe(operators.map(function (event) { return _this.getBreakpoint(event.target.innerWidth); }), operators.distinctUntilChanged())
                : rxjs.of(this.fallbackBreakpoint);
        }
        Object.defineProperty(BreakpointService.prototype, "breakpoints", {
            /**
             * Returns the breakpoints for the storefront layout.
             *
             * The breakpoints are driven by the `LayoutConfig.breakpoints` and sorted based on
             * the given screen size.
             */
            get: function () {
                if (!this._breakpoints) {
                    this._breakpoints = this.resolveBreakpointsFromConfig();
                }
                return this._breakpoints;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns the _maximum_ size for the breakpoint, given by the `LayoutConfig.breakpoints`
         * configuration.
         */
        BreakpointService.prototype.getSize = function (breakpoint) {
            var _a, _b;
            return ((_a = this.getMaxSize(breakpoint)) !== null && _a !== void 0 ? _a :
                // if there's no direct max value or explicit max value
                // we must derive the max value from the previous min
                this.getMinSize((_b = this.breakpoints) === null || _b === void 0 ? void 0 : _b[this.breakpoints.indexOf(breakpoint) + 1]));
        };
        /**
         * Indicates whether the current screen size is smaller than the maximum size of the
         * given breakpoint.
         *
         * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
         * window innerWidth is smaller than the configured size of `BREAKPOINT.md`.
         */
        BreakpointService.prototype.isDown = function (breakpoint) {
            var _this = this;
            return this.breakpoint$.pipe(operators.map(function (br) { return _this.breakpoints
                .slice(0, _this.breakpoints.indexOf(breakpoint) + 1)
                .includes(br); }));
        };
        /**
         * Indicates whether the current screen size is larger than the minimum size of the
         * given breakpoint.
         *
         * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
         * window innerWidth is larger than the configured size of `BREAKPOINT.sm`.
         */
        BreakpointService.prototype.isUp = function (breakpoint) {
            var _this = this;
            return this.breakpoint$.pipe(operators.map(function (br) { return _this.breakpoints
                .slice(_this.breakpoints.indexOf(breakpoint))
                .includes(br); }));
        };
        /**
         * Indicates whether the given breakpoint fits in the current screen size.
         */
        BreakpointService.prototype.isEqual = function (breakpoint) {
            return this.breakpoint$.pipe(operators.map(function (br) { return br === breakpoint; }));
        };
        Object.defineProperty(BreakpointService.prototype, "fallbackBreakpoint", {
            /**
             * Returns the fallback breakpoint in case no breakpoint can be resolved. This is
             * typically the case when we're on SSR without an actual window.
             *
             * Returns the smallest screen size (mobile first).
             */
            get: function () {
                var _a;
                return (_a = this.breakpoints) === null || _a === void 0 ? void 0 : _a[0];
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Resolves the breakpoints and sorts them according to the configured size.
         *
         * The sort order is by small to large screens.
         */
        BreakpointService.prototype.resolveBreakpointsFromConfig = function () {
            var _this = this;
            var sortByScreenSize = function (next, prev) {
                var maxNext = Math.max(_this.getMinSize(next) + 1 || 0, _this.getMaxSize(next) || 0);
                var maxPrev = Math.max(_this.getMinSize(prev) + 1 || 0, _this.getMaxSize(prev) || 0);
                return maxNext < maxPrev ? -1 : 0;
            };
            return Object.keys(this.config).sort(sortByScreenSize);
        };
        /**
         * Returns the _maximum_ size for the breakpoint, given by the
         * `LayoutConfig.breakpoints` configuration. We will try to resolve the
         * max size form the current breakpoint, but if this is not available, we
         * resolve it form the next breakpoint
         */
        BreakpointService.prototype.getMaxSize = function (breakpoint) {
            var breakpointConfig = this.config[breakpoint];
            if (!breakpointConfig) {
                return null;
            }
            // we treat numbers as the max number by default
            if (typeof breakpointConfig === 'number') {
                return breakpointConfig;
            }
            else if (breakpointConfig.max) {
                return breakpointConfig.max;
            }
            else {
                return null;
            }
        };
        BreakpointService.prototype.getMinSize = function (breakpoint) {
            var _a;
            return (_a = this.config[breakpoint]) === null || _a === void 0 ? void 0 : _a.min;
        };
        /**
         * Returns a `BREAKPOINT` for the given window size.
         *
         * This method tries to match the closest breakpoint for the give
         * window size. We'll fallback to the `largest` size in case the window
         * is greater than the largest configurable breakpoint.
         */
        BreakpointService.prototype.getBreakpoint = function (windowWidth) {
            var _this = this;
            var _a, _b;
            return ((_a = this.breakpoints.find(function (br) { return windowWidth <= _this.getSize(br); })) !== null && _a !== void 0 ? _a : (_b = this.breakpoints) === null || _b === void 0 ? void 0 : _b[this.breakpoints.length - 1]);
        };
        Object.defineProperty(BreakpointService.prototype, "config", {
            /**
             * Helper method to return the breakpoint configuration.
             */
            get: function () {
                var _a;
                return ((_a = this.layoutConfig) === null || _a === void 0 ? void 0 : _a.breakpoints) || {};
            },
            enumerable: false,
            configurable: true
        });
        return BreakpointService;
    }());
    BreakpointService.ɵprov = i0.ɵɵdefineInjectable({ factory: function BreakpointService_Factory() { return new BreakpointService(i0.ɵɵinject(i1.WindowRef), i0.ɵɵinject(LayoutConfig), i0.ɵɵinject(i0.PLATFORM_ID)); }, token: BreakpointService, providedIn: "root" });
    BreakpointService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    BreakpointService.ctorParameters = function () { return [
        { type: i1.WindowRef },
        { type: LayoutConfig },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };

    /**
     * Service which generates media URLs. It leverage the MediaContainer and MediaFormats so
     * that URLs and sizes are generated for the same media. This helps to improve performance
     * across difference devices and layouts.
     *
     * Media formats are optional, but highly recommended. The format will help the browser to
     * identify the right media for the right experience.
     *
     * The MediaService will generate absolute URLs in case relative URLs are provided for the Media.
     * The baseUrl is read from the `occConfig.backend.media.baseUrl` or
     * `occConfig.backend.occ.baseUrl`.
     */
    var MediaService = /** @class */ (function () {
        function MediaService(config, 
        /**
         * The BreakpointService is no longer used in version 2.0 as the different size formats are
         * driven by configuration only. There's however a change that this service will play a role
         * in the near future, which is why we keep the constructor as-is.
         */
        breakpointService) {
            this.config = config;
            this.breakpointService = breakpointService;
        }
        /**
         * Returns a `Media` object with the main media (`src`) and various media (`src`)
         * for specific formats.
         */
        MediaService.prototype.getMedia = function (mediaContainer, format, alt) {
            if (!mediaContainer) {
                return;
            }
            var mainMedia = mediaContainer.url
                ? mediaContainer
                : this.resolveMedia(mediaContainer, format);
            return {
                src: this.resolveAbsoluteUrl(mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.url),
                alt: alt || (mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.altText),
                srcset: this.resolveSrcSet(mediaContainer),
            };
        };
        Object.defineProperty(MediaService.prototype, "sortedFormats", {
            /**
             * Creates the media formats in a logical sorted order. The map contains the
             * format key and the format size information. We do this only once for performance
             * benefits.
             */
            get: function () {
                var _this = this;
                if (!this._sortedFormats) {
                    this._sortedFormats = Object.keys(this.config.mediaFormats)
                        .map(function (key) { return ({
                        code: key,
                        size: _this.config.mediaFormats[key],
                    }); })
                        .sort(function (a, b) { return (a.size.width > b.size.width ? 1 : -1); });
                }
                return this._sortedFormats;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MediaService.prototype, "reversedFormats", {
            /**
             * Creates the media formats in a reversed sorted order.
             */
            get: function () {
                if (!this._reversedFormats) {
                    this._reversedFormats = this.sortedFormats.slice().reverse();
                }
                return this._reversedFormats;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Resolves the right media for the given format. The fo
         */
        MediaService.prototype.resolveMedia = function (media, format) {
            return media[this.resolveFormat(media, format)];
        };
        /**
         * Validates the format against the given mediaContainer. If there is no format available,
         * or if the mediaContainer doesn't contain a media for the given media, the most optimal
         * format is resolved. If even that is not possible, the first format is returned.
         */
        MediaService.prototype.resolveFormat = function (mediaContainer, format) {
            if (format && mediaContainer[format]) {
                return format;
            }
            return (this.resolveBestFormat(mediaContainer) || Object.keys(mediaContainer)[0]);
        };
        /**
         * Returns the media format code with the best size.
         */
        MediaService.prototype.resolveBestFormat = function (media) {
            var _a;
            return (_a = this.reversedFormats.find(function (format) { return media.hasOwnProperty(format.code); })) === null || _a === void 0 ? void 0 : _a.code;
        };
        /**
         * Returns a set of media for the available media formats. Additionally, the congiured media
         * format width is added to the srcset, so that browsers can select the appropriate media.
         */
        MediaService.prototype.resolveSrcSet = function (media) {
            var _this = this;
            if (!media) {
                return undefined;
            }
            var srcset = this.sortedFormats.reduce(function (set, format) {
                if (!!media[format.code]) {
                    if (set) {
                        set += ', ';
                    }
                    set += _this.resolveAbsoluteUrl(media[format.code].url) + " " + format.size.width + "w";
                }
                return set;
            }, '');
            return srcset === '' ? undefined : srcset;
        };
        /**
         * Resolves the absolute URL for the given url. In most cases, this URL represents
         * the relative URL on the backend. In that case, we prefix the url with the baseUrl.
         */
        MediaService.prototype.resolveAbsoluteUrl = function (url) {
            if (!url) {
                return null;
            }
            return url.startsWith('http') ? url : this.getBaseUrl() + url;
        };
        /**
         * The base URL is either driven by a specific `backend.media.baseUrl`, or by the
         * `backend.occ.baseUrl`.
         *
         * The `backend.media.baseUrl` can be used to load media from a different location.
         *
         * In Commerce Cloud, a differnt location could mean a different "aspect".
         */
        MediaService.prototype.getBaseUrl = function () {
            return (this.config.backend.media.baseUrl ||
                this.config.backend.occ.baseUrl ||
                '');
        };
        return MediaService;
    }());
    MediaService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MediaService_Factory() { return new MediaService(i0.ɵɵinject(i1.Config), i0.ɵɵinject(BreakpointService)); }, token: MediaService, providedIn: "root" });
    MediaService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    MediaService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.Config,] }] },
        { type: BreakpointService }
    ]; };

    var MediaComponent = /** @class */ (function () {
        function MediaComponent(mediaService) {
            this.mediaService = mediaService;
            /**
             * Once the media is loaded, we emit an event.
             */
            this.loaded = new i0.EventEmitter();
            /**
             * The `cx-media` component has an `is-initialized` class as long as the
             * media is being initialized.
             */
            this.isInitialized = false;
            /**
             * The `cx-media` component has a `is-loading` class as long as the
             * media is loaded. Wehn the media is loaded, the `is-initialized` class
             * is added.
             */
            this.isLoading = true;
            /**
             * When there's no media provided for the content, or in case an error
             * happened during loading, we add the `is-missing` class. Visual effects
             * can be controlled by CSS.
             */
            this.isMissing = false;
        }
        MediaComponent.prototype.ngOnChanges = function () {
            this.create();
        };
        /**
         * Creates the `Media` object
         */
        MediaComponent.prototype.create = function () {
            var _a;
            this.media = this.mediaService.getMedia(this.container, this.format, this.alt);
            if (!((_a = this.media) === null || _a === void 0 ? void 0 : _a.src)) {
                this.handleMissing();
            }
        };
        /**
         * This handler is called from the UI when the image is loaded.
         */
        MediaComponent.prototype.loadHandler = function () {
            this.isLoading = false;
            this.isInitialized = true;
            this.isMissing = false;
            this.loaded.emit(true);
        };
        /**
         * Whenever an error happens during load, we mark the component
         * with css classes to have a missing media.
         */
        MediaComponent.prototype.errorHandler = function () {
            this.handleMissing();
        };
        MediaComponent.prototype.handleMissing = function () {
            this.isLoading = false;
            this.isInitialized = true;
            this.isMissing = true;
            this.loaded.emit(false);
        };
        return MediaComponent;
    }());
    MediaComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-media',
                    template: "<img\n  *ngIf=\"media?.src\"\n  [attr.src]=\"media.src\"\n  [attr.srcset]=\"media.srcset\"\n  [attr.alt]=\"media.alt\"\n  (load)=\"loadHandler()\"\n  (error)=\"errorHandler()\"\n/>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    MediaComponent.ctorParameters = function () { return [
        { type: MediaService }
    ]; };
    MediaComponent.propDecorators = {
        container: [{ type: i0.Input }],
        format: [{ type: i0.Input }],
        alt: [{ type: i0.Input }],
        loaded: [{ type: i0.Output }],
        isInitialized: [{ type: i0.HostBinding, args: ['class.is-initialized',] }],
        isLoading: [{ type: i0.HostBinding, args: ['class.is-loading',] }],
        isMissing: [{ type: i0.HostBinding, args: ['class.is-missing',] }]
    };

    var MediaModule = /** @class */ (function () {
        function MediaModule() {
        }
        MediaModule.forRoot = function () {
            return {
                ngModule: MediaModule,
            };
        };
        return MediaModule;
    }());
    MediaModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [MediaComponent],
                    exports: [MediaComponent],
                },] }
    ];

    var CarouselModule = /** @class */ (function () {
        function CarouselModule() {
        }
        return CarouselModule;
    }());
    CarouselModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, IconModule, MediaModule, i1.UrlModule],
                    declarations: [CarouselComponent],
                    exports: [CarouselComponent],
                },] }
    ];

    var DatePickerFormatterService = /** @class */ (function () {
        function DatePickerFormatterService() {
        }
        DatePickerFormatterService.prototype.toNative = function (value) {
            return value ? new Date(value).toISOString().split('T')[0] : null;
        };
        DatePickerFormatterService.prototype.toModel = function (value, endOfDay) {
            if (value) {
                var date = new Date(value)
                    .toISOString()
                    .replace('.', '+')
                    .replace('Z', '0');
                if (endOfDay) {
                    date = date.replace('00:00:00', '23:59:59');
                }
                return date;
            }
        };
        return DatePickerFormatterService;
    }());
    DatePickerFormatterService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DatePickerFormatterService_Factory() { return new DatePickerFormatterService(); }, token: DatePickerFormatterService, providedIn: "root" });
    DatePickerFormatterService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    DatePickerFormatterService.ctorParameters = function () { return []; };

    var DatePickerComponent = /** @class */ (function () {
        function DatePickerComponent(dateFormatterService) {
            this.dateFormatterService = dateFormatterService;
            this.nativeValue = null;
            this.endOfDay = false;
        }
        DatePickerComponent.prototype.onInput = function (event) {
            this.value = this.dateFormatterService.toModel(event.target.value, this.endOfDay);
            this.nativeValue = event.target.value;
            this.onChange(this.value);
        };
        DatePickerComponent.prototype.onChange = function (_event) { };
        DatePickerComponent.prototype.onTouched = function () { };
        DatePickerComponent.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        DatePickerComponent.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        DatePickerComponent.prototype.writeValue = function (value) {
            if (value) {
                this.value = value;
                this.nativeValue = this.dateFormatterService.toNative(value);
            }
        };
        DatePickerComponent.prototype.getMin = function () {
            return this.dateFormatterService.toNative(this.min);
        };
        DatePickerComponent.prototype.getMax = function () {
            return this.dateFormatterService.toNative(this.max);
        };
        DatePickerComponent.prototype.validate = function () {
            if (this.input && !this.input.nativeElement.validity.valid) {
                var validity = this.input.nativeElement.validity;
                var validators = {};
                if (validity.rangeOverflow) {
                    validators.cxDateMax = true;
                }
                if (validity.rangeUnderflow) {
                    validators.cxDateMin = true;
                }
                return validators;
            }
        };
        return DatePickerComponent;
    }());
    DatePickerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-date-picker',
                    template: "<input\n  #inputElement\n  type=\"date\"\n  class=\"form-control\"\n  (blur)=\"onTouched()\"\n  (input)=\"onInput($event)\"\n  [value]=\"nativeValue\"\n  [required]=\"required\"\n  [class.is-invalid]=\"invalid\"\n  [min]=\"getMin()\"\n  [max]=\"getMax()\"\n/>\n",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return DatePickerComponent; }),
                            multi: true,
                        },
                        {
                            provide: forms.NG_VALIDATORS,
                            useExisting: i0.forwardRef(function () { return DatePickerComponent; }),
                            multi: true,
                        },
                    ]
                },] }
    ];
    DatePickerComponent.ctorParameters = function () { return [
        { type: DatePickerFormatterService }
    ]; };
    DatePickerComponent.propDecorators = {
        input: [{ type: i0.ViewChild, args: ['inputElement', { static: false, read: i0.ElementRef },] }],
        min: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        endOfDay: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        invalid: [{ type: i0.Input }]
    };

    var DatePickerModule = /** @class */ (function () {
        function DatePickerModule() {
        }
        return DatePickerModule;
    }());
    DatePickerModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [DatePickerComponent],
                    exports: [DatePickerComponent],
                },] }
    ];

    /**
     * Service responsible for converting date-like strings to/from formats compatible with the `<input type="datetime-local">`
     * HTML element and valid strings compatible with the `Date` object.
     *
     * Date values used are relative to the local timezone of the user.
     */
    var DateTimePickerFormatterService = /** @class */ (function () {
        function DateTimePickerFormatterService() {
        }
        /**
         * Convert date string into a string format compatable with the browser's native `<input type="datetime-local">` HTML element.
         * @param value: date string to convert
         *
         * @example
         * With UTC-0 local offset, `toNative('2010-01-01T00:00+0000')` returns `'2010-01-01T00:00'`.
         */
        DateTimePickerFormatterService.prototype.toNative = function (value) {
            return value
                ? this.formatDateStringWithTimezone(value, this.getLocalTimezoneOffset(true))
                : null;
        };
        /**
         * Convert datetime-local native string into a valid datetime string.
         * @param value: datetime-local string to convert
         *
         * @example
         * With UTC-0 locale offset, `toModel('2010-01-01T00:00')` returns `'2010-01-01T00:00:00+00:00'`.
         */
        DateTimePickerFormatterService.prototype.toModel = function (value) {
            return value ? value + ":00" + this.getLocalTimezoneOffset() : null;
        };
        /**
         * Returns the local timezone in a format that can be appended to a date-like string.
         * @param invert (default: false): returns the opposite operator relative to the local timezone
         *
         * @example
         * When locale is set to a CEST timezone, `getLocalTimezoneOffset()` returns '+02:00'
         * and `getLocalTimezoneOffset(true)` returns '-02:00'
         */
        DateTimePickerFormatterService.prototype.getLocalTimezoneOffset = function (invert) {
            var offset = new Date().getTimezoneOffset() * -1;
            var hours = Math.abs(Math.floor(offset / 60))
                .toString()
                .padStart(2, '0');
            var minutes = (offset % 60).toString().padStart(2, '0');
            var sign = offset >= 0 ? (invert ? "-" : "+") : invert ? "+" : "-";
            return "" + sign + hours + ":" + minutes;
        };
        /**
         * Format date string into a format compatable with the browser's native `<input type="datetime-local">` HTML element.
         * @param dateString: date string to convert
         * @param offset: offset to append to date string
         *
         * @example
         * With UTC-0 local offset, `formatDateStringWithTimezone('2010-01-01T00:00+0000', '+00:00')` returns `'2010-01-01T00:00+00:00'`.
         */
        DateTimePickerFormatterService.prototype.formatDateStringWithTimezone = function (dateString, offset) {
            return new Date(dateString.replace('+0000', offset))
                .toISOString()
                .substring(0, 16);
        };
        return DateTimePickerFormatterService;
    }());
    DateTimePickerFormatterService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DateTimePickerFormatterService_Factory() { return new DateTimePickerFormatterService(); }, token: DateTimePickerFormatterService, providedIn: "root" });
    DateTimePickerFormatterService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * This component serves the browser's native `<input type="datetime-local">` HTML element
     * in whilst projecting the value in the standard date format with regards to timezone offsets.
     */
    var DateTimePickerComponent = /** @class */ (function () {
        function DateTimePickerComponent(dateFormatterService) {
            this.dateFormatterService = dateFormatterService;
            this.nativeValue = null;
        }
        /**
         * Handler method for input interactions.
         * @param event: Input event.
         */
        DateTimePickerComponent.prototype.onInput = function (event) {
            this.value = this.dateFormatterService.toModel(event.target.value);
            this.nativeValue = event.target.value;
            this.onChange(this.value);
        };
        /**
         * Handler method for when the value is modified.
         * @param event: Change event.
         */
        DateTimePickerComponent.prototype.onChange = function (_event) { };
        /**
         * Handler method for when the element is interacted with.
         */
        DateTimePickerComponent.prototype.onTouched = function () { };
        /**
         * Register the `onChange()` handler method.
         */
        DateTimePickerComponent.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        /**
         * Register the `onTouched()` handler method.
         */
        DateTimePickerComponent.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        /**
         * Set the value of the input element.
         * @param value: Date-like string to be set
         */
        DateTimePickerComponent.prototype.writeValue = function (value) {
            if (value) {
                this.value = value;
                this.nativeValue = this.dateFormatterService.toNative(value);
            }
        };
        /**
         * Get the minimum value allowed for the input.
         */
        DateTimePickerComponent.prototype.getMin = function () {
            return this.dateFormatterService.toNative(this.min);
        };
        /**
         * Get the maximum value allowed for the input.
         */
        DateTimePickerComponent.prototype.getMax = function () {
            return this.dateFormatterService.toNative(this.max);
        };
        /**
         * Returns failing validators if input value is invalid
         */
        DateTimePickerComponent.prototype.validate = function () {
            if (this.input && !this.input.nativeElement.validity.valid) {
                var validity = this.input.nativeElement.validity;
                var validators = {};
                if (validity.rangeOverflow) {
                    validators.cxDateMax = true;
                }
                if (validity.rangeUnderflow) {
                    validators.cxDateMin = true;
                }
                return validators;
            }
        };
        return DateTimePickerComponent;
    }());
    DateTimePickerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-date-time-picker',
                    template: "<input\n  #inputElement\n  type=\"datetime-local\"\n  class=\"form-control\"\n  (blur)=\"onTouched()\"\n  (input)=\"onInput($event)\"\n  [value]=\"nativeValue\"\n  [required]=\"required\"\n  [class.is-invalid]=\"invalid\"\n  [min]=\"getMin()\"\n  [max]=\"getMax()\"\n/>\n",
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return DateTimePickerComponent; }),
                            multi: true,
                        },
                        {
                            provide: forms.NG_VALIDATORS,
                            useExisting: i0.forwardRef(function () { return DateTimePickerComponent; }),
                            multi: true,
                        },
                    ]
                },] }
    ];
    DateTimePickerComponent.ctorParameters = function () { return [
        { type: DateTimePickerFormatterService }
    ]; };
    DateTimePickerComponent.propDecorators = {
        input: [{ type: i0.ViewChild, args: ['inputElement', { static: false, read: i0.ElementRef },] }],
        min: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        invalid: [{ type: i0.Input }]
    };

    var DateTimePickerModule = /** @class */ (function () {
        function DateTimePickerModule() {
        }
        return DateTimePickerModule;
    }());
    DateTimePickerModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [DateTimePickerComponent],
                    exports: [DateTimePickerComponent],
                },] }
    ];

    /**
     * This component renders form errors.
     */
    var FormErrorsComponent = /** @class */ (function () {
        function FormErrorsComponent() {
        }
        Object.defineProperty(FormErrorsComponent.prototype, "control", {
            get: function () {
                return this._control;
            },
            set: function (control) {
                this._control = control;
                this.errors$ = control === null || control === void 0 ? void 0 : control.statusChanges.pipe(operators.startWith({}), operators.map(function () { return control.errors || {}; }), operators.map(function (errors) { return Object.entries(errors)
                    .filter(function (error) { return error[1]; })
                    .map(function (error) { return error[0]; }); }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FormErrorsComponent.prototype, "invalid", {
            get: function () {
                var _a;
                return (_a = this.control) === null || _a === void 0 ? void 0 : _a.invalid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FormErrorsComponent.prototype, "dirty", {
            get: function () {
                var _a;
                return (_a = this.control) === null || _a === void 0 ? void 0 : _a.dirty;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FormErrorsComponent.prototype, "touched", {
            get: function () {
                var _a;
                return (_a = this.control) === null || _a === void 0 ? void 0 : _a.touched;
            },
            enumerable: false,
            configurable: true
        });
        return FormErrorsComponent;
    }());
    FormErrorsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-form-errors',
                    template: "<p *ngFor=\"let errorName of errors$ | async\">\n  {{ 'formErrors.' + errorName | cxTranslate: translationParams }}\n</p>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    FormErrorsComponent.propDecorators = {
        translationParams: [{ type: i0.Input }],
        control: [{ type: i0.Input }],
        invalid: [{ type: i0.HostBinding, args: ['class.control-invalid',] }],
        dirty: [{ type: i0.HostBinding, args: ['class.control-dirty',] }],
        touched: [{ type: i0.HostBinding, args: ['class.control-touched',] }]
    };

    var FormErrorsModule = /** @class */ (function () {
        function FormErrorsModule() {
        }
        return FormErrorsModule;
    }());
    FormErrorsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule],
                    declarations: [FormErrorsComponent],
                    exports: [FormErrorsComponent],
                },] }
    ];

    /**
     * This component navigates using [routerLink] attribute when input 'url' is a relative url. Otherwise (when it's absolute), [href] is used.
     */
    var GenericLinkComponent = /** @class */ (function () {
        function GenericLinkComponent(router) {
            this.router = router;
            /**
             * Pattern matching string starting with `http://` or `https://`.
             */
            this.PROTOCOL_REGEX = /^https?:\/\//i;
            /**
             * Used to split url into 2 parts:
             * 1. the path
             * 2. query params + hash fragment
             */
            this.URL_SPLIT = /(^[^#?]*)(.*)/;
            /**
             * Parsed parts of the @Input `url`, when it's a local URL.
             * It should not be used when the `url` is external.
             * @see `url`
             */
            this.routeParts = {};
        }
        /**
         * Returns true when the @Input `url` is a string starting with `http://` or `https://`.
         */
        GenericLinkComponent.prototype.isExternalUrl = function () {
            return typeof this.url === 'string' && this.PROTOCOL_REGEX.test(this.url);
        };
        Object.defineProperty(GenericLinkComponent.prototype, "rel", {
            get: function () {
                return this.target === '_blank' ? 'noopener' : null;
            },
            enumerable: false,
            configurable: true
        });
        GenericLinkComponent.prototype.ngOnChanges = function (changes) {
            if (changes['url']) {
                this.setUrlParts(changes['url'].currentValue);
            }
        };
        Object.defineProperty(GenericLinkComponent.prototype, "routerUrl", {
            /**
             * The part with the path of the local url.
             */
            get: function () {
                return this.routeParts.path;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(GenericLinkComponent.prototype, "queryParams", {
            /**
             * The part with the query params of the local url.
             */
            get: function () {
                return this.routeParts.queryParams;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(GenericLinkComponent.prototype, "fragment", {
            /**
             * The part with the hash fragment of the local url.
             */
            get: function () {
                return this.routeParts.fragment;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Parses the given url and sets the property `urlParts` accordingly.
         */
        GenericLinkComponent.prototype.setUrlParts = function (url) {
            if (typeof url === 'string') {
                url = this.getAbsoluteUrl(url); // string links in CMS sometimes don't have the leading slash, so fix it here
                this.routeParts = this.splitUrl(url);
            }
            else {
                this.routeParts = { path: url };
            }
        };
        /**
         * Parses the given string into 3 parts:
         * - string path (wrapped in an array to be compatible with Angular syntax for the `routerLink`)
         * - query params (as an object)
         * - hash fragment (string)
         */
        GenericLinkComponent.prototype.splitUrl = function (url) {
            if (url === void 0) { url = ''; }
            var _a = this.router.parseUrl(url), queryParams = _a.queryParams, fragment = _a.fragment;
            var _b = __read(url.match(this.URL_SPLIT), 2), path = _b[1];
            // wrap path in an array, to have the Angular-like path format
            return { path: [path], queryParams: queryParams, fragment: fragment };
        };
        /**
         * Prepends a leading slash to the given URL string, in case it doesn't have it.
         */
        GenericLinkComponent.prototype.getAbsoluteUrl = function (url) {
            return url.startsWith('/') ? url : '/' + url;
        };
        return GenericLinkComponent;
    }());
    GenericLinkComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-generic-link',
                    template: "<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf=\"isExternalUrl(); else isLocalUrl\">\n  <a\n    role=\"link\"\n    [href]=\"url\"\n    [attr.target]=\"target\"\n    [attr.rel]=\"rel\"\n    [attr.class]=\"class\"\n    [attr.id]=\"id\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    role=\"link\"\n    [routerLink]=\"routerUrl\"\n    [queryParams]=\"queryParams\"\n    [fragment]=\"fragment\"\n    [attr.target]=\"target\"\n    [attr.class]=\"class\"\n    [attr.id]=\"id\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n"
                },] }
    ];
    GenericLinkComponent.ctorParameters = function () { return [
        { type: i4.Router }
    ]; };
    GenericLinkComponent.propDecorators = {
        url: [{ type: i0.Input }],
        target: [{ type: i0.Input }],
        class: [{ type: i0.Input }],
        id: [{ type: i0.Input }],
        style: [{ type: i0.Input }],
        title: [{ type: i0.Input }]
    };

    var GenericLinkModule = /** @class */ (function () {
        function GenericLinkModule() {
        }
        return GenericLinkModule;
    }());
    GenericLinkModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule],
                    declarations: [GenericLinkComponent],
                    exports: [GenericLinkComponent],
                },] }
    ];

    /**
     * Provides a UI to manage the count of the quantity, typically by using
     * increase and decrease functionality. The item counter expects an input `FormControl`
     * so that the state of the control can be managed outside of this component.
     */
    var ItemCounterComponent = /** @class */ (function () {
        function ItemCounterComponent() {
            /**
             * This can be used in case an item has a minmum order quantity.
             * @default 1
             */
            this.min = 1;
            /**
             * The step is used to increment the count. It is supposed to be a
             * positive integer or float.
             * @default 1
             */
            this.step = 1;
            /**
             * Indicates that the input can be manually set to zero,
             * despite the fact that the input controls will be limited to
             * the minimum. The zero value can be used to remove an item.
             */
            this.allowZero = false;
            /**
             * In readonly mode the item counter will only be shown as a label,
             * the form controls are not rendered.
             * Please not that readonly is different from the `disabled` form state.
             * @default false
             */
            this.readonly = false;
        }
        ItemCounterComponent.prototype.handleClick = function () {
            this.input.nativeElement.focus();
        };
        ItemCounterComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.sub = this.control.valueChanges
                .pipe(operators.startWith(this.control.value))
                .subscribe(function (value) { return _this.control.setValue(_this.getValidCount(value), { emitEvent: false }); });
        };
        ItemCounterComponent.prototype.ngOnDestroy = function () {
            if (this.sub) {
                this.sub.unsubscribe();
            }
        };
        ItemCounterComponent.prototype.increment = function () {
            // it's too early to use the `stepUp` and `stepDown` API...
            // let's wait for FF: https://caniuse.com/#search=stepUp
            this.control.setValue(this.control.value + this.step);
            this.control.markAsDirty();
        };
        ItemCounterComponent.prototype.decrement = function () {
            this.control.setValue(this.control.value - this.step);
            this.control.markAsDirty();
        };
        /**
         * Validate that the given value is in between
         * the `min` and `max` value. If the value is out
         * of  the min/max range, it will be altered.
         * If `allowZero` is set to true, the 0 value is ignored.
         *
         */
        ItemCounterComponent.prototype.getValidCount = function (value) {
            if (value < this.min && !(value === 0 && this.allowZero)) {
                value = this.min;
            }
            if (this.max && value > this.max) {
                value = this.max;
            }
            return value;
        };
        return ItemCounterComponent;
    }());
    ItemCounterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-item-counter',
                    template: "<button\n  type=\"button\"\n  (click)=\"decrement()\"\n  [disabled]=\"control.disabled || control.value <= min\"\n  tabindex=\"-1\"\n>\n  -\n</button>\n\n<input\n  #qty\n  type=\"number\"\n  [min]=\"min\"\n  [max]=\"max\"\n  [step]=\"step\"\n  [readonly]=\"readonly\"\n  [tabindex]=\"readonly ? -1 : 0\"\n  [formControl]=\"control\"\n/>\n\n<button\n  type=\"button\"\n  (click)=\"increment()\"\n  [disabled]=\"control.disabled || control.value >= max\"\n  tabindex=\"-1\"\n>\n  +\n</button>\n"
                },] }
    ];
    ItemCounterComponent.propDecorators = {
        control: [{ type: i0.Input }],
        min: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        step: [{ type: i0.Input }],
        allowZero: [{ type: i0.Input }],
        readonly: [{ type: i0.HostBinding, args: ['class.readonly',] }, { type: i0.Input }],
        input: [{ type: i0.ViewChild, args: ['qty',] }],
        handleClick: [{ type: i0.HostListener, args: ['click',] }]
    };

    var ItemCounterModule = /** @class */ (function () {
        function ItemCounterModule() {
        }
        return ItemCounterModule;
    }());
    ItemCounterModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, forms.ReactiveFormsModule],
                    declarations: [ItemCounterComponent],
                    exports: [ItemCounterComponent],
                },] }
    ];

    var defaultPaginationConfig = {
        pagination: {
            addStart: true,
            addEnd: true,
        },
    };

    var PaginationConfig = /** @class */ (function () {
        function PaginationConfig() {
        }
        return PaginationConfig;
    }());
    PaginationConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function PaginationConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: PaginationConfig, providedIn: "root" });
    PaginationConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    /**
     * The item type is used to add semantic structure to the
     * PaginationItem, so that the UI understands the usage.
     */
    (function (PaginationItemType) {
        PaginationItemType["GAP"] = "gap";
        PaginationItemType["FIRST"] = "first";
        PaginationItemType["LAST"] = "last";
        PaginationItemType["PREVIOUS"] = "previous";
        PaginationItemType["NEXT"] = "next";
        PaginationItemType["START"] = "start";
        PaginationItemType["END"] = "end";
        PaginationItemType["PAGE"] = "page";
    })(exports.PaginationItemType || (exports.PaginationItemType = {}));
    (function (PaginationNavigationPosition) {
        PaginationNavigationPosition["ASIDE"] = "aside";
        PaginationNavigationPosition["BEFORE"] = "before";
        PaginationNavigationPosition["AFTER"] = "after";
    })(exports.PaginationNavigationPosition || (exports.PaginationNavigationPosition = {}));

    var FALLBACK_PAGINATION_OPTIONS = {
        rangeCount: 3,
        dotsLabel: '...',
        startLabel: '«',
        previousLabel: '‹',
        nextLabel: '›',
        endLabel: '»',
    };
    /**
     * Builds a pagination structures based on a pageCount and current page number.
     * There are various {@link PaginationConfig} options which can be used to configure
     * the behaviour of the build. Alternatively, CSS can be used to further customise
     * the pagination.
     *
     * Examples:
     * The full blown pagination items contain the follow elements:
     *
     * `« ‹ 1 ... 4 (5) 6 ... 9 › »`
     *
     * This includes pagination items to the following pages:
     * - start page
     * - previous page
     * - first page
     * - page range
     * - last page
     * - next page
     * - end page
     *
     * All of those links are configurable, including the size of the page range.
     * The current page will always be centered in the page range to provide direct access
     * to the previous and next page.
     */
    var PaginationBuilder = /** @class */ (function () {
        function PaginationBuilder(paginationConfig) {
            this.paginationConfig = paginationConfig;
        }
        /**
         * Builds a list of `PaginationItem`. The give pageCount and current are used
         * to build out the full pagination. There are various {@link PaginationConfig} options
         * which can be used to configure the behavior of the build. Alternatively, CSS
         * can be used to further specialize visibility of the pagination.
         *
         * @param pageCount The total number of pages
         * @param current The current page number, 0-index based
         * @returns An array of `PaginationItem`
         */
        PaginationBuilder.prototype.paginate = function (pageCount, current) {
            var pages = [];
            if (pageCount < 2) {
                return pages;
            }
            this.addPages(pages, pageCount, current);
            this.addDots(pages, pageCount);
            this.addFirstLast(pages, pageCount);
            this.addNavigation(pages, pageCount, current);
            return pages;
        };
        /**
         * Returns the current page with surrounding pages (based on the `config.rangeCount`).
         * The current page is always centered to provide direct access to the previous and next page.
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         * @param current The current page number, 0-index based
         */
        PaginationBuilder.prototype.addPages = function (pages, pageCount, current) {
            var start = this.getStartOfRange(pageCount, current);
            var max = Math.min(this.config.rangeCount, pageCount);
            Array.from(Array(max)).forEach(function (_, i) {
                pages.push({
                    number: i + start,
                    label: String(i + start + 1),
                    type: exports.PaginationItemType.PAGE,
                });
            });
        };
        /**
         * Adds dots before and after the given pages, if configured (defaults to true).
         * If the dots only represent a single page, the page number is added instead of
         * the dots, unless the configuration requires dots always.
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         */
        PaginationBuilder.prototype.addDots = function (pages, pageCount) {
            var _this = this;
            if (!this.config.addDots) {
                return;
            }
            var addFirstGap = function () {
                var firstItemNumber = pages[0].number;
                var gapNumber = _this.config.addFirst ? 1 : 0;
                if (firstItemNumber > gapNumber) {
                    var isGap = !_this.config.substituteDotsForSingularPage ||
                        firstItemNumber !== gapNumber + 1;
                    var isSubstitued = _this.config.addFirst &&
                        _this.config.substituteDotsForSingularPage &&
                        gapNumber === 0;
                    var type = isGap
                        ? exports.PaginationItemType.GAP
                        : isSubstitued
                            ? exports.PaginationItemType.FIRST
                            : exports.PaginationItemType.PAGE;
                    return [
                        Object.assign({
                            label: isGap ? _this.config.dotsLabel : String(gapNumber + 1),
                            type: type,
                        }, isGap ? null : { number: gapNumber }),
                    ];
                }
                else
                    return [];
            };
            var addLastGap = function () {
                var nextPageNumber = pages[pages.length - 1].number + 1;
                var last = pageCount - (_this.config.addLast ? 2 : 1);
                if (nextPageNumber <= last) {
                    var isSubstitued = _this.config.addLast &&
                        _this.config.substituteDotsForSingularPage &&
                        nextPageNumber === last;
                    var isGap = nextPageNumber <
                        pageCount -
                            (_this.config.substituteDotsForSingularPage ? 1 : 0) -
                            (_this.config.addLast ? 1 : 0);
                    var type = isGap
                        ? exports.PaginationItemType.GAP
                        : isSubstitued
                            ? exports.PaginationItemType.LAST
                            : exports.PaginationItemType.PAGE;
                    return [
                        Object.assign({
                            label: isGap ? _this.config.dotsLabel : String(nextPageNumber + 1),
                            type: type,
                        }, isGap ? null : { number: nextPageNumber }),
                    ];
                }
                else
                    return [];
            };
            pages.unshift.apply(pages, __spread(addFirstGap()));
            pages.push.apply(pages, __spread(addLastGap()));
        };
        /**
         * Add links to the first and last page, if configured to do so.
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         *
         */
        PaginationBuilder.prototype.addFirstLast = function (pages, pageCount) {
            if (this.config.addFirst && pages[0].number !== 0) {
                pages.unshift({
                    number: 0,
                    label: '1',
                    type: exports.PaginationItemType.FIRST,
                });
            }
            if (this.config.addLast &&
                pages[pages.length - 1].number !== pageCount - 1) {
                pages.push({
                    number: pageCount - 1,
                    label: String(pageCount),
                    type: exports.PaginationItemType.LAST,
                });
            }
        };
        /**
         * Add links to the start, previous, next and last page, if configured to do so.
         * The order of the links can be configured by using the {@link PaginationConfig},
         * using the `PaginationNavigationPosition` (`BEFORE` or `AFTER`).
         * The `PaginationNavigationPosition` allows for 3 flavours:
         *
         * - by default the pagination starts with start and previous and ends with the next and end links
         * - BEFORE – all navigation links are added in the front of the pagination list
         * - AFTER – all navigation links are pushed to the end of the pagination list
         *
         * @param pages The list of page items that is used to amend
         * @param pageCount The total number of pages
         * @param current The current page number, 0-index based
         *
         */
        PaginationBuilder.prototype.addNavigation = function (pages, pageCount, current) {
            var before = this.getBeforeLinks(current);
            var after = this.getAfter(pageCount, current);
            var pos = this.config.navigationPosition;
            if (!pos || pos === exports.PaginationNavigationPosition.ASIDE) {
                pages.unshift.apply(pages, __spread(before));
                pages.push.apply(pages, __spread(after));
            }
            else {
                if (pos === exports.PaginationNavigationPosition.BEFORE) {
                    pages.unshift.apply(pages, __spread(before, after));
                }
                if (pos === exports.PaginationNavigationPosition.AFTER) {
                    pages.push.apply(pages, __spread(before, after));
                }
            }
        };
        /**
         * Returns the start and previous links, if applicable.
         */
        PaginationBuilder.prototype.getBeforeLinks = function (current) {
            var _this = this;
            var list = [];
            if (this.config.addStart) {
                var start = function () {
                    return Object.assign({
                        label: _this.config.startLabel,
                        type: exports.PaginationItemType.START,
                    }, current > 0 ? { number: 0 } : null);
                };
                list.push(start());
            }
            if (this.config.addPrevious) {
                var previous = function () {
                    return Object.assign({
                        label: _this.config.previousLabel,
                        type: exports.PaginationItemType.PREVIOUS,
                    }, current > 0 ? { number: current - 1 } : null);
                };
                list.push(previous());
            }
            return list;
        };
        /**
         * Returns the next and end links, if applicable.
         */
        PaginationBuilder.prototype.getAfter = function (pageCount, current) {
            var _this = this;
            var list = [];
            if (this.config.addNext) {
                var next = function () {
                    return Object.assign({
                        label: _this.config.nextLabel,
                        type: exports.PaginationItemType.NEXT,
                    }, current < pageCount - 1 ? { number: current + 1 } : null);
                };
                list.push(next());
            }
            if (this.config.addEnd) {
                var end = function () {
                    return Object.assign({
                        label: _this.config.endLabel,
                        type: exports.PaginationItemType.END,
                    }, current < pageCount - 1 ? { number: pageCount - 1 } : null);
                };
                list.push(end());
            }
            return list;
        };
        /**
         * Resolves the first page of the range we need to build.
         * This is the page that is leading up to the range of the
         * current page.
         *
         * @param pageCount The total number of pages.
         * @param current The current page number, 0-index based.
         */
        PaginationBuilder.prototype.getStartOfRange = function (pageCount, current) {
            var count = this.config.rangeCount - 1;
            // the least number of pages before and after the current
            var delta = Math.round(count / 2);
            // ensure that we start with at least the first page
            var minStart = Math.max(0, current - delta);
            // ensures that we start with at least 1 and do not pass the last range
            var maxStart = Math.max(0, pageCount - count - 1);
            // ensure that we get at least a full range at the end
            return Math.min(maxStart, minStart);
        };
        Object.defineProperty(PaginationBuilder.prototype, "config", {
            get: function () {
                return Object.assign(FALLBACK_PAGINATION_OPTIONS, this.paginationConfig.pagination);
            },
            enumerable: false,
            configurable: true
        });
        return PaginationBuilder;
    }());
    PaginationBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function PaginationBuilder_Factory() { return new PaginationBuilder(i0.ɵɵinject(PaginationConfig)); }, token: PaginationBuilder, providedIn: "root" });
    PaginationBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    PaginationBuilder.ctorParameters = function () { return [
        { type: PaginationConfig }
    ]; };

    /**
     * The `PaginationComponent` is a generic component that is used for
     * all lists in Spartacus that require pagination. The component supports
     * all common features, which can be configured or hidden by CSS.
     */
    var PaginationComponent = /** @class */ (function () {
        function PaginationComponent(paginationBuilder, activatedRoute) {
            this.paginationBuilder = paginationBuilder;
            this.activatedRoute = activatedRoute;
            this.viewPageEvent = new i0.EventEmitter();
            this.pages = [];
        }
        Object.defineProperty(PaginationComponent.prototype, "pagination", {
            get: function () {
                return this._pagination;
            },
            set: function (value) {
                this._pagination = value;
                this.render(value);
            },
            enumerable: false,
            configurable: true
        });
        PaginationComponent.prototype.render = function (pagination) {
            this.pages = this.paginationBuilder.paginate(pagination.totalPages, pagination.currentPage);
        };
        /**
         * Indicates whether the given item is the current item.
         *
         * @param item PaginationItem
         * @returns boolean
         */
        PaginationComponent.prototype.isCurrent = function (item) {
            return (item.type === exports.PaginationItemType.PAGE &&
                item.number === this.pagination.currentPage);
        };
        /**
         * Indicates whether the pagination item is inactive. This is used
         * to disabled a link or set the tabindex to `-1`.
         *
         * Defaults to true
         *
         * @param item PaginationItem
         * @returns returns -1 in case of a disabled
         */
        PaginationComponent.prototype.isInactive = function (item) {
            return (!item.hasOwnProperty('number') ||
                item.number === this.pagination.currentPage);
        };
        PaginationComponent.prototype.getQueryParams = function (item) {
            var queryParams = Object.assign({}, this.activatedRoute.snapshot.queryParams);
            if (this.queryParam &&
                item.number < this.pagination.totalPages &&
                !this.isCurrent(item)) {
                queryParams[this.queryParam] = item.number;
            }
            // omit the page number from the query parameters in case it's the default
            // to clean up the experience and avoid unnecessary polluting of the URL
            if (queryParams[this.queryParam] === this.defaultPage) {
                delete queryParams[this.queryParam];
            }
            return queryParams;
        };
        PaginationComponent.prototype.pageChange = function (page) {
            this.viewPageEvent.emit(page.number);
        };
        return PaginationComponent;
    }());
    PaginationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-pagination',
                    template: "<a\n  *ngFor=\"let item of pages\"\n  [class]=\"item.type\"\n  [class.disabled]=\"isInactive(item)\"\n  [class.current]=\"isCurrent(item)\"\n  [routerLink]=\"pageRoute\"\n  [queryParams]=\"getQueryParams(item)\"\n  [tabIndex]=\"isInactive(item) ? -1 : 0\"\n  (click)=\"pageChange(item)\"\n>\n  {{ item.label }}\n</a>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PaginationComponent.ctorParameters = function () { return [
        { type: PaginationBuilder },
        { type: i4.ActivatedRoute }
    ]; };
    PaginationComponent.propDecorators = {
        pageRoute: [{ type: i0.Input }],
        queryParam: [{ type: i0.Input }],
        defaultPage: [{ type: i0.Input }],
        pagination: [{ type: i0.Input }],
        viewPageEvent: [{ type: i0.Output }]
    };

    var PaginationModule = /** @class */ (function () {
        function PaginationModule() {
        }
        return PaginationModule;
    }());
    PaginationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule],
                    providers: [i1.provideDefaultConfig(defaultPaginationConfig)],
                    declarations: [PaginationComponent],
                    exports: [PaginationComponent],
                },] }
    ];

    var SortingComponent = /** @class */ (function () {
        function SortingComponent() {
            this.sortListEvent = new i0.EventEmitter();
        }
        SortingComponent.prototype.sortList = function (sortCode) {
            this.sortListEvent.emit(sortCode);
        };
        return SortingComponent;
    }());
    SortingComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-sorting',
                    template: "<ng-select\n  [searchable]=\"false\"\n  [clearable]=\"false\"\n  placeholder=\"{{ placeholder }}\"\n  (change)=\"sortList($event)\"\n  [ngModel]=\"selectedOption\"\n>\n  <ng-option *ngFor=\"let sort of sortOptions\" [value]=\"sort.code\">{{\n    sort.name ? sort.name : sortLabels ? sortLabels[sort.code] : ''\n  }}</ng-option>\n</ng-select>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    SortingComponent.ctorParameters = function () { return []; };
    SortingComponent.propDecorators = {
        sortOptions: [{ type: i0.Input }],
        selectedOption: [{ type: i0.Input }],
        placeholder: [{ type: i0.Input }],
        sortLabels: [{ type: i0.Input }],
        sortListEvent: [{ type: i0.Output }]
    };

    var ListNavigationModule = /** @class */ (function () {
        function ListNavigationModule() {
        }
        return ListNavigationModule;
    }());
    ListNavigationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        ngSelect.NgSelectModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        IconModule,
                        PaginationModule,
                    ],
                    declarations: [SortingComponent],
                    exports: [SortingComponent, PaginationComponent],
                },] }
    ];

    /**
     * Provides configuration specific to Media, such as images. This is used to optimize
     * rendering of the media, SEO and performance.
     */
    var MediaConfig = /** @class */ (function () {
        function MediaConfig() {
        }
        return MediaConfig;
    }());
    MediaConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function MediaConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: MediaConfig, providedIn: "root" });
    MediaConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    /**
     * A reference to a newly opened modal
     *
     * @todo remove ngb dependency and create our own implementation of ModalRef
     */
    var ModalRef = /** @class */ (function (_super) {
        __extends(ModalRef, _super);
        function ModalRef() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ModalRef;
    }(i1$3.NgbModalRef));

    /**
     * A service to handle modal
     */
    var ModalService = /** @class */ (function () {
        function ModalService(ngbModalService) {
            this.ngbModalService = ngbModalService;
            this.modals = [];
        }
        ModalService.prototype.open = function (content, options) {
            var activeModal;
            activeModal = this.ngbModalService.open(content, options);
            this.modals.push(activeModal);
            this.handleModalRemoveEvents(activeModal);
            return activeModal;
        };
        ModalService.prototype.handleModalRemoveEvents = function (modal) {
            var _this = this;
            modal.result.finally(function () {
                _this.modals = _this.modals.filter(function (m) { return m !== modal; });
            });
        };
        ModalService.prototype.getActiveModal = function () {
            var modal = this.modals[this.modals.length - 1];
            return modal ? modal : null;
        };
        ModalService.prototype.dismissActiveModal = function (reason) {
            var modal = this.getActiveModal();
            if (modal) {
                modal.dismiss(reason);
            }
        };
        ModalService.prototype.closeActiveModal = function (reason) {
            var modal = this.getActiveModal();
            if (modal) {
                modal.close(reason);
            }
        };
        return ModalService;
    }());
    ModalService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ModalService_Factory() { return new ModalService(i0.ɵɵinject(i1$3.NgbModal)); }, token: ModalService, providedIn: "root" });
    ModalService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ModalService.ctorParameters = function () { return [
        { type: i1$3.NgbModal }
    ]; };

    var OrderOverviewComponent = /** @class */ (function () {
        function OrderOverviewComponent(translation) {
            this.translation = translation;
        }
        Object.defineProperty(OrderOverviewComponent.prototype, "setOrder", {
            set: function (order) {
                this.order = order;
            },
            enumerable: false,
            configurable: true
        });
        OrderOverviewComponent.prototype.getReplenishmentCodeCardContent = function (orderCode) {
            return this.translation
                .translate('checkoutOrderConfirmation.replenishmentNumber')
                .pipe(operators.filter(function () { return Boolean(orderCode); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                text: [orderCode],
            }); }));
        };
        OrderOverviewComponent.prototype.getReplenishmentActiveCardContent = function (active) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutOrderConfirmation.status'),
                this.translation.translate('checkoutOrderConfirmation.active'),
                this.translation.translate('checkoutOrderConfirmation.cancelled'),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 3), textTitle = _d[0], textActive = _d[1], textCancelled = _d[2];
                return ({
                    title: textTitle,
                    text: [active ? textActive : textCancelled],
                });
            }));
        };
        OrderOverviewComponent.prototype.getReplenishmentStartOnCardContent = function (isoDate) {
            var _this = this;
            return this.translation.translate('checkoutReview.startOn').pipe(operators.filter(function () { return Boolean(isoDate); }), operators.map(function (textTitle) {
                var date = _this.getDate(new Date(isoDate));
                return {
                    title: textTitle,
                    text: [date],
                };
            }));
        };
        OrderOverviewComponent.prototype.getReplenishmentFrequencyCardContent = function (frequency) {
            return this.translation
                .translate('checkoutOrderConfirmation.frequency')
                .pipe(operators.filter(function () { return Boolean(frequency); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                text: [frequency],
            }); }));
        };
        OrderOverviewComponent.prototype.getReplenishmentNextDateCardContent = function (isoDate) {
            var _this = this;
            return this.translation
                .translate('checkoutOrderConfirmation.nextOrderDate')
                .pipe(operators.filter(function () { return Boolean(isoDate); }), operators.map(function (textTitle) {
                var date = _this.getDate(new Date(isoDate));
                return {
                    title: textTitle,
                    text: [date],
                };
            }));
        };
        OrderOverviewComponent.prototype.getOrderCodeCardContent = function (orderCode) {
            return this.translation
                .translate('checkoutOrderConfirmation.orderNumber')
                .pipe(operators.filter(function () { return Boolean(orderCode); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                text: [orderCode],
            }); }));
        };
        OrderOverviewComponent.prototype.getOrderCurrentDateCardContent = function (isoDate) {
            var _this = this;
            return this.translation
                .translate('checkoutOrderConfirmation.placedOn')
                .pipe(operators.map(function (textTitle) {
                var date;
                if (Boolean(isoDate)) {
                    date = _this.getDate(new Date(isoDate));
                }
                else {
                    date = _this.getDate(new Date());
                }
                return {
                    title: textTitle,
                    text: [date],
                };
            }));
        };
        OrderOverviewComponent.prototype.getOrderStatusCardContent = function (status) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutOrderConfirmation.status'),
                this.translation.translate('orderDetails.statusDisplay', {
                    context: status,
                }),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 2), textTitle = _d[0], textStatus = _d[1];
                return ({
                    title: textTitle,
                    text: [textStatus],
                });
            }));
        };
        OrderOverviewComponent.prototype.getPurchaseOrderNumber = function (poNumber) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutReview.poNumber'),
                this.translation.translate('checkoutPO.noPoNumber'),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 2), textTitle = _d[0], noneTextTitle = _d[1];
                return ({
                    title: textTitle,
                    text: [poNumber ? poNumber : noneTextTitle],
                });
            }));
        };
        OrderOverviewComponent.prototype.getMethodOfPaymentCardContent = function (hasPaymentInfo) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutProgress.methodOfPayment'),
                this.translation.translate('paymentTypes.paymentType_ACCOUNT'),
                this.translation.translate('paymentTypes.paymentType_CARD'),
            ]).pipe(operators.map(function (_c) {
                var _d = __read(_c, 3), textTitle = _d[0], textAccount = _d[1], textCard = _d[2];
                return ({
                    title: textTitle,
                    text: [Boolean(hasPaymentInfo) ? textCard : textAccount],
                });
            }));
        };
        OrderOverviewComponent.prototype.getCostCenterCardContent = function (costCenter) {
            return this.translation.translate('checkoutPO.costCenter').pipe(operators.filter(function () { return Boolean(costCenter); }), operators.map(function (textTitle) {
                var _a;
                return ({
                    title: textTitle,
                    textBold: costCenter === null || costCenter === void 0 ? void 0 : costCenter.name,
                    text: ['(' + ((_a = costCenter === null || costCenter === void 0 ? void 0 : costCenter.unit) === null || _a === void 0 ? void 0 : _a.name) + ')'],
                });
            }));
        };
        OrderOverviewComponent.prototype.getAddressCardContent = function (deliveryAddress) {
            return this.translation.translate('addressCard.shipTo').pipe(operators.filter(function () { return Boolean(deliveryAddress); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                textBold: deliveryAddress.firstName + " " + deliveryAddress.lastName,
                text: [deliveryAddress.formattedAddress, deliveryAddress.country.name],
            }); }));
        };
        OrderOverviewComponent.prototype.getDeliveryModeCardContent = function (deliveryMode) {
            return this.translation.translate('checkoutShipping.shippingMethod').pipe(operators.filter(function () { return Boolean(deliveryMode); }), operators.map(function (textTitle) {
                var _a, _b;
                return ({
                    title: textTitle,
                    textBold: deliveryMode.name,
                    text: [
                        deliveryMode.description,
                        ((_a = deliveryMode.deliveryCost) === null || _a === void 0 ? void 0 : _a.formattedValue) ? (_b = deliveryMode.deliveryCost) === null || _b === void 0 ? void 0 : _b.formattedValue : '',
                    ],
                });
            }));
        };
        OrderOverviewComponent.prototype.getPaymentInfoCardContent = function (payment) {
            return rxjs.combineLatest([
                this.translation.translate('paymentForm.payment'),
                this.translation.translate('paymentCard.expires', {
                    month: Boolean(payment) ? payment.expiryMonth : '',
                    year: Boolean(payment) ? payment.expiryYear : '',
                }),
            ]).pipe(operators.filter(function () { return Boolean(payment); }), operators.map(function (_c) {
                var _d = __read(_c, 2), textTitle = _d[0], textExpires = _d[1];
                return ({
                    title: textTitle,
                    textBold: payment.accountHolderName,
                    text: [payment.cardNumber, textExpires],
                });
            }));
        };
        OrderOverviewComponent.prototype.getBillingAddressCardContent = function (billingAddress) {
            return this.translation.translate('paymentForm.billingAddress').pipe(operators.filter(function () { return Boolean(billingAddress); }), operators.map(function (textTitle) { return ({
                title: textTitle,
                textBold: billingAddress.firstName + " " + billingAddress.lastName,
                text: [billingAddress.formattedAddress, billingAddress.country.name],
            }); }));
        };
        OrderOverviewComponent.prototype.getDate = function (givenDate) {
            var date = givenDate.toDateString().split(' ');
            var month = date[1];
            var day = date[2];
            var year = date[3];
            return month + ' ' + day + ' ' + year;
        };
        return OrderOverviewComponent;
    }());
    OrderOverviewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-overview',
                    template: "<div class=\"cx-order-summary\">\n  <div class=\"container\">\n    <ng-container *ngIf=\"order.replenishmentOrderCode; else otherOrder\">\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"\n            getReplenishmentCodeCardContent(order?.replenishmentOrderCode)\n              | async\n          \"\n        ></cx-card>\n\n        <ng-container *ngIf=\"order?.created\">\n          <cx-card\n            [content]=\"getOrderCurrentDateCardContent() | async\"\n          ></cx-card>\n        </ng-container>\n\n        <cx-card\n          [content]=\"getReplenishmentActiveCardContent(order?.active) | async\"\n        ></cx-card>\n      </div>\n\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"\n            getReplenishmentStartOnCardContent(order?.firstDate) | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getReplenishmentFrequencyCardContent(\n              order?.trigger?.displayTimeTable\n            ) | async\n          \"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getReplenishmentNextDateCardContent(order?.trigger?.activationTime)\n              | async\n          \"\n        ></cx-card>\n      </div>\n    </ng-container>\n\n    <ng-template #otherOrder>\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getOrderCodeCardContent(order?.code) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getOrderCurrentDateCardContent(order?.created) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getOrderStatusCardContent(order.statusDisplay) | async\"\n        ></cx-card>\n      </div>\n    </ng-template>\n\n    <ng-container\n      *ngIf=\"order.purchaseOrderNumber || order.purchaseOrderNumber === ''\"\n    >\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getPurchaseOrderNumber(order?.purchaseOrderNumber) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"getMethodOfPaymentCardContent(order.paymentInfo) | async\"\n        ></cx-card>\n\n        <ng-container *ngIf=\"order.costCenter\">\n          <cx-card\n            [content]=\"getCostCenterCardContent(order?.costCenter) | async\"\n          ></cx-card>\n        </ng-container>\n      </div>\n    </ng-container>\n\n    <div class=\"cx-summary-card\">\n      <ng-container *ngIf=\"order.deliveryAddress\">\n        <cx-card\n          [content]=\"getAddressCardContent(order?.deliveryAddress) | async\"\n        ></cx-card>\n      </ng-container>\n\n      <ng-container *ngIf=\"order.deliveryMode\">\n        <cx-card\n          [content]=\"getDeliveryModeCardContent(order?.deliveryMode) | async\"\n        ></cx-card>\n      </ng-container>\n    </div>\n\n    <ng-container *ngIf=\"order.paymentInfo\">\n      <div class=\"cx-summary-card\">\n        <cx-card\n          [content]=\"getPaymentInfoCardContent(order?.paymentInfo) | async\"\n        ></cx-card>\n\n        <cx-card\n          [content]=\"\n            getBillingAddressCardContent(order?.paymentInfo?.billingAddress)\n              | async\n          \"\n        ></cx-card>\n      </div>\n    </ng-container>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderOverviewComponent.ctorParameters = function () { return [
        { type: i1.TranslationService }
    ]; };
    OrderOverviewComponent.propDecorators = {
        setOrder: [{ type: i0.Input, args: ['order',] }]
    };

    var OrderOverviewModule = /** @class */ (function () {
        function OrderOverviewModule() {
        }
        return OrderOverviewModule;
    }());
    OrderOverviewModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule, CardModule],
                    declarations: [OrderOverviewComponent],
                    exports: [OrderOverviewComponent],
                },] }
    ];

    var ReplenishmentOrderCancellationDialogComponent = /** @class */ (function () {
        function ReplenishmentOrderCancellationDialogComponent(userReplenishmentOrderService, globalMessageService, launchDialogService, el) {
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.globalMessageService = globalMessageService;
            this.launchDialogService = launchDialogService;
            this.el = el;
            this.subscription = new rxjs.Subscription();
            this.focusConfig = {
                trap: true,
                block: true,
                autofocus: 'button',
                focusOnEscape: true,
            };
        }
        ReplenishmentOrderCancellationDialogComponent.prototype.handleClick = function (event) {
            // Close on click outside the dialog window
            if (event.target.tagName === this.el.nativeElement.tagName) {
                this.close('Cross click');
            }
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(rxjs.combineLatest([
                this.userReplenishmentOrderService
                    .getReplenishmentOrderDetails()
                    .pipe(operators.startWith(null)),
                this.launchDialogService.data$,
            ]).subscribe(function (_a) {
                var _b = __read(_a, 2), replenishmentOrder = _b[0], code = _b[1];
                _this.replenishmentOrderCode =
                    code || replenishmentOrder.replenishmentOrderCode;
            }));
            this.subscription.add(this.userReplenishmentOrderService
                .getCancelReplenishmentOrderSuccess()
                .subscribe(function (value) { return _this.onSuccess(value); }));
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.onSuccess = function (value) {
            if (value) {
                this.launchDialogService.closeDialog('Successffully cancelled replenishment');
                this.globalMessageService.add({
                    key: 'orderDetails.cancelReplenishment.cancelSuccess',
                    params: {
                        replenishmentOrderCode: this.replenishmentOrderCode,
                    },
                }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
            this.userReplenishmentOrderService.clearCancelReplenishmentOrderProcessState();
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.close = function (reason) {
            this.launchDialogService.closeDialog(reason);
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.cancelReplenishment = function () {
            this.userReplenishmentOrderService.cancelReplenishmentOrder(this.replenishmentOrderCode);
        };
        ReplenishmentOrderCancellationDialogComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return ReplenishmentOrderCancellationDialogComponent;
    }());
    ReplenishmentOrderCancellationDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-replenishment-order-cancellation-dialog',
                    template: "<div\n  [cxFocus]=\"focusConfig\"\n  (esc)=\"close('Escape clicked')\"\n  class=\"cx-cancel-replenishment-dialog-foreground\"\n>\n  <div class=\"cx-cancel-replenishment-dialog-content\">\n    <div class=\"cx-cancel-replenishment-dialog-header\">\n      <h3>\n        {{ 'orderDetails.cancelReplenishment.title' | cxTranslate }}\n      </h3>\n    </div>\n    <div class=\"cx-cancel-replenishment-dialog-description\">\n      {{ 'orderDetails.cancelReplenishment.description' | cxTranslate }}\n    </div>\n\n    <div class=\"cx-cancel-replenishment-dialog-body\">\n      <div class=\"cx-cancel-replenishment-btns row\">\n        <div class=\"col-md-6\">\n          <button\n            class=\"btn btn-block btn-action\"\n            (click)=\"close('Close Replenishment Dialog')\"\n          >\n            {{ 'orderDetails.cancelReplenishment.reject' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-md-6\">\n          <button\n            class=\"btn btn-block btn-primary\"\n            (click)=\"cancelReplenishment()\"\n          >\n            {{ 'orderDetails.cancelReplenishment.accept' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    ReplenishmentOrderCancellationDialogComponent.ctorParameters = function () { return [
        { type: i1.UserReplenishmentOrderService },
        { type: i1.GlobalMessageService },
        { type: LaunchDialogService },
        { type: i0.ElementRef }
    ]; };
    ReplenishmentOrderCancellationDialogComponent.propDecorators = {
        handleClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
    };

    var ReplenishmentOrderCancellationDialogModule = /** @class */ (function () {
        function ReplenishmentOrderCancellationDialogModule() {
        }
        return ReplenishmentOrderCancellationDialogModule;
    }());
    ReplenishmentOrderCancellationDialogModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule, KeyboardFocusModule],
                    declarations: [ReplenishmentOrderCancellationDialogComponent],
                    entryComponents: [ReplenishmentOrderCancellationDialogComponent],
                    exports: [ReplenishmentOrderCancellationDialogComponent],
                },] }
    ];

    /**
     * Guard that can be used in split-view based child routes. This guard
     * delays the guard to be removed with 300ms, so that any css transition can be
     * finished before the DOM is destroyed.
     */
    var SplitViewDeactivateGuard = /** @class */ (function () {
        function SplitViewDeactivateGuard() {
        }
        SplitViewDeactivateGuard.prototype.canDeactivate = function () {
            // TODO: this might cause an issue with e2e
            return rxjs.timer(300).pipe(operators.map(function () { return true; }));
        };
        return SplitViewDeactivateGuard;
    }());
    SplitViewDeactivateGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function SplitViewDeactivateGuard_Factory() { return new SplitViewDeactivateGuard(); }, token: SplitViewDeactivateGuard, providedIn: "root" });
    SplitViewDeactivateGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Supposed to be injected in the split view component, so that the split view state
     * is maintained for a single split view.
     */
    var SplitViewService = /** @class */ (function () {
        function SplitViewService() {
            /**
             * Newly added views are hidden by default, unless it is the first view of the split view.
             * The default hide mode can be overridden.
             */
            this.defaultHideMode = true;
            this.splitViewCount = 1;
            this._views$ = new rxjs.BehaviorSubject([]);
        }
        /**
         * Adds a view to the list of views. The view is initialized with the `SplitViewState`
         * state. If no state is provided, the state is created with the hidden property. The hidden
         * property is provided by the `defaultHideMode`, unless it's the first view (position: 0).
         */
        SplitViewService.prototype.add = function (position, initialState) {
            var state = Object.assign({ hidden: position === 0 ? false : this.defaultHideMode }, initialState);
            if (!this.views[position]) {
                this.views[position] = state;
                this.updateState(position, state.hidden);
                this._views$.next(this.views);
            }
        };
        /**
         * The split view is based on a number of views that can be used next to each other.
         * When the number changes (i.e. if the screen goes from wide to small), the visibility state
         * of the views should be updated.
         */
        SplitViewService.prototype.updateSplitView = function (splitViewCount) {
            if (splitViewCount !== this.splitViewCount) {
                this.splitViewCount = splitViewCount;
                this.updateState();
            }
        };
        /**
         * Returns an observable with the active view number. The active view number
         * represents the last visible view.
         */
        SplitViewService.prototype.getActiveView = function () {
            var _this = this;
            return this._views$.pipe(operators.map(function (views) { return _this.getActive(views); }), operators.distinctUntilChanged());
        };
        /**
         * Returns an observable with the SplitViewState for the given view position.
         */
        SplitViewService.prototype.getViewState = function (position) {
            return this._views$.pipe(operators.map(function (views) { return views[position]; }), 
            // we must filter here, since outlet driven views will destroyed the view
            operators.filter(function (view) { return Boolean(view); }));
        };
        /**
         * Removes a view from the list of views.
         *
         * Removing a view is different from hiding a view. Removing a view is typically done
         * when a component is destroyed.
         *
         * When the view is removed, the SplitViewState is updated to reflect that new organization
         * of views.
         */
        SplitViewService.prototype.remove = function (position) {
            var activePosition = this.getActive(this.views);
            this._views$.next(this.views.splice(0, position));
            if (activePosition >= position) {
                this.updateState(position);
            }
        };
        Object.defineProperty(SplitViewService.prototype, "nextPosition", {
            /**
             * Returns the next view position. This is useful for views that do not want to be bothered
             * with controlling view numbers.
             */
            get: function () {
                return this.views.length || 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Toggles the visibility of the views based on the given view position. If the view
         * is already visible, we close the view and active the former view. Unless the hide flag
         * is used, to force the view.
         *
         * The view state of other views in the split view are updated as well.
         *
         * @param position The zero-based position number of the view.
         * @param forceHide The (optional) hide state for the view position.
         */
        SplitViewService.prototype.toggle = function (position, forceHide) {
            // add the view if it hasn't been added before.
            if (!this.views[position]) {
                this.add(position, { hidden: forceHide !== null && forceHide !== void 0 ? forceHide : false });
            }
            // If the position is already visible, we move to a previous position. Only if the hide
            // state is forced, we keep the current position.
            if (this.views[position] &&
                forceHide === undefined &&
                !this.views[position].hidden) {
                position--;
            }
            this.updateState(position, forceHide === true);
        };
        /**
         * Updates the hidden state of all the views.
         */
        SplitViewService.prototype.updateState = function (position, hide) {
            var _this = this;
            var views = __spread(this.views);
            if (hide !== undefined && views[position]) {
                views[position].hidden = hide;
            }
            var lastVisible = views.length - __spread(views).reverse().findIndex(function (view) { return !view.hidden; }) - 1;
            if (lastVisible === views.length) {
                if (position) {
                    // When there's only 1 view (mobile), we might not find any active
                    // if the user navigates back.
                    lastVisible = position - 1;
                }
                else {
                    lastVisible = views.length - 1;
                }
            }
            views.forEach(function (view, pos) {
                if (view && pos !== position) {
                    // hide other views that are outside the split view
                    view.hidden =
                        pos > lastVisible || pos < lastVisible - (_this.splitViewCount - 1);
                }
            });
            this._views$.next(views);
        };
        /**
         * Returns the active view count for the list of views.
         */
        SplitViewService.prototype.getActive = function (views) {
            // we reverse the list to find the last visible view
            var l = __spread(views).reverse()
                .findIndex(function (view) { return !view.hidden; });
            var last = l === -1 ? 0 : views.length - l - 1;
            return last;
        };
        Object.defineProperty(SplitViewService.prototype, "views", {
            /**
             * Utility method that resolves all views from the subject.
             */
            get: function () {
                return this._views$.value;
            },
            enumerable: false,
            configurable: true
        });
        return SplitViewService;
    }());
    SplitViewService.decorators = [
        { type: i0.Injectable }
    ];

    /**
     * The split-view component supports an unlimited number of nested views. The component
     * is a host to those view components and doesn't add any restrictions to it's content;
     * content is projected as-is.
     *
     * ```html
     * <cx-split-view>
     *   <cx-view></cx-view>
     *   <cx-view></cx-view>
     *   <any-wrapper>
     *     <cx-view></cx-view>
     *   </any-wrapper>
     * </cx-split-view>
     * ```
     *
     * The split view component is only concerned with tracking the underlying _visible_
     * view components, so that the `lastVisibleView` can be updated accordingly. The actual
     * visibility of views is controlled by CSS. To allow for maximum flexibility, the CSS
     * implementation is using CSS variables. The `lastVisibleView` is bind to the
     * `--cx-active-view` on the host, so that all descendants views will inherit the
     * property conveniently.
     */
    var SplitViewComponent = /** @class */ (function () {
        function SplitViewComponent(splitService, breakpointService, elementRef) {
            this.splitService = splitService;
            this.breakpointService = breakpointService;
            this.elementRef = elementRef;
            this.subscription = new rxjs.Subscription();
            /**
             * Indicates the last visible view in the range of views that is visible. This
             * is bind to a css variable `--cx-active-view` so that the experience
             * can be fully controlled by css.
             */
            this.lastVisibleView = 1;
        }
        Object.defineProperty(SplitViewComponent.prototype, "hideMode", {
            /**
             * Sets the default hide mode for views. This mode is useful in case views are dynamically being created,
             * for example when they are created by router components.
             *
             * The mode defaults to true, unless this is the first view; the first view is never hidden.
             */
            set: function (mode) {
                this.splitService.defaultHideMode = mode;
            },
            enumerable: false,
            configurable: true
        });
        SplitViewComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.splitService
                .getActiveView()
                .subscribe(function (lastVisible) { return (_this.lastVisibleView = lastVisible + 1); }));
            this.subscription.add(this.breakpointService.breakpoint$.subscribe(function () {
                _this.splitService.updateSplitView(_this.splitViewCount);
            }));
        };
        Object.defineProperty(SplitViewComponent.prototype, "splitViewCount", {
            /**
             * Returns the maximum number of views per split-view. The number is based on the
             * CSS custom property `--cx-max-views`.
             */
            get: function () {
                return Number(getComputedStyle(this.elementRef.nativeElement).getPropertyValue('--cx-max-views'));
            },
            enumerable: false,
            configurable: true
        });
        SplitViewComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return SplitViewComponent;
    }());
    SplitViewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-split-view',
                    template: "<ng-content></ng-content>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    providers: [SplitViewService]
                },] }
    ];
    SplitViewComponent.ctorParameters = function () { return [
        { type: SplitViewService },
        { type: BreakpointService },
        { type: i0.ElementRef }
    ]; };
    SplitViewComponent.propDecorators = {
        hideMode: [{ type: i0.Input }],
        lastVisibleView: [{ type: i0.HostBinding, args: ['style.--cx-active-view',] }, { type: i0.HostBinding, args: ['attr.active-view',] }]
    };

    /**
     * The view component is part of the `SplitViewComponent`. The view
     * contains the navigable content that should be split up. It maintains
     * a view position and allows to show or hide the view.
     *
     * The ViewComponent interacts with the `SplitViewService` for handing over the
     * view state, so that the overarching `SplitViewComponent` can manage the
     * overall experience.
     */
    var ViewComponent = /** @class */ (function () {
        function ViewComponent(splitService, elementRef, cd) {
            this.splitService = splitService;
            this.elementRef = elementRef;
            this.cd = cd;
            /**
             * The disappeared flag is added to the
             */
            this.disappeared = true;
            /**
             * An update of the view visibility is emitted to the hiddenChange output.
             */
            this.hiddenChange = new i0.EventEmitter();
        }
        Object.defineProperty(ViewComponent.prototype, "hidden", {
            /**
             * The hidden input is used to set the initial visible state of the view.
             * The hidden state defaults to false.
             *
             * The hidden input supports 2-way binding, see `hiddenChange` property.
             */
            set: function (hidden) {
                this._hidden = hidden;
                this.splitService.toggle(this.viewPosition, hidden);
            },
            enumerable: false,
            configurable: true
        });
        ViewComponent.prototype.ngOnInit = function () {
            var _this = this;
            var hidden = this._hidden ? { hidden: this._hidden } : {};
            this.splitService.add(this.viewPosition, hidden);
            this.subscription = this.splitService
                .getViewState(this.viewPosition)
                // delay the disappeared state, so that the (CSS driven) animation has time to finish
                .pipe(operators.delayWhen(function (view) { return rxjs.timer(view.hidden ? _this.duration * 1.25 : 0); }))
                .subscribe(function (view) {
                _this.hiddenChange.emit(view.hidden);
                _this._hidden = view.hidden;
                _this.disappeared = view.hidden;
                _this.cd.markForCheck();
            });
        };
        /**
         * Toggles the visibility of the view.
         *
         * An optional force flag can be used to explicitly show or hide view component.
         */
        ViewComponent.prototype.toggle = function (force) {
            this.splitService.toggle(this.viewPosition, force);
        };
        Object.defineProperty(ViewComponent.prototype, "viewPosition", {
            /**
             * Returns the position for the view.
             *
             * The position is either taken from the input `position` or generated by the `SplitService`.
             */
            get: function () {
                if (!(Number(this.position) >= 0)) {
                    this.position = this.splitService.nextPosition.toString();
                }
                return Number(this.position);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ViewComponent.prototype, "duration", {
            /**
             * Returns the duration in milliseconds. The duration is based on the CSS custom property
             * `--cx-transition-duration`. Defaults to 300 milliseconds.
             */
            get: function () {
                var duration = getComputedStyle(this.elementRef.nativeElement)
                    .getPropertyValue('--cx-transition-duration')
                    .trim();
                if (duration.indexOf('ms') > -1) {
                    return Number(duration.split('ms')[0]);
                }
                else if (duration.indexOf('s') > -1) {
                    return Number(duration.split('s')[0]) * 1000;
                }
                else {
                    return 300;
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * The view is removed from the `SplitService` so that the view no longer
         * plays a role in the overall split view.
         */
        ViewComponent.prototype.ngOnDestroy = function () {
            var _a;
            this.splitService.remove(this.viewPosition);
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return ViewComponent;
    }());
    ViewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-view',
                    template: "<ng-content></ng-content>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ViewComponent.ctorParameters = function () { return [
        { type: SplitViewService },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    ViewComponent.propDecorators = {
        position: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.position',] }, { type: i0.HostBinding, args: ['style.--cx-view-position',] }],
        disappeared: [{ type: i0.HostBinding, args: ['attr.disappeared',] }],
        hidden: [{ type: i0.Input }],
        hiddenChange: [{ type: i0.Output }]
    };

    /**
     * The split-view component supports an unlimited number of nested views. Nested views are rendered
     * next to each other. The views can be rendered next to each other, but the max number of visible
     * views can be limisted as well. This is configurable in the CSS layer, so that the max number of views
     * per split-view can be different for each component.
     *
     * The basic structure of the split-view component is shown below:
     *
     *
     * ```
     * <cx-split-view>
     * </cx-split-view>
     * ```
     *
     * The UX pattern used for the split-view is driven by an initial view, which gets splitted into
     * more views as soon as the user starts interacting with the initial and subsequantial views.
     * The views can be driven by routes, which means that you can navigate through the splitted views
     * by using the browser history as well as share or bookmark splitted views.
     *
     * The UI is implemented in the style layer, with only a few generic style rules. Most of the split
     * view style is driven by CSS properties, so that alternative split-view styles can be introduced
     * per page or component.
     *
     * The max number of views per split-view on mobile is limited to 1 by default, where as on tablet
     * (and higher) it is set to 2. Spartacus has a pretty narrow layout, which is why 2 is maximum,
     * but customers could alter the layout to bring in more views in the same split-view at the time.
     *
     */
    var SplitViewModule = /** @class */ (function () {
        function SplitViewModule() {
        }
        return SplitViewModule;
    }());
    SplitViewModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [SplitViewComponent, ViewComponent],
                    imports: [i1$1.CommonModule, i4.RouterModule],
                    exports: [SplitViewComponent, ViewComponent],
                },] }
    ];

    var GlobalMessageComponent = /** @class */ (function () {
        function GlobalMessageComponent(globalMessageService) {
            this.globalMessageService = globalMessageService;
            this.iconTypes = exports.ICON_TYPE;
            this.messageType = i1.GlobalMessageType;
        }
        GlobalMessageComponent.prototype.ngOnInit = function () {
            this.messages$ = this.globalMessageService.get();
        };
        GlobalMessageComponent.prototype.clear = function (type, index) {
            this.globalMessageService.remove(type, index);
        };
        return GlobalMessageComponent;
    }());
    GlobalMessageComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-global-message',
                    template: "<div *ngIf=\"messages$ | async as messages\">\n  <div\n    class=\"alert alert-success\"\n    *ngFor=\"\n      let confMsg of messages[messageType.MSG_TYPE_CONFIRMATION];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.SUCCESS\"></cx-icon>\n    </span>\n    <span>{{ confMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_CONFIRMATION, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-info\"\n    *ngFor=\"let infoMsg of messages[messageType.MSG_TYPE_INFO]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_INFO, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-warning\"\n    *ngFor=\"\n      let infoMsg of messages[messageType.MSG_TYPE_WARNING];\n      let i = index\n    \"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.WARNING\"></cx-icon>\n    </span>\n    <span>{{ infoMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_WARNING, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n  <div\n    class=\"alert alert-danger\"\n    *ngFor=\"let errorMsg of messages[messageType.MSG_TYPE_ERROR]; let i = index\"\n  >\n    <span class=\"alert-icon\">\n      <cx-icon [type]=\"iconTypes.ERROR\"></cx-icon>\n    </span>\n    <span>{{ errorMsg | cxTranslate }}</span>\n    <button\n      class=\"close\"\n      type=\"button\"\n      (click)=\"clear(messageType.MSG_TYPE_ERROR, i)\"\n    >\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </div>\n</div>\n"
                },] }
    ];
    GlobalMessageComponent.ctorParameters = function () { return [
        { type: i1.GlobalMessageService }
    ]; };

    var GlobalMessageComponentModule = /** @class */ (function () {
        function GlobalMessageComponentModule() {
        }
        return GlobalMessageComponentModule;
    }());
    GlobalMessageComponentModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, http.HttpClientModule, IconModule, i1.I18nModule],
                    declarations: [GlobalMessageComponent],
                    exports: [GlobalMessageComponent],
                },] }
    ];

    /**
     * Configuration options for the Qualtrics integration, which allows you to
     * specify the qualtrics project and deployment script.
     */
    var QualtricsConfig = /** @class */ (function () {
        function QualtricsConfig() {
        }
        return QualtricsConfig;
    }());
    QualtricsConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function QualtricsConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: QualtricsConfig, providedIn: "root" });
    QualtricsConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    var QUALTRICS_EVENT_NAME = 'qsi_js_loaded';
    /**
     * Service to integration Qualtrics.
     *
     * The integration observes the Qualtrics API, and when available, it runs the QSI API
     * to let Qualtrics evaluate the application.
     *
     * The service supports an additional _hook_ (`isDataLoaded()`) that can be used to load application
     * data before pulling the QSI API. This is beneficial in a single page application when additional
     * data is required before the Qualtrics _creatives_ run.
     *
     * This service also supports the creation of the Qualtrics deployment script. This is optional, as
     * the script can be added in alternatives ways.
     */
    var QualtricsLoaderService = /** @class */ (function () {
        function QualtricsLoaderService(winRef, rendererFactory) {
            var _this = this;
            var _a;
            this.winRef = winRef;
            this.rendererFactory = rendererFactory;
            /**
             * QSI load event that happens when the QSI JS file is loaded.
             */
            this.qsiLoaded$ = ((_a = this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow) ? rxjs.fromEvent(this.winRef.nativeWindow, QUALTRICS_EVENT_NAME)
                : rxjs.of();
            /**
             * Emits the Qualtrics Site Intercept (QSI) JavaScript API whenever available.
             *
             * The API is emitted when the JavaScript resource holding this API is fully loaded.
             * The API is also stored locally in the service, in case it's required later on.
             */
            this.qsi$ = this.qsiLoaded$.pipe(operators.switchMap(function () { return _this.isDataLoaded(); }), operators.map(function () { var _a; return (_a = _this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow['QSI']; }), operators.filter(function (api) { return Boolean(api); }), operators.tap(function (qsi) { return (_this.qsiApi = qsi); }));
            this.initialize();
        }
        /**
         * Starts observing the Qualtrics integration. The integration is based on a
         * Qualtrics specific event (`qsi_js_loaded`). As soon as this events happens,
         * we run the API.
         */
        QualtricsLoaderService.prototype.initialize = function () {
            var _this = this;
            this.qsi$.subscribe(function () { return _this.run(); });
        };
        /**
         * Evaluates the Qualtrics project code for the application.
         *
         * In order to reload the evaluation in Qualtrics, the API requires to unload the API before
         * running it again. We don't do this by default, but offer a flag to conditionally unload the API.
         */
        QualtricsLoaderService.prototype.run = function (reload) {
            if (reload === void 0) { reload = false; }
            var _a;
            if (!((_a = this.qsiApi) === null || _a === void 0 ? void 0 : _a.API)) {
                if (i0.isDevMode()) {
                    console.log('The QSI api is not available');
                }
                return;
            }
            if (reload) {
                // Removes any currently displaying creatives
                this.qsiApi.API.unload();
            }
            // Starts the intercept code evaluation right after loading the Site Intercept
            // code for any defined intercepts or creatives
            this.qsiApi.API.load().done(this.qsiApi.API.run());
        };
        /**
         * Adds the deployment script to the DOM.
         *
         * The script will not be added twice if it was loaded before. In that case, we use
         * the Qualtrics API directly to _unload_ and _run_ the project.
         */
        QualtricsLoaderService.prototype.addScript = function (scriptSource) {
            if (this.hasScript(scriptSource)) {
                this.run(true);
            }
            else {
                var script = this.renderer.createElement('script');
                script.type = 'text/javascript';
                script.defer = true;
                script.src = scriptSource;
                this.renderer.appendChild(this.winRef.document.body, script);
            }
        };
        /**
         * This logic exist in order to let the client(s) add their own logic to wait for any kind of page data.
         * You can observe any data in this method.
         *
         * Defaults to true.
         */
        QualtricsLoaderService.prototype.isDataLoaded = function () {
            return rxjs.of(true);
        };
        /**
         * Indicates if the script is already added to the DOM.
         */
        QualtricsLoaderService.prototype.hasScript = function (source) {
            return !!this.winRef.document.querySelector("script[src=\"" + source + "\"]");
        };
        Object.defineProperty(QualtricsLoaderService.prototype, "renderer", {
            get: function () {
                return this.rendererFactory.createRenderer(null, null);
            },
            enumerable: false,
            configurable: true
        });
        return QualtricsLoaderService;
    }());
    QualtricsLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function QualtricsLoaderService_Factory() { return new QualtricsLoaderService(i0.ɵɵinject(i1.WindowRef), i0.ɵɵinject(i0.RendererFactory2)); }, token: QualtricsLoaderService, providedIn: "root" });
    QualtricsLoaderService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    QualtricsLoaderService.ctorParameters = function () { return [
        { type: i1.WindowRef },
        { type: i0.RendererFactory2 }
    ]; };

    /**
     * Adds the Qualtrics deployment script whenever the component is loaded. The
     * deployment script is loaded from the global configuration (`qualtrics.scriptSource`).
     */
    var QualtricsComponent = /** @class */ (function () {
        function QualtricsComponent(qualtricsLoader, config) {
            var _a;
            this.qualtricsLoader = qualtricsLoader;
            this.config = config;
            if ((_a = this.config.qualtrics) === null || _a === void 0 ? void 0 : _a.scriptSource) {
                this.qualtricsLoader.addScript(this.config.qualtrics.scriptSource);
            }
            else if (i0.isDevMode()) {
                console.warn("We're unable to add the Qualtrics deployment code as there is no script source defined in config.qualtrics.scriptSource.");
            }
        }
        return QualtricsComponent;
    }());
    QualtricsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-qualtrics',
                    template: ""
                },] }
    ];
    QualtricsComponent.ctorParameters = function () { return [
        { type: QualtricsLoaderService },
        { type: QualtricsConfig }
    ]; };

    var defaultQualtricsConfig = {
        qualtrics: {},
    };

    var QualtricsModule = /** @class */ (function () {
        function QualtricsModule() {
        }
        return QualtricsModule;
    }());
    QualtricsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, http.HttpClientModule],
                    declarations: [QualtricsComponent],
                    entryComponents: [QualtricsComponent],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                QualtricsComponent: {
                                    component: QualtricsComponent,
                                },
                            },
                        }),
                        i1.provideDefaultConfig(defaultQualtricsConfig),
                    ],
                },] }
    ];

    var LanguageCurrencyComponent = /** @class */ (function () {
        function LanguageCurrencyComponent() {
        }
        return LanguageCurrencyComponent;
    }());
    LanguageCurrencyComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-language-currency-selector',
                    template: "\n    <cx-site-context-selector context=\"language\"></cx-site-context-selector>\n    <cx-site-context-selector context=\"currency\"></cx-site-context-selector>\n  ",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];

    var CmsComponentData = /** @class */ (function () {
        function CmsComponentData() {
        }
        return CmsComponentData;
    }());

    var _a;
    var LABELS = (_a = {},
        _a[i1.LANGUAGE_CONTEXT_ID] = 'Language',
        _a[i1.CURRENCY_CONTEXT_ID] = 'Currency',
        _a);
    var SiteContextComponentService = /** @class */ (function () {
        function SiteContextComponentService(componentData, contextServiceMap, injector) {
            this.componentData = componentData;
            this.contextServiceMap = contextServiceMap;
            this.injector = injector;
        }
        SiteContextComponentService.prototype.getItems = function (context) {
            var _this = this;
            return this.getService(context).pipe(operators.switchMap(function (service) { return service.getAll(); }), operators.switchMap(function (items) { return _this.getContext(context).pipe(operators.switchMap(function (ctx) {
                var e_1, _a;
                var itemsCopy = [];
                try {
                    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                        var item = items_1_1.value;
                        itemsCopy.push(Object.assign(Object.assign({}, item), { label: _this.getOptionLabel(item, ctx) }));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return rxjs.of(itemsCopy);
            })); }));
        };
        SiteContextComponentService.prototype.getActiveItem = function (context) {
            return this.getService(context).pipe(operators.switchMap(function (service) { return service.getActive(); }));
        };
        SiteContextComponentService.prototype.getLabel = function (context) {
            return this.getContext(context).pipe(operators.map(function (ctx) {
                return LABELS[ctx];
            }));
        };
        SiteContextComponentService.prototype.setActive = function (value, context) {
            this.getService(context)
                .pipe(operators.take(1))
                .subscribe(function (service) {
                service.setActive(value);
            });
        };
        SiteContextComponentService.prototype.getService = function (context) {
            var _this = this;
            return this.getContext(context).pipe(operators.map(function (ctx) { return (ctx ? _this.getInjectedService(ctx) : undefined); }), operators.filter(function (s) { return !!s; }));
        };
        SiteContextComponentService.prototype.getContext = function (context) {
            if (context) {
                return rxjs.of(context);
            }
            else if (this.componentData) {
                return this.componentData.data$.pipe(operators.map(function (data) { return data === null || data === void 0 ? void 0 : data.context; }), operators.map(function (ctx) {
                    switch (ctx) {
                        case 'LANGUAGE':
                            return i1.LANGUAGE_CONTEXT_ID;
                        case 'CURRENCY':
                            return i1.CURRENCY_CONTEXT_ID;
                        default:
                            return ctx;
                    }
                }));
            }
        };
        SiteContextComponentService.prototype.getInjectedService = function (context) {
            return this.injector.get(this.contextServiceMap[context], null);
        };
        SiteContextComponentService.prototype.getOptionLabel = function (item, context) {
            switch (context) {
                case i1.LANGUAGE_CONTEXT_ID:
                    return item.nativeName;
                case i1.CURRENCY_CONTEXT_ID:
                    return item.symbol + ' ' + item.isocode;
                default:
                    return item.isocode;
            }
        };
        return SiteContextComponentService;
    }());
    SiteContextComponentService.decorators = [
        { type: i0.Injectable }
    ];
    SiteContextComponentService.ctorParameters = function () { return [
        { type: CmsComponentData, decorators: [{ type: i0.Optional }] },
        { type: i1.ContextServiceMap },
        { type: i0.Injector }
    ]; };

    var SiteContextSelectorComponent = /** @class */ (function () {
        function SiteContextSelectorComponent(componentService) {
            this.componentService = componentService;
            this.iconTypes = exports.ICON_TYPE;
        }
        Object.defineProperty(SiteContextSelectorComponent.prototype, "items$", {
            get: function () {
                return this.componentService.getItems(this.context);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SiteContextSelectorComponent.prototype, "activeItem$", {
            get: function () {
                return this.componentService.getActiveItem(this.context);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SiteContextSelectorComponent.prototype, "active", {
            set: function (value) {
                this.componentService.setActive(value, this.context);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SiteContextSelectorComponent.prototype, "label$", {
            get: function () {
                return this.componentService.getLabel(this.context);
            },
            enumerable: false,
            configurable: true
        });
        return SiteContextSelectorComponent;
    }());
    SiteContextSelectorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-site-context-selector',
                    template: "<label *ngIf=\"(items$ | async)?.length > 1 && (items$ | async) as items\">\n  <span>{{ label$ | async }}</span>\n  <select (change)=\"active = $event.target.value\">\n    <option\n      *ngFor=\"let item of items\"\n      value=\"{{ item.isocode }}\"\n      [selected]=\"(activeItem$ | async) === item.isocode\"\n    >\n      {{ item.label }}\n    </option></select\n  ><cx-icon [type]=\"iconTypes.CARET_DOWN\" class=\"small\"></cx-icon>\n</label>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    SiteContextSelectorComponent.ctorParameters = function () { return [
        { type: SiteContextComponentService }
    ]; };
    SiteContextSelectorComponent.propDecorators = {
        context: [{ type: i0.Input }]
    };

    var SiteContextSelectorModule = /** @class */ (function () {
        function SiteContextSelectorModule() {
        }
        return SiteContextSelectorModule;
    }());
    SiteContextSelectorModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.SiteContextModule, IconModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CMSSiteContextComponent: {
                                    component: SiteContextSelectorComponent,
                                    providers: [
                                        {
                                            provide: SiteContextComponentService,
                                            useClass: SiteContextComponentService,
                                            deps: [CmsComponentData, i1.ContextServiceMap, i0.Injector],
                                        },
                                    ],
                                },
                                LanguageCurrencyComponent: {
                                    component: LanguageCurrencyComponent,
                                },
                            },
                        }),
                        SiteContextComponentService,
                    ],
                    declarations: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                    entryComponents: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                    exports: [SiteContextSelectorComponent, LanguageCurrencyComponent],
                },] }
    ];

    (function (SiteContextType) {
        SiteContextType["LANGUAGE"] = "LANGUAGE";
        SiteContextType["CURRENCY"] = "CURRENCY";
    })(exports.SiteContextType || (exports.SiteContextType = {}));

    var StarRatingComponent = /** @class */ (function () {
        function StarRatingComponent(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            /**
             * The rating component can be used in disabled mode,
             * so that the interation is not provided.
             */
            this.disabled = false;
            /**
             * Emits the given rating when the user clicks on a star.
             */
            // tslint:disable-next-line:no-output-native
            this.change = new i0.EventEmitter();
            this.initialRate = 0;
            this.iconTypes = exports.ICON_TYPE;
        }
        StarRatingComponent.prototype.ngOnInit = function () {
            this.setRate(this.rating, true);
        };
        StarRatingComponent.prototype.setRate = function (value, force) {
            if (!this.disabled || force) {
                this.renderer.setAttribute(this.el.nativeElement, 'style', "--star-fill:" + (value || this.initialRate) + ";");
            }
        };
        StarRatingComponent.prototype.saveRate = function (rating) {
            if (this.disabled) {
                return;
            }
            this.initialRate = rating;
            this.setRate(rating);
            this.change.emit(rating);
        };
        StarRatingComponent.prototype.setRateOnEvent = function (event, rating) {
            if (event.code === 'Space') {
                event.preventDefault();
                this.setRate(rating);
            }
        };
        return StarRatingComponent;
    }());
    StarRatingComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-star-rating',
                    template: "<cx-icon\n  *ngFor=\"let i of [1, 2, 3, 4, 5]\"\n  [type]=\"iconTypes.STAR\"\n  class=\"star\"\n  (mouseover)=\"setRate(i)\"\n  (mouseout)=\"setRate(0)\"\n  (keydown)=\"setRateOnEvent($event, i)\"\n  (click)=\"saveRate(i)\"\n  [attr.tabindex]=\"disabled ? null : 0\"\n></cx-icon>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    StarRatingComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    StarRatingComponent.propDecorators = {
        disabled: [{ type: i0.Input }, { type: i0.HostBinding, args: ['attr.disabled',] }],
        rating: [{ type: i0.Input }],
        change: [{ type: i0.Output }]
    };

    var StarRatingModule = /** @class */ (function () {
        function StarRatingModule() {
        }
        return StarRatingModule;
    }());
    StarRatingModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, IconModule],
                    declarations: [StarRatingComponent],
                    exports: [StarRatingComponent],
                },] }
    ];

    var TableDataCellComponent = /** @class */ (function () {
        function TableDataCellComponent(outlet) {
            this.outlet = outlet;
            this.cls = true;
        }
        Object.defineProperty(TableDataCellComponent.prototype, "value", {
            get: function () {
                return this.model[this.field];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableDataCellComponent.prototype, "model", {
            get: function () {
                var _a;
                return (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableDataCellComponent.prototype, "field", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._field;
            },
            enumerable: false,
            configurable: true
        });
        return TableDataCellComponent;
    }());
    TableDataCellComponent.decorators = [
        { type: i0.Component, args: [{
                    template: "{{ value }}",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    TableDataCellComponent.ctorParameters = function () { return [
        { type: OutletContextData }
    ]; };
    TableDataCellComponent.propDecorators = {
        cls: [{ type: i0.HostBinding, args: ['class.content-wrapper',] }]
    };

    var TableHeaderCellComponent = /** @class */ (function () {
        function TableHeaderCellComponent(outlet) {
            this.outlet = outlet;
        }
        Object.defineProperty(TableHeaderCellComponent.prototype, "header", {
            /**
             * Returns the static label for the given field, if available.
             */
            get: function () {
                var _a;
                if (typeof ((_a = this.fieldOptions) === null || _a === void 0 ? void 0 : _a.label) === 'string') {
                    return this.fieldOptions.label;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "localizedHeader", {
            /**
             * Returns the localized label for the given field.
             *
             * The localized label is either driven by the configured `label.i18nKey`
             * or concatenated by the table `type` and field `key`:
             *
             * `[tableType].[fieldKey]`
             *
             * The localized header can be translated with the `cxTranslate` pipe or `TranslationService`.
             */
            get: function () {
                var _a, _b;
                return (((_b = (_a = this.fieldOptions) === null || _a === void 0 ? void 0 : _a.label) === null || _b === void 0 ? void 0 : _b.i18nKey) ||
                    this.type + "." + this.field);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "fieldOptions", {
            get: function () {
                var _a, _b, _c;
                return (_c = (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context._options) === null || _b === void 0 ? void 0 : _b.cells) === null || _c === void 0 ? void 0 : _c[this.field];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "field", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._field;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableHeaderCellComponent.prototype, "type", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.outlet) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b._type;
            },
            enumerable: false,
            configurable: true
        });
        return TableHeaderCellComponent;
    }());
    TableHeaderCellComponent.decorators = [
        { type: i0.Component, args: [{
                    template: "{{ header || (localizedHeader | cxTranslate) }}",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    TableHeaderCellComponent.ctorParameters = function () { return [
        { type: OutletContextData }
    ]; };

    var defaultTableConfig = {
        tableOptions: {
            headerComponent: TableHeaderCellComponent,
            dataComponent: TableDataCellComponent,
        },
    };

    /**
     * The `TableConfig` provides a table configurations for specific table types. You can define
     * an all-screen table structure as well as a breakpoint specific table structure. The various
     * table structures are merged from small to large screen configurations, depending on the users
     * screen size.
     *
     * The `table.type` is used as a key to distinguish the various table configurations in the application.
     */
    var TableConfig = /** @class */ (function () {
        function TableConfig() {
        }
        return TableConfig;
    }());
    TableConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function TableConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: TableConfig, providedIn: "root" });
    TableConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    var TableDataCellModule = /** @class */ (function () {
        function TableDataCellModule() {
        }
        return TableDataCellModule;
    }());
    TableDataCellModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [TableDataCellComponent],
                },] }
    ];

    var TableHeaderCellModule = /** @class */ (function () {
        function TableHeaderCellModule() {
        }
        return TableHeaderCellModule;
    }());
    TableHeaderCellModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule],
                    declarations: [TableHeaderCellComponent],
                },] }
    ];

    /**
     * The table renderer service adds a component for each table cells (th and td)
     * based on a fine grained configuration. Each table type can configure both global
     * components for headers and cells as well as individual components for field
     * specific cells.
     *
     * The components are added to the outlet slots for the corresponding cells. The table
     * structure and data is added to the outlet context.
     */
    var TableRendererService = /** @class */ (function () {
        function TableRendererService(outletService, componentFactoryResolver, config) {
            this.outletService = outletService;
            this.componentFactoryResolver = componentFactoryResolver;
            this.config = config;
            // keep a list of outletRefs to avoid recreation
            this.outletRefs = new Map();
        }
        /**
         * Adds the configured table component for the header and data.
         */
        TableRendererService.prototype.add = function (structure) {
            var _this = this;
            var _a;
            (_a = structure === null || structure === void 0 ? void 0 : structure.cells) === null || _a === void 0 ? void 0 : _a.forEach(function (field) {
                var thRenderer = _this.getHeaderRenderer(structure, field);
                if (thRenderer) {
                    var ref = _this.getHeaderOutletRef(structure.type, field);
                    _this.render(ref, thRenderer);
                }
                var tdRenderer = _this.getDataRenderer(structure, field);
                if (tdRenderer) {
                    var ref = _this.getDataOutletRef(structure.type, field);
                    _this.render(ref, tdRenderer);
                }
            });
        };
        TableRendererService.prototype.render = function (outletRef, renderer) {
            if (this.outletRefs.has(outletRef)) {
                return;
            }
            this.outletRefs.set(outletRef, true);
            var template = this.componentFactoryResolver.resolveComponentFactory(renderer);
            this.outletService.add(outletRef, template);
        };
        /**
         * Returns the header render component for the given field.
         */
        TableRendererService.prototype.getHeaderRenderer = function (structure, field) {
            var _a, _b, _c, _d, _e;
            return (((_c = (_b = (_a = structure.options) === null || _a === void 0 ? void 0 : _a.cells) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.headerComponent) || ((_d = structure.options) === null || _d === void 0 ? void 0 : _d.headerComponent) || ((_e = this.config.tableOptions) === null || _e === void 0 ? void 0 : _e.headerComponent));
        };
        /**
         * Returns the data render component for the given field.
         */
        TableRendererService.prototype.getDataRenderer = function (structure, field) {
            var _a, _b, _c, _d, _e;
            return (((_c = (_b = (_a = structure.options) === null || _a === void 0 ? void 0 : _a.cells) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.dataComponent) || ((_d = structure.options) === null || _d === void 0 ? void 0 : _d.dataComponent) || ((_e = this.config.tableOptions) === null || _e === void 0 ? void 0 : _e.dataComponent));
        };
        /**
         * Returns the header (th) outlet reference for the given field.
         *
         * The outlet reference is generated as:
         * `table.[tableType].header.[field]`
         */
        TableRendererService.prototype.getHeaderOutletRef = function (type, field) {
            return "table." + type + ".header." + field;
        };
        /**
         * Returns the header (th) outlet context for the given field.
         */
        TableRendererService.prototype.getHeaderOutletContext = function (type, options, field) {
            return { _type: type, _options: options, _field: field };
        };
        /**
         * Returns the data (td) outlet reference for the given field.
         *
         * The field is generated as:
         * `table.[tableType].data.[tableField]`
         */
        TableRendererService.prototype.getDataOutletRef = function (type, field) {
            return "table." + type + ".data." + field;
        };
        /**
         * Returns the data (td) outlet context for the given field.
         */
        TableRendererService.prototype.getDataOutletContext = function (type, options, field, data) {
            return Object.assign(Object.assign({}, data), { _type: type, _options: options, _field: field });
        };
        return TableRendererService;
    }());
    TableRendererService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TableRendererService_Factory() { return new TableRendererService(i0.ɵɵinject(OutletService), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(TableConfig)); }, token: TableRendererService, providedIn: "root" });
    TableRendererService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    TableRendererService.ctorParameters = function () { return [
        { type: OutletService },
        { type: i0.ComponentFactoryResolver },
        { type: TableConfig }
    ]; };

    /**
     * Layout orientation for the table configuration.
     */
    (function (TableLayout) {
        /**
         * Renders the table vertically, with a heading on top of the table.
         *
         * Vertical layout is most common and the default layout.
         */
        TableLayout[TableLayout["VERTICAL"] = 1] = "VERTICAL";
        /**
         * Stacks items in a tables by generating a `tbody` for each item.
         */
        TableLayout[TableLayout["VERTICAL_STACKED"] = 2] = "VERTICAL_STACKED";
        /**
         * Horizontal oriented table layout renders the table headers in the first column of the table.
         */
        TableLayout[TableLayout["HORIZONTAL"] = 3] = "HORIZONTAL";
    })(exports.TableLayout || (exports.TableLayout = {}));

    /**
     * The table component provides a generic table DOM structure, with 3 layout types:
     * horizontal, vertical and _stacked vertical_ layout. The layout is driven by the
     * table structure.
     *
     * The implementation is fairly "dumb" and only renders string based content for TH
     * and TD elements. The actual cell rendering is delegated to a (configurable) cell
     * component. Additionally, each cell is registered as an outlet, so that customizations
     * can be done by both outlet templates and components.
     *
     * The outlet references are concatenated from the table `type` and header `key`. The
     * following snippet shows an outlet generated for a table header, for the table type
     * "cost-center" with a header key "name":
     *
     * ```
     * <th>
     *   <template cxOutlet="table.cost-center.header.name">
     *   </template>
     * </th>
     * ```
     *
     * Similarly, the data cells (`<td>`) are generated with the outlet template reference
     * `table.cost-center.data.name`.
     */
    var TableComponent = /** @class */ (function () {
        function TableComponent(rendererService) {
            this.rendererService = rendererService;
            this.launch = new i0.EventEmitter();
        }
        Object.defineProperty(TableComponent.prototype, "structure", {
            get: function () {
                return this._structure;
            },
            set: function (structure) {
                this._structure = structure;
                this.init();
            },
            enumerable: false,
            configurable: true
        });
        TableComponent.prototype.init = function () {
            this.verticalLayout = !this.layout || this.layout === exports.TableLayout.VERTICAL;
            this.verticalStackedLayout = this.layout === exports.TableLayout.VERTICAL_STACKED;
            this.horizontalLayout = this.layout === exports.TableLayout.HORIZONTAL;
            this.rendererService.add(this.structure);
            this.addTableDebugInfo();
        };
        TableComponent.prototype.launchItem = function (item) {
            this.launch.emit(item);
        };
        /**
         * Indicates whether the given item is the current item.
         *
         * The current item is driven by the `currentItem`, that holds a
         * property and value to compare.
         */
        TableComponent.prototype.isCurrentItem = function (item) {
            var _a, _b;
            if (!this.currentItem || !this.currentItem.value) {
                return false;
            }
            return ((_a = this.currentItem) === null || _a === void 0 ? void 0 : _a.value) === (item === null || item === void 0 ? void 0 : item[(_b = this.currentItem) === null || _b === void 0 ? void 0 : _b.property]);
        };
        /**
         * Returns the header (th) outlet reference for the given field.
         */
        TableComponent.prototype.getHeaderOutletRef = function (field) {
            return this.rendererService.getHeaderOutletRef(this.type, field);
        };
        /**
         * Returns the header (th) outlet context for the given field.
         */
        TableComponent.prototype.getHeaderOutletContext = function (field) {
            return this.rendererService.getHeaderOutletContext(this.type, this.options, field);
        };
        /**
         * Returns the data (td) outlet reference for the given field.
         */
        TableComponent.prototype.getDataOutletRef = function (field) {
            return this.rendererService.getDataOutletRef(this.type, field);
        };
        /**
         * Returns the data (td) outlet context for the given field.
         */
        TableComponent.prototype.getDataOutletContext = function (field, data) {
            return this.rendererService.getDataOutletContext(this.type, this.options, field, data);
        };
        TableComponent.prototype.trackData = function (_i, item) {
            return JSON.stringify(item);
        };
        /**
         * Generates the table type into the UI in devMode, so that developers
         * can easily get the notion of the table type.
         */
        TableComponent.prototype.addTableDebugInfo = function () {
            if (i0.isDevMode() && this.type) {
                this.tableType = this.type;
            }
        };
        Object.defineProperty(TableComponent.prototype, "layout", {
            /**
             * Helper method to return the deeply nested orientation configuration.
             */
            get: function () {
                var _a, _b;
                return (_b = (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.layout;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "type", {
            /**
             * Helper method to return the deeply nested type.
             */
            get: function () {
                var _a;
                return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.type;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "options", {
            get: function () {
                var _a;
                return (_a = this.structure) === null || _a === void 0 ? void 0 : _a.options;
            },
            enumerable: false,
            configurable: true
        });
        return TableComponent;
    }());
    TableComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-table',
                    template: "<table *ngIf=\"structure\">\n  <ng-container *ngIf=\"verticalStackedLayout\">\n    <tbody\n      *ngFor=\"let item of data; trackBy: trackData\"\n      (click)=\"launchItem(item)\"\n      [class.is-current]=\"isCurrentItem(item)\"\n    >\n      <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n        <th>\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n        <td>\n          <ng-template\n            [cxOutlet]=\"getDataOutletRef(cell)\"\n            [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n          >\n            {{ item[cell] }}\n          </ng-template>\n        </td>\n      </tr>\n    </tbody>\n  </ng-container>\n\n  <!-- vertical tables render the item  -->\n  <ng-container *ngIf=\"verticalLayout\">\n    <thead>\n      <tr>\n        <th scope=\"col\" *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n          <ng-template\n            [cxOutlet]=\"getHeaderOutletRef(cell)\"\n            [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n          >\n            {{ cell }}\n          </ng-template>\n        </th>\n      </tr>\n    </thead>\n\n    <tr\n      *ngFor=\"let item of data; trackBy: trackData\"\n      [class.is-current]=\"isCurrentItem(item)\"\n      (click)=\"launchItem(item)\"\n    >\n      <td *ngFor=\"let cell of structure.cells; let i = index\" [class]=\"cell\">\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n\n  <ng-container *ngIf=\"horizontalLayout\">\n    <tr *ngFor=\"let cell of structure.cells\" [class]=\"cell\">\n      <th scope=\"col\">\n        <ng-template\n          [cxOutlet]=\"getHeaderOutletRef(cell)\"\n          [cxOutletContext]=\"getHeaderOutletContext(cell)\"\n        >\n          {{ cell }}\n        </ng-template>\n      </th>\n      <td\n        *ngFor=\"let item of data; trackBy: trackData\"\n        [class.is-current]=\"isCurrentItem(item)\"\n        (click)=\"launchItem(item)\"\n      >\n        <ng-template\n          [cxOutlet]=\"getDataOutletRef(cell)\"\n          [cxOutletContext]=\"getDataOutletContext(cell, item)\"\n        >\n          {{ item[cell] }}\n        </ng-template>\n      </td>\n    </tr>\n  </ng-container>\n</table>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    TableComponent.ctorParameters = function () { return [
        { type: TableRendererService }
    ]; };
    TableComponent.propDecorators = {
        tableType: [{ type: i0.HostBinding, args: ['attr.__cx-table-type',] }],
        horizontalLayout: [{ type: i0.HostBinding, args: ['class.horizontal',] }],
        verticalLayout: [{ type: i0.HostBinding, args: ['class.vertical',] }],
        verticalStackedLayout: [{ type: i0.HostBinding, args: ['class.vertical-stacked',] }],
        structure: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        currentItem: [{ type: i0.Input }],
        launch: [{ type: i0.Output }]
    };

    /**
     * The TableModule provides a table component that is driven by (responsible) configuration.
     */
    var TableModule = /** @class */ (function () {
        function TableModule() {
        }
        return TableModule;
    }());
    TableModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        OutletModule,
                        TableHeaderCellModule,
                        TableDataCellModule,
                    ],
                    declarations: [TableComponent],
                    exports: [TableComponent],
                    providers: [i1.provideConfig(defaultTableConfig)],
                },] }
    ];

    /**
     * Responsive table service.
     *
     * The `TableService` is used to build a `TableStructure` by configuration. The configuration
     * allows for breakpoint specific configuration, so that the table can differentiate for
     * various screen sizes.
     *
     * While there are some global options, the configuration is mainly driven by the table _type_.
     *
     * If there is no table configuration for the given type found, a table header structure
     * is generated based on the actual data (if available) or randomly by generating 5 random headers.
     */
    var TableService = /** @class */ (function () {
        function TableService(breakpointService, config) {
            this.breakpointService = breakpointService;
            this.config = config;
        }
        /**
         * Builds the table structure.
         *
         * @param tableType The table type is used  to find the specific table configuration.
         * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
         * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
         */
        TableService.prototype.buildStructure = function (tableType, defaultStructure, data$) {
            if (this.hasTableConfig(tableType)) {
                return this.buildStructureFromConfig(tableType, defaultStructure);
            }
            else {
                if (data$) {
                    return this.buildStructureFromData(tableType, data$);
                }
                else {
                    return this.buildRandomStructure(tableType);
                }
            }
        };
        /**
         * Returns the table structure by configuration. The configuration can be
         * breakpoint-driven, which means that an alternative header structure can
         * be created per screen size.
         *
         * The breakpoint is resolved by teh `BreakpointService`.
         */
        TableService.prototype.buildStructureFromConfig = function (type, defaultStructure) {
            var _this = this;
            return this.breakpointService.breakpoint$.pipe(operators.map(function (breakpoint) { return (Object.assign(Object.assign({}, _this.getTableConfig(type, breakpoint, defaultStructure)), { type: type })); }));
        };
        /**
         * Finds all applicable table configuration for the given type and breakpoint.
         * The default table configuration is merged with all relevant breakpoint
         * configurations.
         *
         * This allows to have some default configurations that apply to all screens, and
         * add configuration options for some screens.
         */
        TableService.prototype.getTableConfig = function (type, breakpoint, defaultStructure) {
            var _this = this;
            var _a, _b;
            if (!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[type])) {
                return null;
            }
            var relevant = this.findRelevantBreakpoints(breakpoint);
            var closestBreakpoint = __spread(relevant).reverse()
                .find(function (br) { var _a; return !!((_a = _this.config.table[type][br]) === null || _a === void 0 ? void 0 : _a.cells); });
            var cells = ((_b = this.config.table[type][closestBreakpoint]) === null || _b === void 0 ? void 0 : _b.cells) ||
                this.config.table[type].cells || (defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.cells);
            // add all default table configurations
            var options = Object.assign(Object.assign({}, defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.options), this.config.table[type].options);
            // We merge all table options for smaller breakpoints into the global
            // options, so we inherit options.
            relevant.forEach(function (br) {
                var _a, _b, _c;
                options = Object.assign(Object.assign(Object.assign({}, options), (_a = defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure[br]) === null || _a === void 0 ? void 0 : _a.options), (_c = (_b = _this.config.table[type]) === null || _b === void 0 ? void 0 : _b[br]) === null || _c === void 0 ? void 0 : _c.options);
            });
            return { cells: cells, options: options };
        };
        /**
         * Generates the table structure by the help of the first data row.
         */
        TableService.prototype.buildStructureFromData = function (type, data$) {
            this.logWarning("No table configuration found to render table with type \"" + type + "\". The table header for \"" + type + "\" is generated by the help of the first data item");
            return data$.pipe(operators.map(function (data) {
                var cells = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map(function (key) { return key; });
                return { type: type, cells: cells };
            }));
        };
        /**
         * As a last resort, the table structure is randomly created. The random structure
         * contains 5 headers, so that some of the unknown data is visualized.
         */
        TableService.prototype.buildRandomStructure = function (type) {
            this.logWarning("No data available for \"" + type + "\", a random structure is generated (with hidden table headers).");
            return rxjs.of({
                type: type,
                cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
            });
        };
        /**
         * Finds all the breakpoints can contribute to the table configuration, from small
         * to current.
         *
         * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
         */
        TableService.prototype.findRelevantBreakpoints = function (breakpoint) {
            var current = this.breakpointService.breakpoints.indexOf(breakpoint);
            return this.breakpointService.breakpoints.slice(0, current + 1);
        };
        /**
         * Indicates if the there is a configuration for the table available.
         */
        TableService.prototype.hasTableConfig = function (tableType) {
            var _a;
            return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
        };
        /**
         * Logs a message in the console to increase developer experience.
         *
         * The message is only logged in dev mode.
         */
        TableService.prototype.logWarning = function (message) {
            if (i0.isDevMode()) {
                console.warn(message);
            }
        };
        return TableService;
    }());
    TableService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TableService_Factory() { return new TableService(i0.ɵɵinject(BreakpointService), i0.ɵɵinject(TableConfig)); }, token: TableService, providedIn: "root" });
    TableService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    TableService.ctorParameters = function () { return [
        { type: BreakpointService },
        { type: TableConfig }
    ]; };

    var ViewConfig = /** @class */ (function () {
        function ViewConfig() {
        }
        return ViewConfig;
    }());
    ViewConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function ViewConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: ViewConfig, providedIn: "root" });
    ViewConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    var ViewConfigModule = /** @class */ (function () {
        function ViewConfigModule() {
        }
        ViewConfigModule.forRoot = function () {
            return {
                ngModule: ViewConfigModule,
                providers: [
                    i1.provideDefaultConfig({
                        view: {},
                    }),
                ],
            };
        };
        return ViewConfigModule;
    }());
    ViewConfigModule.decorators = [
        { type: i0.NgModule, args: [{},] }
    ];

    var OrderDetailsService = /** @class */ (function () {
        function OrderDetailsService(userOrderService, routingService) {
            var _this = this;
            this.userOrderService = userOrderService;
            this.routingService = routingService;
            this.orderCode$ = this.routingService
                .getRouterState()
                .pipe(operators.map(function (routingData) { return routingData.state.params.orderCode; }));
            this.orderLoad$ = this.orderCode$.pipe(operators.tap(function (orderCode) {
                if (orderCode) {
                    _this.userOrderService.loadOrderDetails(orderCode);
                }
                else {
                    _this.userOrderService.clearOrderDetails();
                }
            }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        OrderDetailsService.prototype.getOrderDetails = function () {
            var _this = this;
            return this.orderLoad$.pipe(operators.switchMap(function () { return _this.userOrderService.getOrderDetails(); }));
        };
        return OrderDetailsService;
    }());
    OrderDetailsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OrderDetailsService_Factory() { return new OrderDetailsService(i0.ɵɵinject(i1.UserOrderService), i0.ɵɵinject(i1.RoutingService)); }, token: OrderDetailsService, providedIn: "root" });
    OrderDetailsService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    OrderDetailsService.ctorParameters = function () { return [
        { type: i1.UserOrderService },
        { type: i1.RoutingService }
    ]; };

    var PromotionService = /** @class */ (function () {
        function PromotionService(orderDetailsService, checkoutService, activeCartService) {
            this.orderDetailsService = orderDetailsService;
            this.checkoutService = checkoutService;
            this.activeCartService = activeCartService;
        }
        PromotionService.prototype.getOrderPromotions = function (promotionLocation) {
            switch (promotionLocation) {
                case i1.PromotionLocation.ActiveCart:
                    return this.getOrderPromotionsFromCart();
                case i1.PromotionLocation.Checkout:
                    return this.getOrderPromotionsFromCheckout();
                case i1.PromotionLocation.Order:
                    return this.getOrderPromotionsFromOrder();
                default:
                    return rxjs.of([]);
            }
        };
        PromotionService.prototype.getOrderPromotionsFromCart = function () {
            var _this = this;
            return this.activeCartService
                .getActive()
                .pipe(operators.map(function (cart) { return _this.getOrderPromotionsFromCartHelper(cart); }));
        };
        PromotionService.prototype.getOrderPromotionsFromCartHelper = function (cart) {
            var potentialPromotions = [];
            potentialPromotions.push.apply(potentialPromotions, __spread((cart.potentialOrderPromotions || [])));
            var appliedPromotions = [];
            appliedPromotions.push.apply(appliedPromotions, __spread((cart.appliedOrderPromotions || [])));
            return __spread(potentialPromotions, appliedPromotions);
        };
        PromotionService.prototype.getOrderPromotionsFromCheckout = function () {
            var _this = this;
            return this.checkoutService
                .getOrderDetails()
                .pipe(operators.map(function (order) { return _this.getOrderPromotionsFromOrderHelper(order); }));
        };
        PromotionService.prototype.getOrderPromotionsFromOrder = function () {
            var _this = this;
            return this.orderDetailsService
                .getOrderDetails()
                .pipe(operators.map(function (order) { return _this.getOrderPromotionsFromOrderHelper(order); }));
        };
        PromotionService.prototype.getOrderPromotionsFromOrderHelper = function (order) {
            var appliedOrderPromotions = [];
            appliedOrderPromotions.push.apply(appliedOrderPromotions, __spread((order.appliedOrderPromotions || [])));
            return appliedOrderPromotions;
        };
        PromotionService.prototype.getProductPromotionForEntry = function (item, promotionLocation) {
            var _this = this;
            switch (promotionLocation) {
                case i1.PromotionLocation.ActiveCart:
                    return this.activeCartService
                        .getActive()
                        .pipe(operators.map(function (cart) { return _this.getProductPromotion(item, cart.appliedProductPromotions || []); }));
                case i1.PromotionLocation.Checkout:
                    return this.checkoutService
                        .getOrderDetails()
                        .pipe(operators.map(function (order) { return _this.getProductPromotion(item, order.appliedProductPromotions || []); }));
                case i1.PromotionLocation.Order:
                    return this.orderDetailsService
                        .getOrderDetails()
                        .pipe(operators.map(function (order) { return _this.getProductPromotion(item, order.appliedProductPromotions || []); }));
            }
        };
        PromotionService.prototype.getProductPromotion = function (item, promotions) {
            var e_1, _a, e_2, _b;
            var entryPromotions = [];
            if (promotions && promotions.length > 0) {
                try {
                    for (var promotions_1 = __values(promotions), promotions_1_1 = promotions_1.next(); !promotions_1_1.done; promotions_1_1 = promotions_1.next()) {
                        var promotion = promotions_1_1.value;
                        if (promotion.description &&
                            promotion.consumedEntries &&
                            promotion.consumedEntries.length > 0) {
                            try {
                                for (var _c = (e_2 = void 0, __values(promotion.consumedEntries)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    var consumedEntry = _d.value;
                                    if (this.isConsumedByEntry(consumedEntry, item)) {
                                        entryPromotions.push(promotion);
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (promotions_1_1 && !promotions_1_1.done && (_a = promotions_1.return)) _a.call(promotions_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return entryPromotions;
        };
        PromotionService.prototype.isConsumedByEntry = function (consumedEntry, entry) {
            var e_3, _a;
            var consumedEntryNumber = consumedEntry.orderEntryNumber;
            if (entry.entries && entry.entries.length > 0) {
                try {
                    for (var _b = __values(entry.entries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subEntry = _c.value;
                        if (subEntry.entryNumber === consumedEntryNumber) {
                            return true;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return false;
            }
            else {
                return consumedEntryNumber === entry.entryNumber;
            }
        };
        return PromotionService;
    }());
    PromotionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PromotionService_Factory() { return new PromotionService(i0.ɵɵinject(OrderDetailsService), i0.ɵɵinject(i1.CheckoutService), i0.ɵɵinject(i1.ActiveCartService)); }, token: PromotionService, providedIn: "root" });
    PromotionService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    PromotionService.ctorParameters = function () { return [
        { type: OrderDetailsService },
        { type: i1.CheckoutService },
        { type: i1.ActiveCartService }
    ]; };

    var CustomFormValidators = /** @class */ (function () {
        function CustomFormValidators() {
        }
        /**
         * Checks control's value with predefined email regexp
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxInvalidEmail' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.emailValidator = function (control) {
            var email = control.value;
            return email && (!email.length || email.match(i1.EMAIL_PATTERN))
                ? null
                : { cxInvalidEmail: true };
        };
        /**
         * Checks control's value with predefined password regexp
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxInvalidPassword' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.passwordValidator = function (control) {
            var password = control.value;
            return password && (!password.length || password.match(i1.PASSWORD_PATTERN))
                ? null
                : { cxInvalidPassword: true };
        };
        /**
         * Checks if control's value is between 1 and 5
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxStarRatingEmpty' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.starRatingEmpty = function (control) {
            var rating = control.value;
            return rating >= 1 && rating <= 5 ? null : { cxStarRatingEmpty: true };
        };
        /**
         * Checks if two password controls match
         *
         * NOTE: Use it as a form validator and pass password control names as parameters
         *
         * @static
         * @param {string} password First password control name
         * @param {string} passwordConfirmation Second password control name
         * @returns Uses 'cxPasswordsMustMatch' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.passwordsMustMatch = function (password, passwordConfirmation) {
            var validator = function (formGroup) { return controlsMustMatch(formGroup, password, passwordConfirmation, 'cxPasswordsMustMatch'); };
            return validator;
        };
        /**
         * Checks if two email controls match
         *
         * NOTE: Use it as a form validator and pass email control names as parameters
         *
         * @static
         * @param {string} email First email control name
         * @param {string} emailConfirmation Second email control name
         * @returns Uses 'cxEmailsMustMatch' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.emailsMustMatch = function (email, emailConfirmation) {
            var validator = function (formGroup) { return controlsMustMatch(formGroup, email, emailConfirmation, 'cxEmailsMustMatch'); };
            return validator;
        };
        /**
         * Checks if control's value is euqal or greater than 0
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxNegativeAmount' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.mustBePositive = function (control) {
            var amount = control.value;
            return amount >= 0 ? null : { cxNegativeAmount: true };
        };
        /**
         * Checks if control's value does not contain any special characters
         *
         * NOTE: Use it as a control validator
         *
         * @static
         * @param {AbstractControl} control
         * @returns {(ValidationErrors | null)} Uses 'cxContainsSpecialCharacters' validator error
         * @memberof CustomFormValidators
         */
        CustomFormValidators.noSpecialCharacters = function (control) {
            var forbiddenChars = ['/'];
            var str = String(control.value);
            var containsSpecialChars = forbiddenChars.some(function (char) { return str.includes(char); });
            return !containsSpecialChars ? null : { cxContainsSpecialCharacters: true };
        };
        return CustomFormValidators;
    }());
    /**
     * Generic function for validators, which checks if two passed controls match.
     *
     * @param formGroup
     * @param firstControlName First control to check
     * @param secondControlName Second control to check
     * @param errorName Error which will be returned by validator
     */
    function controlsMustMatch(formGroup, firstControlName, secondControlName, errorName) {
        var _a;
        var firstControl = formGroup.controls[firstControlName];
        var secondControl = formGroup.controls[secondControlName];
        if (secondControl.errors && !secondControl.errors[errorName]) {
            return;
        }
        secondControl.setErrors(firstControl.value !== secondControl.value ? (_a = {}, _a[errorName] = true, _a) : null);
    }

    var titleScores = {
        mr: 1,
        mrs: 2,
        miss: 3,
        ms: 4,
        dr: 5,
        rev: 6,
    };
    function sortTitles(title1, title2) {
        if (!titleScores[title1.code] || !titleScores[title2.code]) {
            return 1;
        }
        else {
            return titleScores[title1.code] - titleScores[title2.code];
        }
    }

    /**
     * Service responsible for resolving cms config based feature modules.
     */
    var FeatureModulesService = /** @class */ (function () {
        function FeatureModulesService(configInitializer, compiler, injector, events) {
            this.configInitializer = configInitializer;
            this.compiler = compiler;
            this.injector = injector;
            this.events = events;
            // maps componentType to feature
            this.componentFeatureMap = new Map();
            /*
             * Contains either FeatureInstance or FeatureInstance resolver for not yet
             * resolved feature modules
             */
            this.features = new Map();
            this.dependencyModules = new Map();
            this.initFeatureMap();
        }
        FeatureModulesService.prototype.initFeatureMap = function () {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var config, _c, _d, _e, featureName, featureConfig, _f, _g, component;
                var e_1, _h, e_2, _j;
                return __generator(this, function (_k) {
                    switch (_k.label) {
                        case 0: return [4 /*yield*/, this.configInitializer.getStableConfig('featureModules')];
                        case 1:
                            config = _k.sent();
                            this.featureModulesConfig = (_a = config.featureModules) !== null && _a !== void 0 ? _a : {};
                            try {
                                for (_c = __values(Object.entries(this.featureModulesConfig)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    _e = __read(_d.value, 2), featureName = _e[0], featureConfig = _e[1];
                                    if ((_b = featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.cmsComponents) === null || _b === void 0 ? void 0 : _b.length) {
                                        try {
                                            for (_f = (e_2 = void 0, __values(featureConfig.cmsComponents)), _g = _f.next(); !_g.done; _g = _f.next()) {
                                                component = _g.value;
                                                this.componentFeatureMap.set(component, featureName);
                                            }
                                        }
                                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                        finally {
                                            try {
                                                if (_g && !_g.done && (_j = _f.return)) _j.call(_f);
                                            }
                                            finally { if (e_2) throw e_2.error; }
                                        }
                                    }
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_h = _c.return)) _h.call(_c);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Check if there is feature module configuration that covers specified
         * component type
         */
        FeatureModulesService.prototype.hasFeatureFor = function (componentType) {
            return this.componentFeatureMap.has(componentType);
        };
        /**
         * Return full CmsComponent mapping defined in feature module
         */
        FeatureModulesService.prototype.getCmsMapping = function (componentType) {
            var feature = this.componentFeatureMap.get(componentType);
            return this.resolveFeature(feature).pipe(operators.map(function (featureInstance) { return featureInstance.componentsMappings[componentType]; }));
        };
        /**
         * Get all injectors for feature and its dependencies
         *
         * As it's a synchronous method, it works only for already resolved features,
         * returning undefined otherwise
         */
        FeatureModulesService.prototype.getInjectors = function (componentType) {
            var _this = this;
            var _a;
            var feature = this.componentFeatureMap.get(componentType);
            var injectors;
            // we are returning injectors only for already resolved features
            (_a = this.features
                .get(feature)) === null || _a === void 0 ? void 0 : _a.subscribe(function (featureInstance) {
                injectors = __spread([
                    // feature module injector
                    featureInstance.moduleRef.injector
                ], featureInstance.depsModules.map(function (module) { return _this.dependencyModules.get(module).injector; }));
            }).unsubscribe();
            return injectors;
        };
        /**
         * Resolve feature based on feature name, if feature was not yet resolved
         *
         * It will first resolve all module dependencies if defined
         */
        FeatureModulesService.prototype.resolveFeature = function (featureName) {
            var _this = this;
            return rxjs.defer(function () {
                var _a;
                if (!_this.features.has(featureName)) {
                    var featureConfig_1 = _this.featureModulesConfig[featureName];
                    if (!(featureConfig_1 === null || featureConfig_1 === void 0 ? void 0 : featureConfig_1.module)) {
                        throw new Error('No module defined for Feature Module ' + featureName);
                    }
                    // resolve dependencies first (if any)
                    var depsResolve = ((_a = featureConfig_1.dependencies) === null || _a === void 0 ? void 0 : _a.length) ? rxjs.forkJoin(featureConfig_1.dependencies.map(function (depModuleFunc) { return _this.resolveDependencyModule(depModuleFunc); }))
                        : rxjs.of(undefined);
                    _this.features.set(featureName, depsResolve.pipe(operators.switchMap(function (deps) { return _this.resolveFeatureModule(featureConfig_1, deps); }), operators.tap(function (featureInstance) { return _this.events.dispatch(i1.createFrom(i1.ModuleInitializedEvent, {
                        featureName: featureName,
                        moduleRef: featureInstance.moduleRef,
                    })); }), operators.shareReplay()));
                }
                return _this.features.get(featureName);
            });
        };
        /**
         * Initialize feature module by returning feature instance
         */
        FeatureModulesService.prototype.resolveFeatureModule = function (featureConfig, depsModules) {
            var _this = this;
            if (depsModules === void 0) { depsModules = []; }
            return this.resolveModuleFactory(featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.module).pipe(operators.map(function (_c) {
                var e_3, _d;
                var _e = __read(_c, 1), moduleFactory = _e[0];
                var moduleRef = moduleFactory.create(_this.injector);
                var featureInstance = Object.assign(Object.assign({}, featureConfig), { moduleRef: moduleRef,
                    depsModules: depsModules, componentsMappings: {} });
                // resolve configuration for feature module
                var resolvedConfiguration = _this.resolveFeatureConfiguration(moduleRef.injector);
                try {
                    // extract cms components configuration from feature config
                    for (var _f = __values(featureInstance.cmsComponents), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var componentType = _g.value;
                        featureInstance.componentsMappings[componentType] =
                            resolvedConfiguration.cmsComponents[componentType];
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_d = _f.return)) _d.call(_f);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return featureInstance;
            }));
        };
        /**
         * Returns configuration provided in feature module
         */
        FeatureModulesService.prototype.resolveFeatureConfiguration = function (featureInjector) {
            // get config chunks from feature lib
            var featureConfigChunks = featureInjector.get(i1.ConfigChunk, [], i0.InjectFlags.Self);
            // get default config chunks from feature lib
            var featureDefaultConfigChunks = featureInjector.get(i1.DefaultConfigChunk, [], i0.InjectFlags.Self);
            return i1.deepMerge.apply(void 0, __spread([{}], (featureDefaultConfigChunks !== null && featureDefaultConfigChunks !== void 0 ? featureDefaultConfigChunks : []), (featureConfigChunks !== null && featureConfigChunks !== void 0 ? featureConfigChunks : [])));
        };
        /**
         * Resolves dependency module and initializes single module instance
         */
        FeatureModulesService.prototype.resolveDependencyModule = function (moduleFunc) {
            var _this = this;
            // We grab moduleFactory symbol from module function and if there is no
            // such a module created yet, we create it and store it in a
            // dependencyModules map
            return this.resolveModuleFactory(moduleFunc).pipe(operators.tap(function (_c) {
                var _d = __read(_c, 2), moduleFactory = _d[0], module = _d[1];
                if (!_this.dependencyModules.has(module)) {
                    var moduleRef = moduleFactory.create(_this.injector);
                    _this.dependencyModules.set(module, moduleRef);
                    _this.events.dispatch(i1.createFrom(i1.ModuleInitializedEvent, {
                        moduleRef: moduleRef,
                    }));
                }
            }), operators.pluck(1));
        };
        /**
         * Resolve any Angular module from an function that return module or moduleFactory
         */
        FeatureModulesService.prototype.resolveModuleFactory = function (moduleFunc) {
            var _this = this;
            return rxjs.from(moduleFunc()).pipe(operators.switchMap(function (module) { return module instanceof i0.NgModuleFactory
                ? rxjs.of([module, module])
                : rxjs.combineLatest([
                    // using compiler here is for jit compatibility, there is no overhead
                    // for aot production builds as it will be stubbed
                    rxjs.from(_this.compiler.compileModuleAsync(module)),
                    rxjs.of(module),
                ]); }), operators.observeOn(rxjs.queueScheduler));
        };
        FeatureModulesService.prototype.ngOnDestroy = function () {
            // clean up all initialized features
            rxjs.merge.apply(void 0, __spread(Array.from(this.features.values()))).subscribe(function (featureInstance) { var _a; return (_a = featureInstance.moduleRef) === null || _a === void 0 ? void 0 : _a.destroy(); });
            // clean up all initialized dependency modules
            this.dependencyModules.forEach(function (dependency) { return dependency.destroy(); });
        };
        return FeatureModulesService;
    }());
    FeatureModulesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FeatureModulesService_Factory() { return new FeatureModulesService(i0.ɵɵinject(i1.ConfigInitializerService), i0.ɵɵinject(i0.Compiler), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.EventService)); }, token: FeatureModulesService, providedIn: "root" });
    FeatureModulesService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    FeatureModulesService.ctorParameters = function () { return [
        { type: i1.ConfigInitializerService },
        { type: i0.Compiler },
        { type: i0.Injector },
        { type: i1.EventService }
    ]; };

    var CmsComponentsService = /** @class */ (function () {
        /**
         * @deprecated since 2.1
         * constructor(config: CmsConfig, platformId: Object);
         */
        function CmsComponentsService(config, platformId, featureModules) {
            this.config = config;
            this.platformId = platformId;
            this.featureModules = featureModules;
            this.missingComponents = [];
            this.mappings = {};
            // contains
            this.mappingResolvers = new Map();
        }
        /**
         * Should be called to make sure all component mappings are determined,
         * especially lazy loaded ones.
         *
         * It's recommended way to make sure all other methods of CmsComponentService
         * will be able to work synchronously for asked component types and avoid risk
         * of potential errors that could be thrown otherwise.
         */
        CmsComponentsService.prototype.determineMappings = function (componentTypes) {
            var _this = this;
            return rxjs.defer(function () {
                var e_1, _c;
                // we use defer, to be sure the logic below used to compose final observable
                // will be executed at subscription time (with up to date state at the time,
                // when it will be needed)
                var featureResolvers = [];
                try {
                    for (var componentTypes_1 = __values(componentTypes), componentTypes_1_1 = componentTypes_1.next(); !componentTypes_1_1.done; componentTypes_1_1 = componentTypes_1.next()) {
                        var componentType = componentTypes_1_1.value;
                        if (!_this.mappings[componentType]) {
                            var staticConfig = _this.config.cmsComponents[componentType];
                            // check if this component type is managed by feature module
                            if (_this.featureModules.hasFeatureFor(componentType)) {
                                featureResolvers.push(
                                // we delegate populating this.mappings to feature resolver
                                _this.getFeatureMappingResolver(componentType, staticConfig));
                            }
                            else {
                                // simply use only static config
                                _this.mappings[componentType] = staticConfig;
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (componentTypes_1_1 && !componentTypes_1_1.done && (_c = componentTypes_1.return)) _c.call(componentTypes_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (featureResolvers.length) {
                    return rxjs.forkJoin(featureResolvers).pipe(operators.mapTo(componentTypes));
                }
                else {
                    return rxjs.of(componentTypes);
                }
            });
        };
        CmsComponentsService.prototype.getFeatureMappingResolver = function (componentType, staticConfig) {
            var _this = this;
            if (!this.mappingResolvers.has(componentType)) {
                var mappingResolver$ = this.featureModules
                    .getCmsMapping(componentType)
                    .pipe(operators.tap(function (featureComponentMapping) {
                    // We treat cms mapping configuration from a feature as a default,
                    // that can be overridden by app/static configuration
                    _this.mappings[componentType] = i1.deepMerge({}, featureComponentMapping, staticConfig);
                    _this.mappingResolvers.delete(componentType);
                }), operators.share());
                this.mappingResolvers.set(componentType, mappingResolver$);
            }
            return this.mappingResolvers.get(componentType);
        };
        CmsComponentsService.prototype.getInjectors = function (componentType) {
            var _a;
            return ((_a = (this.featureModules.hasFeatureFor(componentType) &&
                this.featureModules.getInjectors(componentType))) !== null && _a !== void 0 ? _a : []);
        };
        /**
         * Return collection of component mapping configuration for specified list of
         * component types.
         *
         * If component mapping can't be determined synchronously, for example, lazy
         * loaded one, it will throw an error.
         *
         * To make sure component mapping is available, determineMappings()
         * should be called and completed first.
         */
        CmsComponentsService.prototype.getMapping = function (componentType) {
            var _a, _b;
            var componentConfig = (_a = this.mappings[componentType]) !== null && _a !== void 0 ? _a : (_b = this.config.cmsComponents) === null || _b === void 0 ? void 0 : _b[componentType];
            if (!componentConfig) {
                if (!this.missingComponents.includes(componentType)) {
                    this.missingComponents.push(componentType);
                    console.warn("No component implementation found for the CMS component type '" + componentType + "'.\n", "Make sure you implement a component and register it in the mapper.");
                }
            }
            return componentConfig;
        };
        /**
         * Checks, if component should be rendered as some components
         * could be disabled for server side renderings
         */
        CmsComponentsService.prototype.shouldRender = function (componentType) {
            var _a;
            var isSSR = i1$1.isPlatformServer(this.platformId);
            return !(isSSR && ((_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.disableSSR));
        };
        /**
         * Return DeferLoadingStrategy for component type.
         */
        CmsComponentsService.prototype.getDeferLoadingStrategy = function (componentType) {
            var _a, _b;
            return (_b = (_a = this.config.cmsComponents) === null || _a === void 0 ? void 0 : _a[componentType]) === null || _b === void 0 ? void 0 : _b.deferLoading;
        };
        /**
         * Get cms driven child routes for components
         */
        CmsComponentsService.prototype.getChildRoutes = function (componentTypes) {
            var e_2, _c;
            var _a, _b;
            var configs = [];
            try {
                for (var componentTypes_2 = __values(componentTypes), componentTypes_2_1 = componentTypes_2.next(); !componentTypes_2_1.done; componentTypes_2_1 = componentTypes_2.next()) {
                    var componentType = componentTypes_2_1.value;
                    if (this.shouldRender(componentType)) {
                        configs.push((_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.childRoutes) !== null && _b !== void 0 ? _b : []);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (componentTypes_2_1 && !componentTypes_2_1.done && (_c = componentTypes_2.return)) _c.call(componentTypes_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return this.standardizeChildRoutes(configs);
        };
        /**
         * Standardizes the format of `childRoutes` config.
         *
         * Some `childRoutes` configs are simple arrays of Routes (without the notion of the parent route).
         * But some configs can be an object with children routes and their parent defined in separate property.
         */
        CmsComponentsService.prototype.standardizeChildRoutes = function (childRoutesConfigs) {
            var result = { children: [] };
            (childRoutesConfigs || []).forEach(function (config) {
                var _c, _d;
                if (Array.isArray(config)) {
                    (_c = result.children).push.apply(_c, __spread(config));
                }
                else {
                    (_d = result.children).push.apply(_d, __spread((config.children || [])));
                    if (config.parent) {
                        result.parent = config.parent;
                    }
                }
            });
            return result;
        };
        /**
         * Get cms driven guards for components
         */
        CmsComponentsService.prototype.getGuards = function (componentTypes) {
            var e_3, _c;
            var _a, _b;
            var guards = new Set();
            try {
                for (var componentTypes_3 = __values(componentTypes), componentTypes_3_1 = componentTypes_3.next(); !componentTypes_3_1.done; componentTypes_3_1 = componentTypes_3.next()) {
                    var componentType = componentTypes_3_1.value;
                    (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.guards) === null || _b === void 0 ? void 0 : _b.forEach(function (guard) { return guards.add(guard); });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (componentTypes_3_1 && !componentTypes_3_1.done && (_c = componentTypes_3.return)) _c.call(componentTypes_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return Array.from(guards);
        };
        /**
         * Get i18n keys associated with components
         */
        CmsComponentsService.prototype.getI18nKeys = function (componentTypes) {
            var e_4, _c;
            var _a, _b;
            var i18nKeys = new Set();
            try {
                for (var componentTypes_4 = __values(componentTypes), componentTypes_4_1 = componentTypes_4.next(); !componentTypes_4_1.done; componentTypes_4_1 = componentTypes_4.next()) {
                    var componentType = componentTypes_4_1.value;
                    if (this.shouldRender(componentType)) {
                        (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.i18nKeys) === null || _b === void 0 ? void 0 : _b.forEach(function (key) { return i18nKeys.add(key); });
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (componentTypes_4_1 && !componentTypes_4_1.done && (_c = componentTypes_4.return)) _c.call(componentTypes_4);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return Array.from(i18nKeys);
        };
        return CmsComponentsService;
    }());
    CmsComponentsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsComponentsService_Factory() { return new CmsComponentsService(i0.ɵɵinject(i1.CmsConfig), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(FeatureModulesService)); }, token: CmsComponentsService, providedIn: "root" });
    CmsComponentsService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CmsComponentsService.ctorParameters = function () { return [
        { type: i1.CmsConfig },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: FeatureModulesService }
    ]; };

    var NOT_FOUND_SYMBOL = {};
    /**
     * CombinedInjector is able to combine more than one injector together in a way
     * that main injector is supported by complementary injectors.
     *
     * Should be used as a parent injector for components, when we want to have access
     * to both providers from component hierarchical injectors and providers from any
     * number of additional injectors (lazy loaded modules for example).
     */
    var CombinedInjector = /** @class */ (function () {
        /**
         * @param mainInjector Component hierarchical injector
         * @param complementaryInjectors Additional injector that will be taken into an account when resolving dependencies
         */
        function CombinedInjector(mainInjector, complementaryInjectors) {
            this.mainInjector = mainInjector;
            this.complementaryInjectors = complementaryInjectors;
        }
        CombinedInjector.prototype.get = function (token, notFoundValue, flags) {
            var e_1, _a;
            // tslint:disable-next-line:no-bitwise
            if (flags & i0.InjectFlags.Self) {
                if (notFoundValue !== undefined) {
                    return notFoundValue;
                }
                throw new Error("CombinedInjector should be used as a parent injector / doesn't support self dependencies");
            }
            try {
                for (var _b = __values(__spread([
                    this.mainInjector
                ], this.complementaryInjectors)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var injector = _c.value;
                    // First we are resolving providers provided at Self level in all injectors,
                    // starting with main injector and going through complementary ones...
                    var service = injector.get(token, NOT_FOUND_SYMBOL, i0.InjectFlags.Self);
                    if (service !== NOT_FOUND_SYMBOL) {
                        return service;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // ...and then fallback to main injector passing the flag
            return this.mainInjector.get(token, notFoundValue, flags);
        };
        return CombinedInjector;
    }());

    /**
     * Used to prepare injector for CMS components.
     *
     * Injector will take into account configured providers and provides CmsComponentData
     * for specified component's uid
     */
    var CmsInjectorService = /** @class */ (function () {
        function CmsInjectorService(cmsComponentsService, injector) {
            this.cmsComponentsService = cmsComponentsService;
            this.injector = injector;
        }
        CmsInjectorService.prototype.getCmsData = function (uid, parentInjector) {
            return {
                uid: uid,
                data$: (parentInjector !== null && parentInjector !== void 0 ? parentInjector : this.injector)
                    .get(i1.CmsService)
                    .getComponentData(uid),
            };
        };
        CmsInjectorService.prototype.getInjector = function (type, uid, parentInjector) {
            var _a, _b;
            var configProviders = (_b = (_a = this.cmsComponentsService.getMapping(type)) === null || _a === void 0 ? void 0 : _a.providers) !== null && _b !== void 0 ? _b : [];
            var complementaryInjectors = this.cmsComponentsService.getInjectors(type);
            if (complementaryInjectors === null || complementaryInjectors === void 0 ? void 0 : complementaryInjectors.length) {
                parentInjector = new CombinedInjector(parentInjector !== null && parentInjector !== void 0 ? parentInjector : this.injector, complementaryInjectors);
            }
            return i0.Injector.create({
                providers: __spread([
                    {
                        provide: CmsComponentData,
                        useValue: this.getCmsData(uid),
                    }
                ], configProviders),
                parent: parentInjector !== null && parentInjector !== void 0 ? parentInjector : this.injector,
            });
        };
        return CmsInjectorService;
    }());
    CmsInjectorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsInjectorService_Factory() { return new CmsInjectorService(i0.ɵɵinject(CmsComponentsService), i0.ɵɵinject(i0.INJECTOR)); }, token: CmsInjectorService, providedIn: "root" });
    CmsInjectorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CmsInjectorService.ctorParameters = function () { return [
        { type: CmsComponentsService },
        { type: i0.Injector }
    ]; };

    /**
     * ComponentHandler implementations can be used for instantiating and launching
     * different types of CMS mapped components
     */
    var ComponentHandler = /** @class */ (function () {
        function ComponentHandler() {
        }
        return ComponentHandler;
    }());

    /**
     * Responsible for obtaining component handler for specified component mapping
     */
    var ComponentHandlerService = /** @class */ (function () {
        function ComponentHandlerService(handlers) {
            this.handlers = handlers;
            this.invalidMappings = new Set();
        }
        /**
         * Get best matching component handler
         *
         * @param componentMapping
         */
        ComponentHandlerService.prototype.resolve = function (componentMapping) {
            var handler = i1.resolveApplicable(this.handlers, [componentMapping]);
            if (i0.isDevMode() && !handler) {
                if (!this.invalidMappings.has(componentMapping)) {
                    this.invalidMappings.add(componentMapping);
                    console.warn("Can't resolve handler for component mapping: ", componentMapping);
                }
            }
            return handler;
        };
        /**
         * Get launcher for specified component mapping
         *
         * @param componentMapping
         * @param viewContainerRef
         * @param elementInjector
         */
        ComponentHandlerService.prototype.getLauncher = function (componentMapping, viewContainerRef, elementInjector) {
            var _a;
            return (_a = this.resolve(componentMapping)) === null || _a === void 0 ? void 0 : _a.launcher(componentMapping, viewContainerRef, elementInjector);
        };
        return ComponentHandlerService;
    }());
    ComponentHandlerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ComponentHandlerService_Factory() { return new ComponentHandlerService(i0.ɵɵinject(ComponentHandler, 8)); }, token: ComponentHandlerService, providedIn: "root" });
    ComponentHandlerService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ComponentHandlerService.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [ComponentHandler,] }] }
    ]; };

    /**
     * Directive used to facilitate instantiation of CMS driven dynamic components
     */
    var ComponentWrapperDirective = /** @class */ (function () {
        function ComponentWrapperDirective(vcr, cmsComponentsService, injector, dynamicAttributeService, renderer, componentHandler, cmsInjector) {
            this.vcr = vcr;
            this.cmsComponentsService = cmsComponentsService;
            this.injector = injector;
            this.dynamicAttributeService = dynamicAttributeService;
            this.renderer = renderer;
            this.componentHandler = componentHandler;
            this.cmsInjector = cmsInjector;
        }
        ComponentWrapperDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.cmsComponentsService
                .determineMappings([this.cxComponentWrapper.flexType])
                .subscribe(function () {
                if (_this.cmsComponentsService.shouldRender(_this.cxComponentWrapper.flexType)) {
                    _this.launchComponent();
                }
            });
        };
        ComponentWrapperDirective.prototype.launchComponent = function () {
            var _this = this;
            var _a;
            var componentMapping = this.cmsComponentsService.getMapping(this.cxComponentWrapper.flexType);
            if (!componentMapping) {
                return;
            }
            this.launcherResource = (_a = this.componentHandler
                .getLauncher(componentMapping, this.vcr, this.cmsInjector.getInjector(this.cxComponentWrapper.flexType, this.cxComponentWrapper.uid, this.injector))) === null || _a === void 0 ? void 0 : _a.subscribe(function (_b) {
                var elementRef = _b.elementRef, componentRef = _b.componentRef;
                _this.cmpRef = componentRef;
                _this.decorate(elementRef);
                _this.injector.get(i0.ChangeDetectorRef).markForCheck();
            });
        };
        ComponentWrapperDirective.prototype.decorate = function (elementRef) {
            this.dynamicAttributeService.addDynamicAttributes(elementRef.nativeElement, this.renderer, { componentData: this.cxComponentWrapper });
        };
        ComponentWrapperDirective.prototype.ngOnDestroy = function () {
            if (this.launcherResource) {
                this.launcherResource.unsubscribe();
            }
        };
        return ComponentWrapperDirective;
    }());
    ComponentWrapperDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cxComponentWrapper]',
                },] }
    ];
    ComponentWrapperDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: CmsComponentsService },
        { type: i0.Injector },
        { type: i1.DynamicAttributeService },
        { type: i0.Renderer2 },
        { type: ComponentHandlerService },
        { type: CmsInjectorService }
    ]; };
    ComponentWrapperDirective.propDecorators = {
        cxComponentWrapper: [{ type: i0.Input }]
    };

    /**
     * Default component handler used for dynamically launching cms components implemented
     * as native Angular components.
     */
    var DefaultComponentHandler = /** @class */ (function () {
        function DefaultComponentHandler() {
        }
        DefaultComponentHandler.prototype.hasMatch = function (componentMapping) {
            return typeof componentMapping.component === 'function';
        };
        DefaultComponentHandler.prototype.getPriority = function () {
            return -50 /* FALLBACK */;
        };
        DefaultComponentHandler.prototype.launcher = function (componentMapping, viewContainerRef, elementInjector) {
            var _this = this;
            return new rxjs.Observable(function (subscriber) {
                var componentRef;
                var injector = elementInjector !== null && elementInjector !== void 0 ? elementInjector : viewContainerRef.injector;
                var dispose = function () {
                    if (componentRef) {
                        componentRef.destroy();
                    }
                };
                var factory = _this.getComponentFactory(injector, componentMapping.component);
                if (factory) {
                    componentRef = viewContainerRef.createComponent(factory, undefined, injector);
                    subscriber.next({ elementRef: componentRef.location, componentRef: componentRef });
                }
                return dispose;
            });
        };
        DefaultComponentHandler.prototype.getComponentFactory = function (injector, component) {
            if (!component) {
                return null;
            }
            var factory = injector
                .get(i0.ComponentFactoryResolver)
                .resolveComponentFactory(component);
            return factory;
        };
        return DefaultComponentHandler;
    }());
    DefaultComponentHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function DefaultComponentHandler_Factory() { return new DefaultComponentHandler(); }, token: DefaultComponentHandler, providedIn: "root" });
    DefaultComponentHandler.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Lazy component handler used for launching lazy loaded cms components implemented
     * as native Angular components.
     */
    var LazyComponentHandler = /** @class */ (function () {
        function LazyComponentHandler(defaultHandler) {
            this.defaultHandler = defaultHandler;
        }
        /**
         * We want to mach dynamic import signature () => import('')
         */
        LazyComponentHandler.prototype.hasMatch = function (componentMapping) {
            return (typeof componentMapping.component === 'function' &&
                this.isNotClass(componentMapping.component));
        };
        LazyComponentHandler.prototype.isNotClass = function (symbol) {
            var signature = symbol.toString().substr(0, 20).replace(' ', '');
            return signature.startsWith('function()') || signature.startsWith('()=>');
        };
        LazyComponentHandler.prototype.getPriority = function () {
            return -10 /* LOW */;
        };
        LazyComponentHandler.prototype.launcher = function (componentMapping, viewContainerRef, elementInjector) {
            var _this = this;
            return rxjs.from(componentMapping.component()).pipe(operators.switchMap(function (component) { return _this.defaultHandler.launcher(Object.assign(Object.assign({}, componentMapping), { component: component }), viewContainerRef, elementInjector); }));
        };
        return LazyComponentHandler;
    }());
    LazyComponentHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyComponentHandler_Factory() { return new LazyComponentHandler(i0.ɵɵinject(DefaultComponentHandler)); }, token: LazyComponentHandler, providedIn: "root" });
    LazyComponentHandler.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    LazyComponentHandler.ctorParameters = function () { return [
        { type: DefaultComponentHandler }
    ]; };

    var PageComponentModule = /** @class */ (function () {
        function PageComponentModule() {
        }
        return PageComponentModule;
    }());
    PageComponentModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    providers: [
                        {
                            provide: ComponentHandler,
                            useExisting: DefaultComponentHandler,
                            multi: true,
                        },
                        {
                            provide: ComponentHandler,
                            useExisting: LazyComponentHandler,
                            multi: true,
                        },
                    ],
                    declarations: [ComponentWrapperDirective],
                    exports: [ComponentWrapperDirective],
                },] }
    ];

    var ASM_ENABLED_LOCAL_STORAGE_KEY = 'asm_enabled';

    /**
     * The AsmEnablerService is used to enable ASM for those scenario's
     * where it's actually used. This service is added to avoid any polution
     * of the UI and runtime performance for the ordinary production user.
     */
    var AsmEnablerService = /** @class */ (function () {
        function AsmEnablerService(location, winRef, launchDialogService) {
            this.location = location;
            this.winRef = winRef;
            this.launchDialogService = launchDialogService;
        }
        /**
         * Loads the ASM UI if needed. The ASM UI will be added based on the
         * existence of a URL parameter or previous usage given by local storage.
         */
        AsmEnablerService.prototype.load = function () {
            if (this.isEnabled()) {
                this.addUi();
            }
        };
        /**
         * Indicates whether the ASM module is enabled.
         */
        AsmEnablerService.prototype.isEnabled = function () {
            if (this.isLaunched() && !this.isUsedBefore()) {
                if (this.winRef.localStorage) {
                    this.winRef.localStorage.setItem(ASM_ENABLED_LOCAL_STORAGE_KEY, 'true');
                }
            }
            return this.isLaunched() || this.isUsedBefore();
        };
        /**
         * Indicates whether ASM is launched through the URL,
         * using the asm flag in the URL.
         */
        AsmEnablerService.prototype.isLaunched = function () {
            var params = this.location.path().split('?')[1];
            return params && params.split('&').includes('asm=true');
        };
        /**
         * Evaluates local storage where we persist the usage of ASM.
         */
        AsmEnablerService.prototype.isUsedBefore = function () {
            return (this.winRef.localStorage &&
                this.winRef.localStorage.getItem(ASM_ENABLED_LOCAL_STORAGE_KEY) === 'true');
        };
        /**
         * Adds the ASM UI by using the `cx-storefront` outlet.
         */
        AsmEnablerService.prototype.addUi = function () {
            this.launchDialogService.launch(exports.LAUNCH_CALLER.ASM);
        };
        return AsmEnablerService;
    }());
    AsmEnablerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AsmEnablerService_Factory() { return new AsmEnablerService(i0.ɵɵinject(i1$1.Location), i0.ɵɵinject(i1.WindowRef), i0.ɵɵinject(LaunchDialogService)); }, token: AsmEnablerService, providedIn: "root" });
    AsmEnablerService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AsmEnablerService.ctorParameters = function () { return [
        { type: i1$1.Location },
        { type: i1.WindowRef },
        { type: LaunchDialogService }
    ]; };

    /**
     * The ASM loader module takes care of loading the ASM UI
     * only in case there's a reason to do so.
     */
    var AsmLoaderModule = /** @class */ (function () {
        function AsmLoaderModule() {
        }
        return AsmLoaderModule;
    }());
    AsmLoaderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, PageComponentModule],
                    providers: [
                        {
                            provide: i0.APP_INITIALIZER,
                            useFactory: asmFactory,
                            deps: [AsmEnablerService],
                            multi: true,
                        },
                    ],
                },] }
    ];
    /**
     *
     * We do not like to block the UI, which is why we delgate loading of ASM
     * to a real component; the router and state aren't available in an optimized
     * way during the APP_INITIALIZER.
     */
    function asmFactory(asmEnablerService) {
        var isReady = function () {
            asmEnablerService.load();
        };
        return isReady;
    }

    var AsmComponentService = /** @class */ (function () {
        function AsmComponentService(authService, asmAuthService, routingService, winRef) {
            this.authService = authService;
            this.asmAuthService = asmAuthService;
            this.routingService = routingService;
            this.winRef = winRef;
        }
        AsmComponentService.prototype.logoutCustomerSupportAgentAndCustomer = function () {
            var _this = this;
            this.authService
                .getUserToken()
                .pipe(operators.take(1))
                .subscribe(function (token) {
                if (_this.asmAuthService.isCustomerEmulationToken(token)) {
                    _this.logoutCustomer();
                }
                _this.asmAuthService.logoutCustomerSupportAgent();
            });
        };
        AsmComponentService.prototype.logoutCustomer = function () {
            this.authService.logout();
            this.routingService.go({ cxRoute: 'home' });
        };
        AsmComponentService.prototype.isCustomerEmulationSessionInProgress = function () {
            var _this = this;
            return this.authService
                .getUserToken()
                .pipe(operators.mergeMap(function (userToken) { return rxjs.of(_this.asmAuthService.isCustomerEmulationToken(userToken)); }));
        };
        /**
         * We're currently only removing the persisted storage in the browser
         * to ensure the ASM experience isn't loaded on the next visit. There are a few
         * optimsiations we could think of:
         * - drop the `asm` parameter from the URL, in case it's still there
         * - remove the generated UI from the DOM (outlets currently do not support this)
         */
        AsmComponentService.prototype.unload = function () {
            if (this.winRef.localStorage) {
                this.winRef.localStorage.removeItem(ASM_ENABLED_LOCAL_STORAGE_KEY);
            }
        };
        return AsmComponentService;
    }());
    AsmComponentService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AsmComponentService_Factory() { return new AsmComponentService(i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i1.AsmAuthService), i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.WindowRef)); }, token: AsmComponentService, providedIn: "root" });
    AsmComponentService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AsmComponentService.ctorParameters = function () { return [
        { type: i1.AuthService },
        { type: i1.AsmAuthService },
        { type: i1.RoutingService },
        { type: i1.WindowRef }
    ]; };

    var AsmMainUiComponent = /** @class */ (function () {
        function AsmMainUiComponent(authService, asmAuthService, userService, asmComponentService, globalMessageService, routingService, asmService) {
            this.authService = authService;
            this.asmAuthService = asmAuthService;
            this.userService = userService;
            this.asmComponentService = asmComponentService;
            this.globalMessageService = globalMessageService;
            this.routingService = routingService;
            this.asmService = asmService;
            this.disabled = false;
            this.startingCustomerSession = false;
        }
        AsmMainUiComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.csAgentToken$ = this.asmAuthService.getCustomerSupportAgentToken();
            this.csAgentTokenLoading$ = this.asmAuthService.getCustomerSupportAgentTokenLoading();
            this.customer$ = this.authService.getUserToken().pipe(operators.switchMap(function (token) {
                if (token && !!token.access_token) {
                    _this.handleCustomerSessionStartRedirection(token);
                    return _this.userService.get();
                }
                else {
                    return rxjs.of(undefined);
                }
            }));
            this.isCollapsed$ = this.asmService
                .getAsmUiState()
                .pipe(operators.map(function (uiState) { return uiState.collapsed; }));
        };
        AsmMainUiComponent.prototype.handleCustomerSessionStartRedirection = function (token) {
            if (this.startingCustomerSession &&
                this.asmAuthService.isCustomerEmulationToken(token)) {
                this.startingCustomerSession = false;
                this.globalMessageService.remove(i1.GlobalMessageType.MSG_TYPE_ERROR);
                this.routingService.go('/');
            }
        };
        AsmMainUiComponent.prototype.loginCustomerSupportAgent = function (_a) {
            var userId = _a.userId, password = _a.password;
            this.asmAuthService.authorizeCustomerSupportAgent(userId, password);
        };
        AsmMainUiComponent.prototype.logout = function () {
            this.asmComponentService.logoutCustomerSupportAgentAndCustomer();
        };
        AsmMainUiComponent.prototype.startCustomerEmulationSession = function (_a) {
            var _this = this;
            var customerId = _a.customerId;
            this.asmAuthService
                .getCustomerSupportAgentToken()
                .pipe(operators.take(1))
                .subscribe(function (customerSupportAgentToken) { return _this.asmAuthService.startCustomerEmulationSession(customerSupportAgentToken, customerId); })
                .unsubscribe();
            this.startingCustomerSession = true;
        };
        AsmMainUiComponent.prototype.hideUi = function () {
            this.disabled = true;
            this.asmComponentService.unload();
        };
        return AsmMainUiComponent;
    }());
    AsmMainUiComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-asm-main-ui',
                    template: "<div class=\"asm-bar\">\n  <div class=\"asm-bar-branding\">\n    <img\n      class=\"logo\"\n      src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAwCAYAAADuFn/PAAAAAXNSR0IArs4c6QAAD7RJREFUeAHtW3twVGcVP7t795V30rwJBBJeASq01NJgnZa2otTW2nHAqrRak+rUKfgYZ/xDW5lRR2e0/mGtAadqq6WjUAdNa4udqVZaEdtCKQ2FQEh5JSQh5Lnvp7/ft9lkd9l7swkhwMiZ3N27937fd8533ufcG9P1L/VE5SpMOwdMmk0iocDzWjAUnnbk/9cITSYx2xwS9Xs3Wzs7NmqhcOT/mh/Tunkw32SzScjr2Vy2v3XDa5tWhbRI5KoHmi4hmGx2ifi8mz8UmvHI9k2VyvVokasWMC38N8HtRHyezUejex5pXbdu1O9r5qsCuLgCUD4fmu/1bq5sbd9wdNMY84lYM10VwMUTAJlvtUnU491c0XZc+fxUZFo0Mn4QjiJMMFREcKJG4xxrC/7ETCQ854+JAtbBny5Mak3d1ab3BsKtCrhhuJ2K9lNpmU+KYAHpWRAFa4K4x7t5NouU5WhS4rRIvt0idotJ3MGIDPgj0usNSZ8vLMOBiIQhJQukoZkpHGOJcGXLiPD0WBNStOmvQ8ETAjp7iN0d++RelBLhBFsAnVQe/fXHZk7wDEuarXaJBrxNFe2nNzLb0VsBMWA0HoyO8WNDDnDxIzOy5ONzcuX6MqdU5VhxLZlYWoUvFJEud0iODQZkb5dXHa19PnEFw2LDBi0QRqqac14BBPnz2yul0GEZxZt68vzhQXm6pS+Gl9xLANL4uUWFsm5hPmiIjiPu2EQqSY8nJCeHAnK4zy+tOLrdQXXTClqVLFLwJKDM7BSLmMD8iN/btCRn3obtm+adz+CElTTlW0YuEDe1qR6M//oNJXJDRVbC0PNPqYFZVrPUFNjU8bHqHGUF3NxLx4ZkZ/uQdLnOF34Acad+To6srDRe/7ML8+T5Q/3KEpNFD5lijVKnWa4tdpxPWIZXeiGM/3S65Y/vD8hbnR6lLBdkEdR8DZrv9zUtyT+wYfu6+YbMJ5mjQZjMZ1H20HXF8s0VZWKjjU4C6IIWgyk8PlqVLY0vnhDGkMTVNJjA3bV5464+t9AhS4vtsqfDBWuiKY0Bk4dIhq5nbFbyWXGWJnfPzZc1NRT0gDy+p1uG/WHlmpJHZvALG6TmR/2epoOFBzccTEg1jWabTXBBpkhYgoGQNCy9Rr6zsnzSzE9ERKZvazknAX9IzFhf4QGuMFofNXmarKjMThye9pwWtqYmV6Jwc2R4fI3Rb/qyKQDGgvsWF8ovVlcJSEOPJsaTUTzkkdGBRMZstorA7SwqXLRBMmQ+STczC/IHwnA3TvlGfdkUbCe2xBsnhmVna79YTQi3YB7x8AhA0LfPzpNsW7JG6yG+BWOLHWYJgwHxNUa/KeUphPqZOfKt+nKlJIk0j+Ib2UPyb8QfMD/q8zYV9/Ru3L7ONK7bSSTZHIUZm6FJDdeXIrsZnynMdBh4jfbuR1B8YnenhBCIVZZFV4GDuLLh2j4xLz+RBsPzylyrspYAlIRrJB1TZAGJBHxmUZFcV5YFRUmDLxU/fpP5aC80Fff1GWY7iTgSzzWa26wCu6yA9I3g7VPDsu1Ar3zQ75MAGEwNLnBoUgtfv2JmriybkSM5SFcJO1p65Z3Tw2JnPgqtiUMIgluGsXUlzviljL7vnF8gLx86h7UShnNdIy3A0NeODcrrHwwqn56LrKv2GtA6K0+K4Pv1wAoF+STw7T05lBy4kibQ8lhkMdvxNZUMD06K+VxSC0NLawtto8xLwjPyYx+Y2bCtVVwjAYrpGvdOBXzlcFSeguVUF9rlzroiuXlOgfzmv2fEwgFwG4kQhitag80xUE8EbgLTZsISOgb9Y3MhzPEE8NapIdmyu0McyNRIDjOcmVC2x1ZXy621BbokLK/KEZQ8CPLJ9I9OwDpm9POR7fzqYPXyjTJBtzO6Dk4QH8MosPQ1goND4DSDNFCKDT4dHk99O8xRRSjKaTnR65Ff7jolX37ufTnT78UYBE1oafygT2Uhd9vcwkT8GZ3noVa4tSY/5tIS1jQBrxFYIWdkqurIAkMdoL2jzyvf/1u7dA8HdKdW5FmlCHEnFozH9qASAfDCYtLYz2+qe7P9gphPAhADEBipTQZwIzTwJ3fVSmm2VTy+kARgNeyiqkDFbzDFooQioh7w4PfovZFxDL7U5Mp8W1pMrLppYXqwBtbFuJ2MF2ptAFEwK4kO0MWkoGPAK/s7hnVnMhZmw30m4eI+aEZgPtzOr+pqTmzYvj25saa7oMENiDIq3UN+gyGxW5+6tkRurM6XHe/2yIstZ6XtrEcJTgOxTOPoluIVbypb+JvK+slF1+jiae/1yuvH+qVx5Yy0Y66tzJX5xVnScsYlrFpZA5AfRkCGcVwEljoKoDOMaz5UxXqgIQ7Aa6lxo1Mxj3l+OOD73eEFKze2rKvX1xa9hdNcx1aicqjLJb0ufZOMzyvPs8nDH62SPzculWceWAJmVUkNAlsAgdwFywhCS0LQstTDz0BfZJebEB/0YM8HA7Jjf7eqpNONYWF4x4JC8QVDav0g8LCvYwS8z3GJ9NDaEY9lfql+Fc4kg/sJJ8wNm20S9nu3+sKBr12Iz0+l10wtOQ2fTa3OFBjUbpqdL9/9xBz5y1eXyVNfWCy0EA0bc6Pw4oZJfPzwwWXdPr9IcrhzHdjV1icHod20LD1YXVes1qCgufZ4AmDKTOFTQUgDafPg+PwNFbIAqaYeuOEKe90B5XIUHgseIwa9W/3RYOPxTat8evMmc121o+m/m/51QlaBSdVFE0sRnVaLmse5LZ0ueeK14/IShKk6nbQvCDiLqd3iYl36uuAC950cFK8/KK9DEAvK0lfJc0uyZHlVrvzzyLmY+xnHAvIg8CpYrQM0ZiGAVF+TJXdDUe6+ttSwC9ra7ZJ+eASVraG3A5+/1VLqbmjfeOf4vlp3l+lvQAAoxHDvNLKDh7e+J1vWf0hmogczGVhSmSNbPr9EnvnPafnB344iINP8o3Lj7AJZDB+uB3va+6V70KcC+T9bz0nDyplpny8wzty1pFRePXQ2IwE8WD9DPgdtN2EiBWBFvMoEXnm/V/xwddnOLHY1n9OGfQ1tP5x65pMW1PgIRjiYYew/MSj3bdkrfz/YkwmdumO+WF8lP753IVLQqEod74LWscDRg1cP9ap+jxWMOgBL6BjQt/JVC4qkIgfv1JBurG8E1PyCLKvkI83OlPknoYgvvtslDjzDDQe8W8H8L7c9cXGYT9qRa2ETPJAZ2OEyTvS65StPvysP//6AvH18wGh/hvfWLq+QtcvLhW5g9aIS3bH96Mf/tw09IygAApL0DvlkdxuqXh0oy7PLzaglmNbGzEBn4CQuM2b86IUjctYFrxD0bTU5LI0Xk/kk0RxhMEs4GCbplnbs7ZC1T74lX9jytvzpzQ45Y6CVentdf1OVrIHLmGkQV/a098mpc24xgfmKDmj2Ky3GFnjX0jIIi3pjbAF6dKW7zjrksR2Hpfm9PtEi/q3RLG3KA246vBrdRCrQWTjgL1kJ/gPM4FGe75Dl8OV3LC6VW5CNVBSMHycWVuTKN1fXpi6f9Jsuh81Atq0JVIAPetwyhEedeToV+sraIvSgnOhank+7WmSCH0eRhv8Ymr8TzwSQ7zxr7rc9dPzxqc129Egy1Xz9paRd8Eeqt+Y1lVNjwzwvRz/l08tnyCNgbhH88YUAU8O2brd0IhX24zlzCVzMbGQ7FLDR06nvbTsodvitR++tmxT6QU9QDqEafuGdTmned0b6fSaxg/mRwa6Hjj/9oH4QmhQ2/UnnWQALFWYbDFpxQfCb+QMrRAqgH02xJ3celdOIF5sbl+NhRHykPiK9O9l2TZbOyleH3ph019fADe05qh8rOOeNw72y+0gv6I7thSnxOaSXp895YGUelfmxTnA4nGKPBrfCrTW2P/3glKea6eiPX9Ms8P9xYMq4/iOzlAvY09qrLttIfDr+QiLtnUMqflM40w3LqgtQNxh3A954v0cebz4szpE2OWnkXpiWMsdnC8XuQLaDgBs1WxoudsBNxyNYQEwAZP6c0hx5dO0SVUTthGlu//cJOXC8X4bx8JouSAkCJsAZOXgW8NAdtcoq0i18sa9lA//NC/WLO+Jnzygbb3Kkvs2haIMgzKhwI0g1oxbrJWE+6dAs9CmAIPzvA7fORsESaxfcc2OVfOrDVXKsa1gOnhyQDrSbB1Ce0y+XoVBbsaBEFs3M/MlWDMvUfjoSNDvdyrRM7i++x8QxJjI/6Hs2rFkveqqZiDf1XFkAU7B55Tny6fpZSfep8XORyfC4IoEtWFp4BBsZAb4wpv45Iuh/1uvvY8CdVp8fpyP+rbH4iSIQrV81B2kfnuxPA/AlgJ9tf0/KUR8sqi6U8kInyn6rCvpMAs6hGDuJVHQ/CrL7bquRuZXjv8KSjmy0/tWTOfV0bmSAcjsh/7OewMC0Zjvp6OM1ja+J1MGVrL1ljt6YKb/ehuD93KvHVJfSjnaB06aJNvLWHRXWj86lF+mpF4IqRTo6WQHwAQULPB4EExtrYL7X6Wg8/utLq/lxpppZUfrQ+37tnTNq4/Ebk/lmoH793TOKeUbzd2EM35jIBvMZcfxgthvxhYfXizYwqmEnnkjxIf+/W7rQqoox0GjNdPdoASw0eZjRzxf4fG+H45L6/FQ6zVS8M2dd8u0nd8v9P/yH/H7nETnd40odZ/ib7NmHfPurP90lbx7uESdyeyPYtb8TjwbBHAiMLpDtcAoifvAa7/Hd0kNoVUyUnjhu9b4n10fANQX8f3BndTa2vXzxGmtxvBP5Nl33pW1KvUCnejWR2laEarQOvnnZvGKpm10olXgUWJhrFxs0lsCxLk9AulG9toBBb0Cj6a/d3qCsva1W5lTQZ6tl1fjEj0Fo+XOvHAUuMHksNiYOSTpnS/tOJAcLZvFhfvo1kyYk/Njd0i1vHxlAbAltc3VlP3C5MZ+kmq574E/n7YquhO+JsuPLgsWJjiaDZLylywk+uI1hMJzpKythK1wGGcrfRi6DYyjIDHgfYyUGBrDmZP6XzWZHO0NCzR6LfX3rb+/Rfwofw3RJPrV4gErErlwBKmDlE3AjDAYMBn1J3V8ykk+9NPaRCTQL/KmXeg16/6Nj1UkGH1iT/48AZBkMHhvCt5Qj4UCzW3NctswntRr5lgmo/DmVBzGeZzJ9WseQ+eFgoNkz5Frf2vzZy1Lz4wxBDM5QAvEZl/m32cJUE8y3kfkNlzXzyUr1XtBlztOMyVNuJ+Rvdg571u+7Apg/IoCM93dZD+S7mnA7f/W4PPdfKcwfEcCV74KU26HPd3vvvxLcTqImX4pWfiL+Cz7nf6ZEI8G/ut3eK8Lnp254pAOTevnK+G0yI4RFQvtzQ9r6vc0NEyvfL5Mt/g8XIbTVhsig+gAAAABJRU5ErkJggg==\"\n      width=\"48\"\n      height=\"24\"\n      alt=\"{{ 'asm.mainLogoLabel' | cxTranslate }}\"\n    />\n\n    <div class=\"asm-title\">\n      {{ 'asm.mainTitle' | cxTranslate }}\n    </div>\n  </div>\n  <div class=\"asm-bar-actions\">\n    <cx-asm-toggle-ui></cx-asm-toggle-ui>\n\n    <cx-asm-session-timer\n      *ngIf=\"(csAgentToken$ | async)?.access_token\"\n    ></cx-asm-session-timer>\n\n    <button\n      class=\"close\"\n      title=\"{{ 'asm.hideUi' | cxTranslate }}\"\n      *ngIf=\"\n        !(csAgentToken$ | async)?.access_token &&\n        !(csAgentTokenLoading$ | async)\n      \"\n      (click)=\"hideUi()\"\n    ></button>\n\n    <button\n      class=\"logout\"\n      title=\"{{ 'asm.logout' | cxTranslate }}\"\n      *ngIf=\"(csAgentToken$ | async)?.access_token\"\n      (click)=\"logout()\"\n    ></button>\n  </div>\n</div>\n\n<ng-container *ngIf=\"!(isCollapsed$ | async) as notCollapsed\">\n  <ng-container\n    *ngIf=\"(csAgentToken$ | async)?.access_token; else showLoginForm\"\n  >\n    <ng-container *ngIf=\"customer$ | async; else showCustomerSelection\">\n      <cx-customer-emulation *ngIf=\"notCollapsed\"></cx-customer-emulation>\n    </ng-container>\n    <ng-template #showCustomerSelection>\n      <cx-customer-selection\n        *ngIf=\"notCollapsed\"\n        (submitEvent)=\"startCustomerEmulationSession($event)\"\n      ></cx-customer-selection>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #showLoginForm>\n    <cx-csagent-login-form\n      *ngIf=\"notCollapsed\"\n      (submitEvent)=\"loginCustomerSupportAgent($event)\"\n      [csAgentTokenLoading]=\"csAgentTokenLoading$ | async\"\n    ></cx-csagent-login-form>\n  </ng-template>\n</ng-container>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["cx-asm-main-ui{display:flex;flex-direction:column;font-family:Arial,sans-serif;font-size:14px;width:100%}cx-asm-main-ui .close,cx-asm-main-ui .logout{background-color:transparent;border:transparent;cursor:pointer;height:16px;width:16px}cx-asm-main-ui .close{background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='white' d='M14.53 4.53l-1.06-1.06L9 7.94 4.53 3.47 3.47 4.53 7.94 9l-4.47 4.47 1.06 1.06L9 10.06l4.47 4.47 1.06-1.06L10.06 9z'/%3E%3C/svg%3E\")}cx-asm-main-ui .logout{background-image:url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cpath fill='%23d1e3ff' d='M11,2.7c1.2,0.6,2.2,1.5,2.9,2.6c1.3,1.9,1.5,4.4,0.6,6.5c-0.3,0.8-0.8,1.6-1.5,2.2c-0.6,0.6-1.4,1.1-2.2,1.5 C9.9,15.8,9,16,8,16c-0.9,0-1.9-0.2-2.7-0.5c-0.8-0.4-1.6-0.9-2.2-1.5c-0.6-0.6-1.1-1.4-1.5-2.2C0.7,9.6,0.9,7.2,2.1,5.3 c0.7-1.1,1.7-2,2.9-2.6v1.1C4.1,4.3,3.3,5.1,2.8,6C2.3,6.9,2,7.9,2,9c0,1.6,0.6,3.2,1.8,4.3c0.5,0.5,1.2,1,1.9,1.3 c1.5,0.6,3.2,0.6,4.7,0c0.7-0.3,1.4-0.7,1.9-1.3C13.4,12.1,14,10.6,14,9c0-1.1-0.3-2.1-0.8-3c-0.5-0.9-1.3-1.7-2.2-2.2 C11,3.8,11,2.7,11,2.7z M8,9C7.7,9,7.5,8.9,7.3,8.7C7.1,8.5,7,8.3,7,8V1c0-0.3,0.1-0.5,0.3-0.7c0.4-0.4,1-0.4,1.4,0 C8.9,0.5,9,0.7,9,1v7c0,0.3-0.1,0.5-0.3,0.7C8.5,8.9,8.2,9,8,9z'/%3E%3C/svg%3E%0A\")}cx-asm-main-ui button[type=submit]{border-radius:4px;border-style:solid;border-width:1px;font-weight:400;height:36px;padding:0 12px;white-space:nowrap}cx-asm-main-ui button[type=submit]:disabled{cursor:not-allowed;opacity:.4}cx-asm-main-ui .spinner{color:#0a6ed1;display:flex;justify-content:center;width:100%}cx-asm-main-ui .spinner>div{-webkit-animation:spinner-dots-pulse 1s ease infinite;animation:spinner-dots-pulse 1s ease infinite;background-color:currentColor;border-radius:100%;height:8px;margin:6px;width:8px}cx-asm-main-ui .spinner>div:first-child{-webkit-animation-delay:-.2s;animation-delay:-.2s}@-webkit-keyframes spinner-dots-pulse{0%,60%,to{transform:scale(1)}30%{transform:scale(2)}}@keyframes spinner-dots-pulse{0%,60%,to{transform:scale(1)}30%{transform:scale(2)}}cx-asm-main-ui.hidden{display:none}cx-asm-main-ui .asm-bar{background-color:#354a5f;color:#fff;display:flex;height:48px;justify-content:space-between;padding:0 2rem;z-index:1}cx-asm-main-ui .asm-bar-branding{align-items:center;display:flex}cx-asm-main-ui .asm-bar-branding .logo{-webkit-margin-end:8px;margin-inline-end:8px}cx-asm-main-ui .asm-bar-branding .asm-title{font-size:16px;font-weight:700}cx-asm-main-ui .asm-bar-actions{align-items:center;display:flex;justify-content:flex-end}cx-asm-main-ui>:nth-child(2){display:flex;padding:1rem 2rem;width:100%}cx-asm-main-ui input{background-color:#fff;border:1px solid #89919a;border-radius:4px;color:#32363a;height:36px;outline:0;padding:0 12px}cx-asm-main-ui input:focus{box-shadow:0 0 0 1px #fafafa}cx-asm-main-ui input:hover{border-color:#085caf}cx-asm-main-ui input::-moz-placeholder{color:#74777a;font-style:italic}cx-asm-main-ui input:-ms-input-placeholder{color:#74777a;font-style:italic}cx-asm-main-ui input::placeholder{color:#74777a;font-style:italic}@media (max-width:575px){cx-asm-main-ui .asm-bar-branding .asm-title{display:none}cx-asm-main-ui .asm-alert{margin-top:30px}}"]
                },] }
    ];
    AsmMainUiComponent.ctorParameters = function () { return [
        { type: i1.AuthService },
        { type: i1.AsmAuthService },
        { type: i1.UserService },
        { type: AsmComponentService },
        { type: i1.GlobalMessageService },
        { type: i1.RoutingService },
        { type: i1.AsmService }
    ]; };
    AsmMainUiComponent.propDecorators = {
        disabled: [{ type: i0.HostBinding, args: ['class.hidden',] }]
    };

    var AsmSessionTimerComponent = /** @class */ (function () {
        function AsmSessionTimerComponent(config, asmComponentService, authService, routingService, changeDetectorRef) {
            this.config = config;
            this.asmComponentService = asmComponentService;
            this.authService = authService;
            this.routingService = routingService;
            this.changeDetectorRef = changeDetectorRef;
            this.subscriptions = new rxjs.Subscription();
            this.maxStartDelayInSeconds = 60000;
        }
        AsmSessionTimerComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.timeLeft = this.getTimerStartDelayInSeconds();
            this.interval = setInterval(function () {
                if (_this.timeLeft > 0) {
                    _this.timeLeft--;
                }
                else {
                    clearInterval(_this.interval);
                    _this.asmComponentService.logoutCustomerSupportAgentAndCustomer();
                }
                _this.changeDetectorRef.markForCheck();
            }, 1000);
            this.resetOnNavigate();
            this.resetOnCustomerSessionChange();
        };
        AsmSessionTimerComponent.prototype.resetOnNavigate = function () {
            var _this = this;
            this.subscriptions.add(this.routingService.isNavigating().subscribe(function (isNavigating) {
                if (isNavigating) {
                    _this.resetTimer();
                }
            }));
        };
        AsmSessionTimerComponent.prototype.resetOnCustomerSessionChange = function () {
            var _this = this;
            this.subscriptions.add(this.authService
                .getOccUserId()
                .pipe(operators.distinctUntilChanged())
                .subscribe(function () { return _this.resetTimer(); }));
        };
        AsmSessionTimerComponent.prototype.resetTimer = function () {
            if (this.timeLeft > 0) {
                this.timeLeft = this.getTimerStartDelayInSeconds();
            }
        };
        AsmSessionTimerComponent.prototype.getTimerStartDelayInSeconds = function () {
            if (this.config.asm.agentSessionTimer.startingDelayInSeconds >
                this.maxStartDelayInSeconds) {
                return this.maxStartDelayInSeconds;
            }
            else {
                return this.config.asm.agentSessionTimer.startingDelayInSeconds;
            }
        };
        AsmSessionTimerComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
            if (this.interval) {
                clearInterval(this.interval);
            }
        };
        return AsmSessionTimerComponent;
    }());
    AsmSessionTimerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-asm-session-timer',
                    template: "<span class=\"label\">{{ 'asm.agentSessionTimer.label' | cxTranslate }}:</span>\n<span class=\"time\"\n  >{{ timeLeft | formatTimer }}\n  {{ 'asm.agentSessionTimer.minutes' | cxTranslate }}</span\n>\n<button\n  class=\"reset\"\n  title=\"{{ 'asm.agentSessionTimer.reset' | cxTranslate }}\"\n  (click)=\"resetTimer()\"\n></button>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["cx-asm-session-timer{align-items:center;display:flex;height:16px;margin:0 15px}cx-asm-session-timer .label{margin:0 6px}@media (max-width:575px){cx-asm-session-timer .label{display:none}}cx-asm-session-timer .time{font-weight:600}cx-asm-session-timer .reset{background:url(\"data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cpath fill='%23d1e3ff' d='M14.9,7.5l-1,0.2c0.2,0.9,0.1,1.7-0.1,2.5c-0.3,1-0.8,2-1.5,2.7c-1.1,1.1-2.7,1.8-4.2,1.8 c-0.8,0-1.5-0.1-2.3-0.4c-1.5-0.6-2.7-1.8-3.3-3.3C2.1,10.2,2,9.5,2,8.7c0-1.6,0.7-3.1,1.8-4.3c0.7-0.8,1.7-1.3,2.7-1.5 c1-0.3,2-0.2,3,0l0,0v-1c-1-0.2-2.1-0.2-3.1,0C4.2,2.4,2.4,4,1.5,6.1C1.2,6.9,1,7.8,1,8.7c0,0.9,0.2,1.8,0.5,2.6 c0.4,0.9,0.9,1.7,1.5,2.3c0.7,0.7,1.4,1.2,2.3,1.5c0.8,0.3,1.7,0.5,2.6,0.5c0.9,0,1.8-0.2,2.6-0.5c2.1-0.9,3.7-2.7,4.2-5 C15,9.3,15,8.4,14.9,7.5z'/%3E%3Cpolygon fill='%23d1e3ff' points='11.5,2.8 9.2,4.5 9.7,0.5 '/%3E%3C/svg%3E%0A\") no-repeat 50%;background-color:transparent;border:transparent;cursor:pointer;height:16px;margin:0 15px;width:16px}"]
                },] }
    ];
    AsmSessionTimerComponent.ctorParameters = function () { return [
        { type: i1.AsmConfig },
        { type: AsmComponentService },
        { type: i1.AuthService },
        { type: i1.RoutingService },
        { type: i0.ChangeDetectorRef }
    ]; };

    var FormatTimerPipe = /** @class */ (function () {
        function FormatTimerPipe() {
        }
        FormatTimerPipe.prototype.transform = function (totalSeconds) {
            if (totalSeconds < 0) {
                totalSeconds = 0;
            }
            var minutes = Math.floor(totalSeconds / 60);
            var seconds = totalSeconds % 60;
            var zeroPaddedMinutes;
            if (minutes < 10) {
                zeroPaddedMinutes = ('00' + minutes).slice(-2);
            }
            else {
                zeroPaddedMinutes = minutes + '';
            }
            var zeroPaddedSeconds = ('00' + seconds).slice(-2);
            return zeroPaddedMinutes + ":" + zeroPaddedSeconds;
        };
        return FormatTimerPipe;
    }());
    FormatTimerPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'formatTimer',
                },] }
    ];

    var AsmToggleUiComponent = /** @class */ (function () {
        function AsmToggleUiComponent(asmService) {
            this.asmService = asmService;
            this.subscription = new rxjs.Subscription();
        }
        AsmToggleUiComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.asmService.getAsmUiState().subscribe(function (uiState) {
                _this.isCollapsed = uiState.collapsed;
            }));
        };
        AsmToggleUiComponent.prototype.toggleUi = function () {
            this.asmService.updateAsmUiState({ collapsed: !this.isCollapsed });
        };
        AsmToggleUiComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return AsmToggleUiComponent;
    }());
    AsmToggleUiComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-asm-toggle-ui',
                    template: "<a class=\"toggleUi\" (click)=\"toggleUi()\">\n  <span [ngClass]=\"!isCollapsed ? 'collapseIcon' : 'expandIcon'\"></span>\n  <span *ngIf=\"!isCollapsed\" class=\"label\">\n    {{ 'asm.toggleUi.collapse' | cxTranslate }}\n  </span>\n  <span *ngIf=\"isCollapsed\" class=\"label\">\n    {{ 'asm.toggleUi.expand' | cxTranslate }}\n  </span>\n</a>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["cx-asm-toggle-ui{align-items:center;cursor:pointer;display:flex;height:16px;margin:0 15px}cx-asm-toggle-ui .toggleUi{align-items:inherit;display:inherit}cx-asm-toggle-ui .toggleUi .label{-webkit-margin-start:5px;margin-inline-start:5px}@media (max-width:575px){cx-asm-toggle-ui .toggleUi .label{display:none}}cx-asm-toggle-ui .toggleUi .collapseIcon,cx-asm-toggle-ui .toggleUi .expandIcon{height:16px;width:16px}cx-asm-toggle-ui .toggleUi .collapseIcon{background:url(\"data:image/svg+xml,%3Csvg aria-hidden='true' focusable='false' data-prefix='fas' data-icon='chevron-circle-up' class='svg-inline--fa fa-chevron-circle-up fa-w-16' role='img' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath fill='%23d1e3ff' d='M8 256C8 119 119 8 256 8s248 111 248 248-111 248-248 248S8 393 8 256zm231-113.9L103.5 277.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L256 226.9l101.6 101.6c9.4 9.4 24.6 9.4 33.9 0l17-17c9.4-9.4 9.4-24.6 0-33.9L273 142.1c-9.4-9.4-24.6-9.4-34 0z'%3E%3C/path%3E%3C/svg%3E\") 50% no-repeat}cx-asm-toggle-ui .toggleUi .expandIcon{background:url(\"data:image/svg+xml,%3Csvg aria-hidden='true' focusable='false' data-prefix='fas' data-icon='chevron-circle-down' class='svg-inline--fa fa-chevron-circle-down fa-w-16' role='img' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath fill='%23d1e3ff' d='M504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zM273 369.9l135.5-135.5c9.4-9.4 9.4-24.6 0-33.9l-17-17c-9.4-9.4-24.6-9.4-33.9 0L256 285.1 154.4 183.5c-9.4-9.4-24.6-9.4-33.9 0l-17 17c-9.4 9.4-9.4 24.6 0 33.9L239 369.9c9.4 9.4 24.6 9.4 34 0z'%3E%3C/path%3E%3C/svg%3E\") 50% no-repeat}"]
                },] }
    ];
    AsmToggleUiComponent.ctorParameters = function () { return [
        { type: i1.AsmService }
    ]; };

    var CSAgentLoginFormComponent = /** @class */ (function () {
        function CSAgentLoginFormComponent(fb) {
            this.fb = fb;
            this.csAgentTokenLoading = false;
            this.submitEvent = new i0.EventEmitter();
        }
        CSAgentLoginFormComponent.prototype.ngOnInit = function () {
            this.csAgentLoginForm = this.fb.group({
                userId: ['', [forms.Validators.required]],
                password: ['', [forms.Validators.required]],
            });
        };
        CSAgentLoginFormComponent.prototype.onSubmit = function () {
            if (this.csAgentLoginForm.valid) {
                this.submitEvent.emit({
                    userId: this.csAgentLoginForm.get('userId').value,
                    password: this.csAgentLoginForm.get('password').value,
                });
            }
            else {
                this.csAgentLoginForm.markAllAsTouched();
            }
        };
        return CSAgentLoginFormComponent;
    }());
    CSAgentLoginFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-csagent-login-form',
                    template: "<form\n  (ngSubmit)=\"onSubmit()\"\n  [formGroup]=\"csAgentLoginForm\"\n  *ngIf=\"!csAgentTokenLoading\"\n>\n  <label>\n    <input\n      type=\"text\"\n      formControlName=\"userId\"\n      placeholder=\"{{ 'asm.loginForm.userId.label' | cxTranslate }}\"\n    />\n    <cx-form-errors [control]=\"csAgentLoginForm.get('userId')\"></cx-form-errors>\n  </label>\n\n  <label>\n    <input\n      type=\"password\"\n      placeholder=\"{{ 'asm.loginForm.password.label' | cxTranslate }}\"\n      formControlName=\"password\"\n    />\n    <cx-form-errors\n      [control]=\"csAgentLoginForm.get('password')\"\n    ></cx-form-errors>\n  </label>\n  <button type=\"submit\">\n    {{ 'asm.loginForm.submit' | cxTranslate }}\n  </button>\n</form>\n\n<div\n  *ngIf=\"csAgentTokenLoading\"\n  class=\"spinner\"\n  aria-hidden=\"false\"\n  aria-label=\"Loading\"\n>\n  <div></div>\n  <div></div>\n  <div></div>\n</div>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["cx-csagent-login-form form{display:flex;width:100%}@media (max-width:575px){cx-csagent-login-form form{flex-direction:column}}cx-csagent-login-form form label{margin:0 0 15px;min-width:auto}@media (min-width:575px){cx-csagent-login-form form label{-webkit-margin-end:15px;-webkit-margin-start:0;margin-bottom:0;margin-inline-end:15px;margin-inline-start:0;margin-top:0;min-width:15rem}}cx-csagent-login-form form label input{width:100%}cx-csagent-login-form button[type=submit]{background-color:#0a6ed1;border-color:#0a6ed1;color:#fff}cx-csagent-login-form button[type=submit]:hover{background-color:#085caf}"]
                },] }
    ];
    CSAgentLoginFormComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    CSAgentLoginFormComponent.propDecorators = {
        csAgentTokenLoading: [{ type: i0.Input }],
        submitEvent: [{ type: i0.Output }]
    };

    var CustomerEmulationComponent = /** @class */ (function () {
        function CustomerEmulationComponent(asmComponentService, userService) {
            this.asmComponentService = asmComponentService;
            this.userService = userService;
            this.subscription = new rxjs.Subscription();
        }
        CustomerEmulationComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.userService.get().subscribe(function (user) { return (_this.customer = user); }));
            this.isCustomerEmulationSessionInProgress$ = this.asmComponentService.isCustomerEmulationSessionInProgress();
        };
        CustomerEmulationComponent.prototype.logoutCustomer = function () {
            this.asmComponentService.logoutCustomer();
        };
        CustomerEmulationComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return CustomerEmulationComponent;
    }());
    CustomerEmulationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-customer-emulation',
                    template: "<ng-container\n  *ngIf=\"\n    isCustomerEmulationSessionInProgress$ | async;\n    else realCustomerSession\n  \"\n>\n  <input\n    formcontrolname=\"customer\"\n    type=\"text\"\n    disabled=\"true\"\n    placeholder=\"{{ customer?.name }}, {{ customer?.uid }}\"\n  />\n  <button (click)=\"logoutCustomer()\">\n    {{ 'asm.endSession' | cxTranslate }}\n  </button>\n</ng-container>\n\n<ng-template #realCustomerSession>\n  <div class=\"asm-alert\" role=\"alert\">\n    {{ 'asm.standardSessionInProgress' | cxTranslate }}\n  </div>\n</ng-template>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: ["cx-customer-emulation{display:flex}@media (max-width:575px){cx-customer-emulation{flex-direction:column}cx-customer-emulation>*{margin-bottom:12px}}@media (min-width:575px){cx-customer-emulation input{flex:1}}cx-customer-emulation button{-webkit-padding-start:35px;background:url(\"data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cpath fill='%23bb0000' d='M14.8,8c0-3.7-3-6.8-6.8-6.8S1.3,4.2,1.3,8s3,6.8,6.8,6.8S14.8,11.7,14.8,8z M2.6,8c0-3,2.4-5.5,5.5-5.5S13.5,5,13.5,8 s-2.4,5.5-5.5,5.5S2.6,11,2.6,8z M10.7,5.8v4.4c0,0.2-0.2,0.4-0.4,0.4H5.9c-0.2,0-0.4-0.2-0.4-0.4V5.8c0-0.2,0.2-0.4,0.4-0.4h4.4 C10.5,5.4,10.7,5.6,10.7,5.8z'/%3E%3C/svg%3E%0A\") no-repeat 10px;border-color:#b00;color:#b00;padding-inline-start:35px}@media (min-width:575px){cx-customer-emulation button{-webkit-margin-start:8px;margin-inline-start:8px}}cx-customer-emulation button:hover{background:url(\"data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Cpath fill='white' d='M14.8,8c0-3.7-3-6.8-6.8-6.8S1.3,4.2,1.3,8s3,6.8,6.8,6.8S14.8,11.7,14.8,8z M2.6,8c0-3,2.4-5.5,5.5-5.5S13.5,5,13.5,8 s-2.4,5.5-5.5,5.5S2.6,11,2.6,8z M10.7,5.8v4.4c0,0.2-0.2,0.4-0.4,0.4H5.9c-0.2,0-0.4-0.2-0.4-0.4V5.8c0-0.2,0.2-0.4,0.4-0.4h4.4 C10.5,5.4,10.7,5.6,10.7,5.8z'/%3E%3C/svg%3E%0A\") no-repeat 10px #b00;color:#fff;fill:#fff}.asm-alert{background-color:#f4f4f4;border:1px solid #89919a;border-radius:4px;color:#32363a;flex:1;padding:9px 12px;text-align:center}"]
                },] }
    ];
    CustomerEmulationComponent.ctorParameters = function () { return [
        { type: AsmComponentService },
        { type: i1.UserService }
    ]; };

    var CustomerSelectionComponent = /** @class */ (function () {
        function CustomerSelectionComponent(fb, asmService, config) {
            this.fb = fb;
            this.asmService = asmService;
            this.config = config;
            this.subscription = new rxjs.Subscription();
            this.submitEvent = new i0.EventEmitter();
        }
        CustomerSelectionComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.customerSelectionForm = this.fb.group({
                searchTerm: ['', forms.Validators.required],
            });
            this.asmService.customerSearchReset();
            this.searchResultsLoading$ = this.asmService.getCustomerSearchResultsLoading();
            this.searchResults = this.asmService.getCustomerSearchResults();
            this.subscription.add(this.customerSelectionForm.controls.searchTerm.valueChanges
                .pipe(operators.debounceTime(300))
                .subscribe(function (searchTermValue) {
                _this.handleSearchTerm(searchTermValue);
            }));
        };
        CustomerSelectionComponent.prototype.handleSearchTerm = function (searchTermValue) {
            if (Boolean(this.selectedCustomer) &&
                searchTermValue !== this.selectedCustomer.name) {
                this.selectedCustomer = undefined;
            }
            if (Boolean(this.selectedCustomer)) {
                return;
            }
            this.asmService.customerSearchReset();
            if (searchTermValue.trim().length >= 3) {
                this.asmService.customerSearch({
                    query: searchTermValue,
                    pageSize: this.config.asm.customerSearch.maxResults,
                });
            }
        };
        CustomerSelectionComponent.prototype.selectCustomerFromList = function (customer) {
            this.selectedCustomer = customer;
            this.customerSelectionForm.controls.searchTerm.setValue(this.selectedCustomer.name);
            this.asmService.customerSearchReset();
        };
        CustomerSelectionComponent.prototype.onSubmit = function () {
            if (this.customerSelectionForm.valid && Boolean(this.selectedCustomer)) {
                this.submitEvent.emit({ customerId: this.selectedCustomer.customerId });
            }
            else {
                this.customerSelectionForm.markAllAsTouched();
            }
        };
        CustomerSelectionComponent.prototype.onDocumentClick = function (event) {
            if (Boolean(this.resultList)) {
                if (this.resultList.nativeElement.contains(event.target) ||
                    this.searchTerm.nativeElement.contains(event.target)) {
                    return;
                }
                else {
                    this.asmService.customerSearchReset();
                }
            }
        };
        CustomerSelectionComponent.prototype.closeResults = function () {
            this.asmService.customerSearchReset();
        };
        CustomerSelectionComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.asmService.customerSearchReset();
        };
        return CustomerSelectionComponent;
    }());
    CustomerSelectionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-customer-selection',
                    template: "<form (ngSubmit)=\"onSubmit()\" [formGroup]=\"customerSelectionForm\">\n  <label>\n    <input\n      #searchTerm\n      type=\"text\"\n      formControlName=\"searchTerm\"\n      placeholder=\"{{ 'asm.customerSearch.searchTerm.label' | cxTranslate }}\"\n    />\n    <cx-form-errors\n      [control]=\"customerSelectionForm.get('searchTerm')\"\n    ></cx-form-errors>\n  </label>\n  <button type=\"submit\">\n    {{ 'asm.customerSearch.submit' | cxTranslate }}\n  </button>\n</form>\n\n<div *ngIf=\"searchResults | async as results\" class=\"asm-results\" #resultList>\n  <button\n    *ngFor=\"let result of results.entries\"\n    (click)=\"selectCustomerFromList(result)\"\n  >\n    <span class=\"result-name\">{{ result.name }}</span>\n    <span class=\"result-id\">{{ result.uid }}</span>\n  </button>\n  <button\n    (click)=\"closeResults()\"\n    *ngIf=\"\n      !(searchResultsLoading$ | async) &&\n      searchTerm.value.length >= 3 &&\n      !!results.entries &&\n      results.entries.length <= 0\n    \"\n  >\n    {{ 'asm.customerSearch.noMatch' | cxTranslate }}\n  </button>\n</div>\n\n<div class=\"asm-results\" *ngIf=\"searchResultsLoading$ | async\">\n  <div class=\"spinner\" aria-hidden=\"false\" aria-label=\"Loading\">\n    <div></div>\n    <div></div>\n    <div></div>\n  </div>\n</div>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    // tslint:disable-next-line:no-host-metadata-property
                    host: {
                        '(document:click)': 'onDocumentClick($event)',
                    },
                    styles: ["cx-customer-selection{position:relative}cx-customer-selection form{display:flex;width:100%}@media (max-width:575px){cx-customer-selection form{flex-direction:column}}cx-customer-selection form label{margin:0 0 15px;min-width:auto}@media (min-width:575px){cx-customer-selection form label{-webkit-margin-end:15px;margin-inline-end:15px;min-width:20rem}}cx-customer-selection form label input{width:100%}cx-customer-selection form button[type=submit]{-webkit-padding-start:35px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAKtmlDQ1BEaXNwbGF5AABIx62Wd1BT+RbHf/fe9EILICAl9N6lSwk9dOkgKiEJJJQYEoKIDZHFFVwLKiKgrugiRcFGkbUgFiwsgg2sC7IoqOtiwYbKu8Aj7L6Z98ebeWfm3N9nzpzf+Z1z7/3NfAGgApZQmA7LAZAhyBKF+3nSY+Pi6fghAAEYEIE+cGaxxUJGWFgQQG12/ad9uIdmo3bbfKoW+N9MnsMVswGAwlBO4ojZGSifQv0ZWyjKAgCpROO6K7KEU9yOsqIIbRDlO1OcMsMjU5w0w1+ncyLDvQDAoFMRKCyWKAUAijoap2ezU9A6lIUoWwk4fAHKU/26sXksDspHUDbLyFg+xf0oGyX9rU7KP2omSWuyWClSnpll2gjefLEwnbUS/L8tI10ye4YB6hSeyD8cXWXQd9aftjxQyoKkkNBZ5nOm86eZJ/GPmmW22Ct+ljks70Dp3vSQoFlO5vsypXWymJGzzBX7RMyyaHm49KxkkRdjllmiuXMlaVHSOI/LlNbP5UXGzHI2PzpklsVpEYFzOV7SuEgSLu2fK/DznDvXVzp7hvhv8/KZ0r1ZvEh/6eysuf65AsZcTXGstDcO19tnLidKmi/M8pSeJUwPk+Zz0/2kcXF2hHRvFvpDzu0Nk77DVFZA2CwDfxAG6MAGWIEcwAcgi5uTNTWE13LhShE/hZdFZ6C3i0tnCtgWZnQbK2snAKbu6syv8K5/+g5CyoS5WGY+AE7ofUCC52JLFwNwvAEAhdC5mMFn9Mqg3+DsdrZElD0Tw0w9sIAEZIEiUAWaQBcYAXO0O3vgAjyADwgAoSASxIGlgA14IAOIwAqwGqwHhaAYbAO7QDnYDw6CGnAUnAAt4Ay4AK6AG6AH3AUPwQAYBi/BGPgAJiAIwkNUiAapQlqQPmQK2UCOkBvkAwVB4VAclAilQAJIAq2GNkDFUAlUDh2AaqHj0GnoAnQN6oXuQ4PQKPQW+gIjMAVWhDVgA9gSdoQZcCAcCS+BU+BMOBcugLfAZXAVfARuhi/AN+C78AD8Eh5HAEJGlBFtxBxxRLyQUCQeSUZEyFqkCClFqpAGpA3pRG4jA8gr5DMGh6Fh6BhzjAvGHxOFYWMyMWsxmzHlmBpMM+YS5jZmEDOG+Y6lYtWxplhnLBMbi03BrsAWYkux1dgm7GXsXeww9gMOh1PGGeIccP64OFwqbhVuM24vrhHXjuvFDeHG8Xi8Kt4U74oPxbPwWfhC/B78Efx5/C38MP4TgUzQItgQfAnxBAEhn1BKqCOcI9wiPCdMEOWI+kRnYiiRQ1xJ3Eo8RGwj3iQOEydI8iRDkispkpRKWk8qIzWQLpMekd6RyWQdshN5EZlPziOXkY+Rr5IHyZ8pChQTihclgSKhbKEcprRT7lPeUalUA6oHNZ6aRd1CraVepD6hfpKhyVjIMGU4MutkKmSaZW7JvJYlyurLMmSXyubKlsqelL0p+0qOKGcg5yXHklsrVyF3Wq5PblyeJm8tHyqfIb9Zvk7+mvyIAl7BQMFHgaNQoHBQ4aLCEA2h6dK8aGzaBtoh2mXasCJO0VCRqZiqWKx4VLFbcUxJQWmBUrRSjlKF0lmlAWVE2UCZqZyuvFX5hPI95S/zNOYx5nHnbZrXMO/WvI8q81U8VLgqRSqNKndVvqjSVX1U01S3q7aoPlbDqJmoLVJbobZP7bLaq/mK813ms+cXzT8x/4E6rG6iHq6+Sv2gepf6uIamhp+GUGOPxkWNV5rKmh6aqZo7Nc9pjmrRtNy0+Fo7tc5rvaAr0Rn0dHoZ/RJ9TFtd219bon1Au1t7QsdQJ0onX6dR57EuSddRN1l3p26H7piell6w3mq9er0H+kR9R32e/m79Tv2PBoYGMQYbDVoMRgxVDJmGuYb1ho+MqEbuRplGVUZ3jHHGjsZpxnuNe0xgEzsTnkmFyU1T2NTelG+617TXDGvmZCYwqzLrM6eYM8yzzevNBy2ULYIs8i1aLF5b6lnGW2637LT8bmVnlW51yOqhtYJ1gHW+dZv1WxsTG7ZNhc0dW6qtr+0621bbNwtMF3AX7FvQb0ezC7bbaNdh983ewV5k32A/6qDnkOhQ6dDnqOgY5rjZ8aoT1snTaZ3TGafPzvbOWc4nnP9yMXdJc6lzGVlouJC78NDCIVcdV5brAdcBN7pbotvPbgPu2u4s9yr3px66HhyPao/nDGNGKuMI47WnlafIs8nzo5ez1xqvdm/E28+7yLvbR8Enyqfc54mvjm+Kb73vmJ+d3yq/dn+sf6D/dv8+pgaTzaxljgU4BKwJuBRICYwILA98GmQSJApqC4aDA4J3BD8K0Q8RhLSEglBm6I7Qx2GGYZlhvy7CLQpbVLHoWbh1+OrwzghaxLKIuogPkZ6RWyMfRhlFSaI6omWjE6Jroz/GeMeUxAzEWsauib0RpxbHj2uNx8dHx1fHjy/2Wbxr8XCCXUJhwr0lhktyllxbqrY0fenZZbLLWMtOJmITYxLrEr+yQllVrPEkZlJl0hjbi72b/ZLjwdnJGeW6cku4z5Ndk0uSR1JcU3akjPLceaW8V3wvfjn/Tap/6v7Uj2mhaYfTJtNj0hszCBmJGacFCoI0waXlmstzlvcKTYWFwoFM58xdmWOiQFG1GBIvEbdmKaKiqEtiJPlBMpjtll2R/WlF9IqTOfI5gpyulSYrN618nuub+8sqzCr2qo7V2qvXrx5cw1hzYC20NmltxzrddQXrhvP88mrWk9anrf8t3yq/JP/9hpgNbQUaBXkFQz/4/VBfKFMoKuzb6LJx/4+YH/k/dm+y3bRn0/ciTtH1Yqvi0uKvm9mbr/9k/VPZT5Nbkrd0b7Xfum8bbptg273t7ttrSuRLckuGdgTvaN5J31m08/2uZbuulS4o3b+btFuye6AsqKx1j96ebXu+lvPK71Z4VjRWqlduqvy4l7P31j6PfQ37NfYX7//yM//n/gN+B5qrDKpKD+IOZh98dij6UOcvjr/UVqtVF1d/Oyw4PFATXnOp1qG2tk69bms9XC+pHz2ScKTnqPfR1gbzhgONyo3Fx8AxybEXxxOP3zsReKLjpOPJhlP6pyqbaE1FzVDzyuaxFl7LQGtca+/pgNMdbS5tTb9a/Hr4jPaZirNKZ7eeI50rODd5Pvf8eLuw/dWFlAtDHcs6Hl6MvXjn0qJL3ZcDL1+94nvlYiej8/xV16tnrjlfO33d8XrLDfsbzV12XU2/2f3W1G3f3XzT4WZrj1NPW+/C3nO33G9duO19+8od5p0bd0Pu9t6Lutffl9A30M/pH7mffv/Ng+wHEw/zHmEfFT2We1z6RP1J1e/GvzcO2A+cHfQe7Hoa8fThEHvo5R/iP74OFzyjPit9rvW8dsRm5Myo72jPi8Uvhl8KX068KvxT/s/K10avT/3l8VfXWOzY8BvRm8m3m9+pvjv8fsH7jvGw8ScfMj5MfCz6pPqp5rPj584vMV+eT6z4iv9a9s34W9v3wO+PJjMmJ4UsEWtaCiCow8nJALw9DAA1DgBaDwCkxTNaetqgGf0/TeC/8YzenjZ7AA55ABCJ6vkQdN2HukEeqklQD5uKewDY1lbq/zZxsq3NTC1yCypNSicn36GaBW8MwLe+ycmJlsnJb9Vosw8AaP8wo+GnTGcMlfreU9SdM5H3n1r6X/dYEDmGJmdAAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGL2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIGV4aWY6UGl4ZWxYRGltZW5zaW9uPSIyNSIgZXhpZjpQaXhlbFlEaW1lbnNpb249IjI3IiB4bXA6Q3JlYXRlRGF0ZT0iMjAxOS0wOS0yNVQxMjoyODo1MS0wNDowMCIgeG1wOk1vZGlmeURhdGU9IjIwMTktMDktMjVUMTI6MzI6MjAtMDQ6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTktMDktMjVUMTI6MzI6MjAtMDQ6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0iRGlzcGxheSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowZTIyOTVhMC0yYWY0LTQ2Y2UtOThlNy0zZTU2YTM0YjFkZjUiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozYmMzNWI0YS0wNjkxLTRmNDEtODk5OC1lYWFmOTI2NGQ2NmMiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpjZWE4Y2FhMC0yMGU1LTQzN2ItYmQ5YS03YjlmMGZiNmYyZTYiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjZWE4Y2FhMC0yMGU1LTQzN2ItYmQ5YS03YjlmMGZiNmYyZTYiIHN0RXZ0OndoZW49IjIwMTktMDktMjVUMTI6MzI6MjAtMDQ6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowZTIyOTVhMC0yYWY0LTQ2Y2UtOThlNy0zZTU2YTM0YjFkZjUiIHN0RXZ0OndoZW49IjIwMTktMDktMjVUMTI6MzI6MjAtMDQ6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PuzZx/kAAAEoSURBVDjLY/z//z8DNQATA5UAhkGNe+f8f/757f+09e2kORXkNWR86P75/zCw7cax/6o9If/R1WDDOA368/cvmH7/7dP/tHXt/8k2KGlNy/8dN4/DXbf95rH/anhch9Mgz/kFYE3p6zv+f/j+GSwGokF8sgwCYZBLQC6CAZBL0V1HlEEwnLquDRxmMNfFrmyAqyEpHd1+85jh5Zd3YDYfOzeDlrgi4ehHdpFYi8f/KcdW///7DxKTQAP/e8zLJ81rfgtL/j949wws9vvvn/+9h5f9F212/090YEetqP2/+Nx2eABfeHbrv/WMNNKj/8fvX2D6+++f/+t3z/ov2Ojyn6wECQJHHlz8bzgplrws0rBn9v9XX97/L9zS/5+vwYkoQ0CYcdCVRwBmUrSjUTYI3gAAAABJRU5ErkJggg==) no-repeat 10px #0a7e3e;border-color:#0a7e3e;color:#fff;padding-inline-start:35px}cx-customer-selection .spinner{align-items:center;height:42px}cx-customer-selection .asm-results{background-color:#fff;border:1px solid #89919a;border-radius:4px;box-shadow:0 5px 20px 0 #d9d9d9,0 2px 8px 0 #ededed;left:2rem;line-height:1.5rem;max-width:50vw;position:absolute;top:4rem;width:100%;z-index:11}@media (max-width:1200px){cx-customer-selection .asm-results{max-width:calc(100% - 4rem)}}cx-customer-selection .asm-results button{-moz-appearance:none;-moz-user-select:none;-ms-user-select:none;-webkit-appearance:none;-webkit-user-select:none;align-items:flex-start;appearance:none;background-color:transparent;border:0;color:#51555a;cursor:pointer;display:flex;flex-direction:column;justify-content:flex-start;margin:0;outline:0;padding:10px;text-decoration:none;user-select:none;vertical-align:middle;white-space:nowrap;width:100%}@media (min-width:767px){cx-customer-selection .asm-results button{flex-direction:row}}cx-customer-selection .asm-results button:hover{background-color:#d3d6db;color:#32363a}cx-customer-selection .asm-results button span{-webkit-margin-end:15px;-webkit-margin-start:0;margin-bottom:0;margin-inline-end:15px;margin-inline-start:0;margin-top:0;text-align:start;white-space:normal;word-break:break-all}@media (min-width:575px){cx-customer-selection .asm-results button span:last-of-type{margin:0}}"]
                },] }
    ];
    CustomerSelectionComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder },
        { type: i1.AsmService },
        { type: i1.AsmConfig }
    ]; };
    CustomerSelectionComponent.propDecorators = {
        submitEvent: [{ type: i0.Output }],
        resultList: [{ type: i0.ViewChild, args: ['resultList',] }],
        searchTerm: [{ type: i0.ViewChild, args: ['searchTerm',] }]
    };

    var defaultAsmLayoutConfig = {
        launch: {
            ASM: {
                outlet: 'cx-storefront',
                component: AsmMainUiComponent,
            },
        },
    };

    var AsmModule = /** @class */ (function () {
        function AsmModule() {
        }
        return AsmModule;
    }());
    AsmModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        i1.I18nModule,
                        i1.AsmModule.forRoot(),
                        AsmLoaderModule,
                        FormErrorsModule,
                    ],
                    declarations: [
                        AsmMainUiComponent,
                        CSAgentLoginFormComponent,
                        CustomerSelectionComponent,
                        AsmSessionTimerComponent,
                        FormatTimerPipe,
                        CustomerEmulationComponent,
                        AsmToggleUiComponent,
                    ],
                    providers: [i1.provideConfig(defaultAsmLayoutConfig)],
                    entryComponents: [AsmMainUiComponent],
                },] }
    ];

    var CurrentProductService = /** @class */ (function () {
        function CurrentProductService(routingService, productService) {
            this.routingService = routingService;
            this.productService = productService;
            this.DEFAULT_PRODUCT_SCOPE = i1.ProductScope.DETAILS;
        }
        /**
         * Will emit current product or null, if there is no current product (i.e. we are not on PDP)
         *
         * @param scopes
         */
        CurrentProductService.prototype.getProduct = function (scopes) {
            var _this = this;
            return this.routingService.getRouterState().pipe(operators.map(function (state) { return state.state.params['productCode']; }), operators.switchMap(function (productCode) {
                return productCode
                    ? _this.productService.get(productCode, scopes || _this.DEFAULT_PRODUCT_SCOPE)
                    : rxjs.of(null);
            }), operators.filter(function (x) { return x !== undefined; }), operators.distinctUntilChanged());
        };
        return CurrentProductService;
    }());
    CurrentProductService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CurrentProductService_Factory() { return new CurrentProductService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.ProductService)); }, token: CurrentProductService, providedIn: "root" });
    CurrentProductService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CurrentProductService.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.ProductService }
    ]; };

    var AddedToCartDialogComponent = /** @class */ (function () {
        function AddedToCartDialogComponent(modalService, cartService, promotionService) {
            this.modalService = modalService;
            this.cartService = cartService;
            this.promotionService = promotionService;
            this.iconTypes = exports.ICON_TYPE;
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
            this.quantity = 0;
            this.modalIsOpen = false;
            this.form = new forms.FormGroup({});
        }
        /**
         * Returns an observable formControl with the quantity of the cartEntry,
         * but also updates the entry in case of a changed value.
         * The quantity can be set to zero in order to remove the entry.
         */
        AddedToCartDialogComponent.prototype.getQuantityControl = function () {
            var _this = this;
            if (!this.quantityControl$) {
                this.quantityControl$ = this.entry$.pipe(operators.filter(function (e) { return !!e; }), operators.map(function (entry) { return _this.getFormControl(entry); }), operators.switchMap(function () { return _this.form.valueChanges.pipe(
                // tslint:disable-next-line:deprecation
                operators.startWith(null), operators.tap(function (valueChange) {
                    if (valueChange) {
                        _this.cartService.updateEntry(valueChange.entryNumber, valueChange.quantity);
                        if (valueChange.quantity === 0) {
                            _this.dismissModal('Removed');
                        }
                    }
                    else {
                        _this.form.markAsPristine();
                    }
                })); }), operators.map(function () { return _this.form.get('quantity'); }));
            }
            return this.quantityControl$;
        };
        AddedToCartDialogComponent.prototype.ngOnInit = function () {
            this.orderPromotions$ = this.promotionService.getOrderPromotions(this.promotionLocation);
        };
        AddedToCartDialogComponent.prototype.getFormControl = function (entry) {
            if (!this.form.get('quantity')) {
                var quantity = new forms.FormControl(entry.quantity, { updateOn: 'blur' });
                this.form.addControl('quantity', quantity);
                var entryNumber = new forms.FormControl(entry.entryNumber);
                this.form.addControl('entryNumber', entryNumber);
            }
            return this.form.get('quantity');
        };
        AddedToCartDialogComponent.prototype.dismissModal = function (reason) {
            this.modalService.dismissActiveModal(reason);
        };
        return AddedToCartDialogComponent;
    }());
    AddedToCartDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-added-to-cart-dialog',
                    template: "<div #dialog>\n  <!-- Modal Header -->\n  <ng-container *ngIf=\"(loaded$ | async) || modalIsOpen; else loading\">\n    <div class=\"cx-dialog-header modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{\n          (increment\n            ? 'addToCart.itemsIncrementedInYourCart'\n            : 'addToCart.itemsAddedToYourCart'\n          ) | cxTranslate\n        }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        aria-label=\"Close\"\n        (click)=\"dismissModal('Cross click')\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\" *ngIf=\"entry$ | async as entry\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"cx-dialog-item col-sm-12 col-md-6\">\n          <cx-cart-item\n            [item]=\"entry\"\n            [compact]=\"true\"\n            [quantityControl]=\"getQuantityControl() | async\"\n            [promotionLocation]=\"promotionLocation\"\n            (view)=\"dismissModal('Product selected')\"\n          ></cx-cart-item>\n        </div>\n        <!-- Separator -->\n        <div\n          class=\"cx-dialog-separator col-sm-12 d-xs-block d-sm-block d-md-none\"\n        ></div>\n        <!-- Total container -->\n        <div class=\"cx-dialog-actions col-sm-12 col-md-6\">\n          <div class=\"cx-dialog-total\" *ngIf=\"cart$ | async as cart\">\n            <div>\n              {{\n                'cartItems.cartTotal'\n                  | cxTranslate: { count: cart.deliveryItemsQuantity }\n              }}\n            </div>\n\n            <div>{{ cart.subTotal?.formattedValue }}</div>\n          </div>\n\n          <!-- Promotions -->\n          <div\n            class=\"cx-dialog-promotions\"\n            *ngIf=\"orderPromotions$ | async as orderPromotions\"\n          >\n            <cx-promotions [promotions]=\"orderPromotions\"></cx-promotions>\n          </div>\n\n          <!-- Actions -->\n          <div class=\"cx-dialog-buttons\">\n            <a\n              [class.disabled]=\"form.dirty\"\n              [routerLink]=\"{ cxRoute: 'cart' } | cxUrl\"\n              class=\"btn btn-primary\"\n              autofocus\n              (click)=\"!form.dirty && dismissModal('View Cart click')\"\n              >{{ 'addToCart.viewCart' | cxTranslate }}</a\n            >\n            <a\n              [class.disabled]=\"form.dirty\"\n              [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n              class=\"btn btn-secondary\"\n              (click)=\"!form.dirty && dismissModal('Proceed To Checkout click')\"\n              >{{ 'addToCart.proceedToCheckout' | cxTranslate }}</a\n            >\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"cx-dialog-header modal-header\">\n      <div class=\"cx-dialog-title modal-title\">\n        {{ 'addToCart.updatingCart' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        aria-label=\"Close\"\n        (click)=\"dismissModal('Cross click')\"\n      >\n        <span aria-hidden=\"true\">\n          <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n        </span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <div class=\"cx-dialog-body modal-body\">\n      <div class=\"cx-dialog-row\">\n        <div class=\"col-sm-12\"><cx-spinner></cx-spinner></div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n"
                },] }
    ];
    AddedToCartDialogComponent.ctorParameters = function () { return [
        { type: ModalService },
        { type: i1.ActiveCartService },
        { type: PromotionService }
    ]; };
    AddedToCartDialogComponent.propDecorators = {
        dialog: [{ type: i0.ViewChild, args: ['dialog', { read: i0.ElementRef },] }]
    };

    var AddToCartComponent = /** @class */ (function () {
        function AddToCartComponent(modalService, currentProductService, cd, activeCartService) {
            this.modalService = modalService;
            this.currentProductService = currentProductService;
            this.cd = cd;
            this.activeCartService = activeCartService;
            this.showQuantity = true;
            this.hasStock = false;
            this.quantity = 1;
            this.increment = false;
            this.addToCartForm = new forms.FormGroup({
                quantity: new forms.FormControl(1),
            });
        }
        AddToCartComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this.product) {
                this.productCode = this.product.code;
                this.cartEntry$ = this.activeCartService.getEntry(this.productCode);
                this.setStockInfo(this.product);
                this.cd.markForCheck();
            }
            else if (this.productCode) {
                this.cartEntry$ = this.activeCartService.getEntry(this.productCode);
                // force hasStock and quantity for the time being, as we do not have more info:
                this.quantity = 1;
                this.hasStock = true;
                this.cd.markForCheck();
            }
            else {
                this.subscription = this.currentProductService
                    .getProduct()
                    .pipe(operators.filter(Boolean))
                    .subscribe(function (product) {
                    _this.productCode = product.code;
                    _this.setStockInfo(product);
                    _this.cartEntry$ = _this.activeCartService.getEntry(_this.productCode);
                    _this.cd.markForCheck();
                });
            }
        };
        AddToCartComponent.prototype.setStockInfo = function (product) {
            this.quantity = 1;
            this.hasStock =
                product.stock && product.stock.stockLevelStatus !== 'outOfStock';
            if (this.hasStock && product.stock.stockLevel) {
                this.maxQuantity = product.stock.stockLevel;
            }
        };
        AddToCartComponent.prototype.updateCount = function (value) {
            this.quantity = value;
        };
        AddToCartComponent.prototype.addToCart = function () {
            var _this = this;
            var quantity = this.addToCartForm.get('quantity').value;
            if (!this.productCode || quantity <= 0) {
                return;
            }
            // check item is already present in the cart
            // so modal will have proper header text displayed
            this.activeCartService
                .getEntry(this.productCode)
                .subscribe(function (entry) {
                if (entry) {
                    _this.increment = true;
                }
                _this.openModal();
                _this.activeCartService.addEntry(_this.productCode, quantity);
                _this.increment = false;
            })
                .unsubscribe();
        };
        AddToCartComponent.prototype.openModal = function () {
            var modalInstance;
            this.modalRef = this.modalService.open(AddedToCartDialogComponent, {
                centered: true,
                size: 'lg',
            });
            modalInstance = this.modalRef.componentInstance;
            modalInstance.entry$ = this.cartEntry$;
            modalInstance.cart$ = this.activeCartService.getActive();
            modalInstance.loaded$ = this.activeCartService.isStable();
            modalInstance.quantity = this.quantity;
            modalInstance.increment = this.increment;
        };
        AddToCartComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return AddToCartComponent;
    }());
    AddToCartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-add-to-cart',
                    template: "<form *ngIf=\"productCode\" [formGroup]=\"addToCartForm\" (submit)=\"addToCart()\">\n  <div class=\"quantity\" *ngIf=\"showQuantity\">\n    <label>{{ 'addToCart.quantity' | cxTranslate }}</label>\n    <cx-item-counter\n      *ngIf=\"hasStock\"\n      [max]=\"maxQuantity\"\n      [control]=\"addToCartForm.get('quantity')\"\n    ></cx-item-counter>\n    <span class=\"info\">{{\n      hasStock\n        ? ('addToCart.inStock' | cxTranslate)\n        : ('addToCart.outOfStock' | cxTranslate)\n    }}</span>\n  </div>\n\n  <button\n    *ngIf=\"hasStock\"\n    class=\"btn btn-primary btn-block\"\n    type=\"submit\"\n    [disabled]=\"quantity <= 0 || quantity > maxQuantity\"\n  >\n    {{ 'addToCart.addToCart' | cxTranslate }}\n  </button>\n</form>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    AddToCartComponent.ctorParameters = function () { return [
        { type: ModalService },
        { type: CurrentProductService },
        { type: i0.ChangeDetectorRef },
        { type: i1.ActiveCartService }
    ]; };
    AddToCartComponent.propDecorators = {
        productCode: [{ type: i0.Input }],
        showQuantity: [{ type: i0.Input }],
        product: [{ type: i0.Input }]
    };

    var PromotionsComponent = /** @class */ (function () {
        function PromotionsComponent() {
        }
        return PromotionsComponent;
    }());
    PromotionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-promotions',
                    template: "<div class=\"cx-promotions\" *ngIf=\"promotions\">\n  <ul *ngFor=\"let promotion of promotions\">\n    <li>{{ promotion.description }}</li>\n  </ul>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PromotionsComponent.ctorParameters = function () { return []; };
    PromotionsComponent.propDecorators = {
        promotions: [{ type: i0.Input }]
    };

    var PromotionsModule = /** @class */ (function () {
        function PromotionsModule() {
        }
        return PromotionsModule;
    }());
    PromotionsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [PromotionsComponent],
                    exports: [PromotionsComponent],
                },] }
    ];

    var AppliedCouponsComponent = /** @class */ (function () {
        function AppliedCouponsComponent(cartVoucherService) {
            this.cartVoucherService = cartVoucherService;
            this.cartIsLoading = false;
            this.isReadOnly = false;
            this.iconTypes = exports.ICON_TYPE;
        }
        Object.defineProperty(AppliedCouponsComponent.prototype, "sortedVouchers", {
            get: function () {
                this.vouchers = this.vouchers || [];
                return this.vouchers.slice().sort(function (a, b) {
                    return a.code.localeCompare(b.code);
                });
            },
            enumerable: false,
            configurable: true
        });
        AppliedCouponsComponent.prototype.removeVoucher = function (voucherId) {
            this.cartVoucherService.removeVoucher(voucherId);
        };
        return AppliedCouponsComponent;
    }());
    AppliedCouponsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-applied-coupons',
                    template: "<div *ngIf=\"isReadOnly; else editableCoupons\">\n  <div *ngIf=\"sortedVouchers.length > 0\">\n    <div class=\"cx-applied-coupon-title\">\n      {{ 'voucher.vouchersApplied' | cxTranslate }}\n    </div>\n  </div>\n  <div\n    *ngFor=\"let voucher of sortedVouchers\"\n    class=\"coupon-summary cx-coupon-card textonly\"\n    role=\"filter\"\n  >\n    <span class=\"cx-applied-coupon-code\">{{ voucher.voucherCode }}</span>\n  </div>\n</div>\n\n<ng-template #editableCoupons>\n  <div class=\"row\">\n    <div\n      *ngFor=\"let voucher of sortedVouchers\"\n      class=\"col-sm-12 col-md-6 col-lg-12 cx-coupon-card-grid\"\n      role=\"filter\"\n    >\n      <div class=\"cx-coupon-apply cx-coupon-card cx-coupon-list-wrap\">\n        <span class=\"cx-cart-coupon-code\">{{ voucher.voucherCode }}</span>\n        <button\n          type=\"button\"\n          class=\"close\"\n          aria-label=\"Close\"\n          (click)=\"removeVoucher(voucher.voucherCode)\"\n          [disabled]=\"cartIsLoading\"\n          [class.disabled]=\"cartIsLoading\"\n        >\n          <span aria-hidden=\"true\">\n            <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n          </span>\n        </button>\n      </div>\n    </div>\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    AppliedCouponsComponent.ctorParameters = function () { return [
        { type: i1.CartVoucherService }
    ]; };
    AppliedCouponsComponent.propDecorators = {
        vouchers: [{ type: i0.Input }],
        cartIsLoading: [{ type: i0.Input }],
        isReadOnly: [{ type: i0.Input }]
    };

    var CartCouponComponent = /** @class */ (function () {
        function CartCouponComponent(cartVoucherService, formBuilder, customerCouponService, activeCartService) {
            this.cartVoucherService = cartVoucherService;
            this.formBuilder = formBuilder;
            this.customerCouponService = customerCouponService;
            this.activeCartService = activeCartService;
            this.MAX_CUSTOMER_COUPON_PAGE = 100;
            this.ignoreCloseEvent = false;
            this.subscription = new rxjs.Subscription();
            this.couponBoxIsActive = false;
        }
        CartCouponComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this.customerCouponService) {
                this.customerCouponService.loadCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE);
            }
            this.cart$ = rxjs.combineLatest([
                this.activeCartService.getActive(),
                this.activeCartService.getActiveCartId(),
                this.customerCouponService.getCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE),
            ]).pipe(operators.tap(function (_a) {
                var _b = __read(_a, 3), cart = _b[0], activeCardId = _b[1], customerCoupons = _b[2];
                _this.cartId = activeCardId;
                _this.getApplicableCustomerCoupons(cart, customerCoupons.coupons);
            }), operators.map(function (_a) {
                var _b = __read(_a, 1), cart = _b[0];
                return cart;
            }));
            this.cartIsLoading$ = this.activeCartService
                .isStable()
                .pipe(operators.map(function (loaded) { return !loaded; }));
            this.cartVoucherService.resetAddVoucherProcessingState();
            this.couponForm = this.formBuilder.group({
                couponCode: ['', [forms.Validators.required]],
            });
            // TODO(#7241): Replace process subscriptions with event listeners and drop process for ADD_VOUCHER
            this.subscription.add(this.cartVoucherService
                .getAddVoucherResultSuccess()
                .subscribe(function (success) {
                _this.onSuccess(success);
            }));
            // TODO(#7241): Replace process subscriptions with event listeners and drop process for ADD_VOUCHER
            this.subscription.add(this.cartVoucherService.getAddVoucherResultError().subscribe(function (error) {
                _this.onError(error);
            }));
        };
        CartCouponComponent.prototype.onError = function (error) {
            if (error) {
                this.customerCouponService.loadCustomerCoupons(this.MAX_CUSTOMER_COUPON_PAGE);
                this.cartVoucherService.resetAddVoucherProcessingState();
            }
        };
        CartCouponComponent.prototype.onSuccess = function (success) {
            if (success) {
                this.couponForm.reset();
                this.cartVoucherService.resetAddVoucherProcessingState();
            }
        };
        CartCouponComponent.prototype.getApplicableCustomerCoupons = function (cart, coupons) {
            var _this = this;
            this.applicableCoupons = coupons || [];
            if (cart.appliedVouchers) {
                cart.appliedVouchers.forEach(function (appliedVoucher) {
                    _this.applicableCoupons = _this.applicableCoupons.filter(function (coupon) { return coupon.couponId !== appliedVoucher.code; });
                });
            }
        };
        CartCouponComponent.prototype.applyVoucher = function () {
            if (this.couponForm.valid) {
                this.cartVoucherService.addVoucher(this.couponForm.value.couponCode, this.cartId);
            }
            else {
                this.couponForm.markAllAsTouched();
            }
        };
        CartCouponComponent.prototype.applyCustomerCoupon = function (couponId) {
            this.cartVoucherService.addVoucher(couponId, this.cartId);
            this.couponBoxIsActive = false;
        };
        CartCouponComponent.prototype.close = function (event) {
            if (!this.ignoreCloseEvent) {
                this.couponBoxIsActive = false;
                if (event && event.target) {
                    event.target.blur();
                }
            }
            this.ignoreCloseEvent = false;
        };
        CartCouponComponent.prototype.disableClose = function () {
            this.ignoreCloseEvent = true;
        };
        CartCouponComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
            this.cartVoucherService.resetAddVoucherProcessingState();
        };
        return CartCouponComponent;
    }());
    CartCouponComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cart-coupon',
                    template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <div class=\"cx-cart-coupon-title\">\n    {{ 'voucher.coupon' | cxTranslate }}\n  </div>\n  <div class=\"form-group\">\n    <form (ngSubmit)=\"applyVoucher()\" [formGroup]=\"couponForm\">\n      <div class=\"cx-cart-coupon-container\">\n        <input\n          type=\"text\"\n          class=\"form-control input-coupon-code\"\n          formControlName=\"couponCode\"\n          placeholder=\"{{ 'voucher.placeholder' | cxTranslate }}\"\n        />\n        <button\n          class=\"btn btn-block btn-action apply-coupon-button\"\n          type=\"submit\"\n          [disabled]=\"cartIsLoading$ | async\"\n          [class.disabled]=\"cartIsLoading$ | async\"\n        >\n          {{ 'voucher.apply' | cxTranslate }}\n        </button>\n        <cx-form-errors\n          [control]=\"couponForm.get('couponCode')\"\n        ></cx-form-errors>\n      </div>\n    </form>\n  </div>\n\n  <cx-applied-coupons\n    [vouchers]=\"cart.appliedVouchers\"\n    [cartIsLoading]=\"cartIsLoading$ | async\"\n    [isReadOnly]=\"false\"\n  >\n  </cx-applied-coupons>\n\n  <ng-container *ngIf=\"applicableCoupons && applicableCoupons.length > 0\">\n    <div class=\"cx-available-coupon\">\n      <div class=\"title cx-cart-coupon-title\">\n        {{ 'voucher.availableCoupons' | cxTranslate }}\n      </div>\n      <div class=\"message\">\n        {{ 'voucher.availableCouponsLabel' | cxTranslate }}\n      </div>\n      <div class=\"scroll\">\n        <div class=\"coupons card\" *ngFor=\"let coupon of applicableCoupons\">\n          <button\n            (click)=\"applyCustomerCoupon(coupon.couponId)\"\n            class=\"coupon-id link\"\n            [disabled]=\"cartIsLoading$ | async\"\n            [class.disabled]=\"cartIsLoading$ | async\"\n          >\n            {{ coupon.couponId }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n"
                },] }
    ];
    CartCouponComponent.ctorParameters = function () { return [
        { type: i1.CartVoucherService },
        { type: forms.FormBuilder },
        { type: i1.CustomerCouponService },
        { type: i1.ActiveCartService }
    ]; };

    var CartCouponModule = /** @class */ (function () {
        function CartCouponModule() {
        }
        return CartCouponModule;
    }());
    CartCouponModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [CartCouponComponent, AppliedCouponsComponent],
                    exports: [CartCouponComponent, AppliedCouponsComponent],
                    imports: [
                        i1$1.CommonModule,
                        ngSelect.NgSelectModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        i1.I18nModule,
                        IconModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CartApplyCouponComponent: {
                                    component: CartCouponComponent,
                                },
                            },
                        }),
                    ],
                    entryComponents: [CartCouponComponent],
                },] }
    ];

    var CartItemListComponent = /** @class */ (function () {
        function CartItemListComponent(activeCartService, selectiveCartService) {
            this.activeCartService = activeCartService;
            this.selectiveCartService = selectiveCartService;
            this.readonly = false;
            this.hasHeader = true;
            this.options = {
                isSaveForLater: false,
                optionalBtn: null,
            };
            this._items = [];
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
        }
        Object.defineProperty(CartItemListComponent.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                this.resolveItems(items);
                this.createForm();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CartItemListComponent.prototype, "setLoading", {
            set: function (value) {
                if (!this.readonly) {
                    // Whenver the cart is loading, we disable the complete form
                    // to avoid any user interaction with the cart.
                    value
                        ? this.form.disable({ emitEvent: false })
                        : this.form.enable({ emitEvent: false });
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * The items we're getting form the input do not have a consistent model.
         * In case of a `consignmentEntry`, we need to normalize the data from the orderEntry.
         */
        CartItemListComponent.prototype.resolveItems = function (items) {
            if (items.every(function (item) { return item.hasOwnProperty('orderEntry'); })) {
                this._items = items.map(function (consignmentEntry) {
                    var entry = Object.assign({}, consignmentEntry.orderEntry);
                    entry.quantity = consignmentEntry.quantity;
                    return entry;
                });
            }
            else {
                this._items = items;
            }
        };
        CartItemListComponent.prototype.createForm = function () {
            var _this = this;
            this.form = new forms.FormGroup({});
            this._items.forEach(function (item) {
                var code = item.product.code;
                var group = new forms.FormGroup({
                    entryNumber: new forms.FormControl(item.entryNumber),
                    quantity: new forms.FormControl(item.quantity, { updateOn: 'blur' }),
                });
                if (!item.updateable || _this.readonly) {
                    group.disable();
                }
                _this.form.addControl(code, group);
            });
        };
        CartItemListComponent.prototype.removeEntry = function (item) {
            if (this.selectiveCartService && this.options.isSaveForLater) {
                this.selectiveCartService.removeEntry(item);
            }
            else {
                this.activeCartService.removeEntry(item);
            }
            delete this.form.controls[item.product.code];
        };
        CartItemListComponent.prototype.getControl = function (item) {
            var _this = this;
            return this.form.get(item.product.code).valueChanges.pipe(
            // tslint:disable-next-line:deprecation
            operators.startWith(null), operators.map(function (value) {
                if (value && _this.selectiveCartService && _this.options.isSaveForLater) {
                    _this.selectiveCartService.updateEntry(value.entryNumber, value.quantity);
                }
                else if (value) {
                    _this.activeCartService.updateEntry(value.entryNumber, value.quantity);
                }
            }), operators.map(function () { return _this.form.get(item.product.code); }));
        };
        return CartItemListComponent;
    }());
    CartItemListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cart-item-list',
                    template: "<div *ngIf=\"hasHeader\" class=\"d-none d-md-block d-lg-block d-xl-block\">\n  <div class=\"cx-item-list-header row\">\n    <div class=\"cx-item-list-desc col-md-5 col-lg-5 col-xl-6\">\n      {{ 'cartItems.description' | cxTranslate }}\n    </div>\n    <div class=\"cx-item-list-price col-md-3 col-lg-2 col-xl-2\">\n      {{ 'cartItems.itemPrice' | cxTranslate }}\n    </div>\n    <div class=\"cx-item-list-qty col-md-2 col-lg-3 col-xl-2\">\n      {{ 'cartItems.quantity' | cxTranslate }}\n    </div>\n\n    <ng-container *ngIf=\"options.isSaveForLater; else totalHeader\">\n      <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n        {{ 'saveForLaterItems.stock' | cxTranslate }}\n      </div>\n    </ng-container>\n  </div>\n</div>\n\n<div class=\"cx-item-list-row\" *ngFor=\"let item of items; let i = index\">\n  <div\n    class=\"cx-item-list-items\"\n    *ngIf=\"getControl(item) | async as control\"\n    [class.is-changed]=\"control.get('quantity').dirty\"\n  >\n    <cx-cart-item\n      [item]=\"item\"\n      [quantityControl]=\"control.get('quantity')\"\n      [readonly]=\"readonly\"\n      [promotionLocation]=\"promotionLocation\"\n      [options]=\"options\"\n    >\n    </cx-cart-item>\n  </div>\n</div>\n\n<ng-template #totalHeader>\n  <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n    {{ 'cartItems.total' | cxTranslate }}\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CartItemListComponent.ctorParameters = function () { return [
        { type: i1.ActiveCartService },
        { type: i1.SelectiveCartService }
    ]; };
    CartItemListComponent.propDecorators = {
        readonly: [{ type: i0.Input }],
        hasHeader: [{ type: i0.Input }],
        options: [{ type: i0.Input }],
        items: [{ type: i0.Input, args: ['items',] }],
        promotionLocation: [{ type: i0.Input }],
        setLoading: [{ type: i0.Input, args: ['cartIsLoading',] }]
    };

    var CartItemComponent = /** @class */ (function () {
        function CartItemComponent(promotionService) {
            this.promotionService = promotionService;
            this.compact = false;
            this.readonly = false;
            this.view = new i0.EventEmitter();
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
            // TODO: evaluate whether this is generic enough
            this.options = {
                isSaveForLater: false,
                optionalBtn: null,
            };
        }
        CartItemComponent.prototype.ngOnInit = function () {
            this.appliedProductPromotions$ = this.promotionService.getProductPromotionForEntry(this.item, this.promotionLocation);
        };
        CartItemComponent.prototype.isProductOutOfStock = function (product) {
            // TODO Move stocklevelstatuses across the app to an enum
            return (product &&
                product.stock &&
                product.stock.stockLevelStatus === 'outOfStock');
        };
        CartItemComponent.prototype.removeItem = function () {
            this.quantityControl.setValue(0);
            this.quantityControl.markAsDirty();
        };
        CartItemComponent.prototype.viewItem = function () {
            this.view.emit();
        };
        return CartItemComponent;
    }());
    CartItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cart-item',
                    template: "<div [ngClass]=\"compact ? 'cx-compact row' : 'row'\">\n  <!-- Item Image -->\n  <div class=\"col-2 cx-image-container\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: item.product } | cxUrl\"\n      (click)=\"viewItem()\"\n      tabindex=\"-1\"\n    >\n      <cx-media [container]=\"item.product.images?.PRIMARY\"></cx-media>\n    </a>\n  </div>\n  <!-- Item Information -->\n  <div class=\"cx-info col-10\">\n    <div class=\"cx-info-container row\">\n      <!-- Item Description -->\n      <div [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-5'\">\n        <div *ngIf=\"item.product.name\" class=\"cx-name\">\n          <a\n            class=\"cx-link\"\n            [routerLink]=\"{ cxRoute: 'product', params: item.product } | cxUrl\"\n            (click)=\"viewItem()\"\n            >{{ item.product.name }}</a\n          >\n        </div>\n        <div *ngIf=\"item.product.code\" class=\"cx-code\">\n          {{ 'cartItems.id' | cxTranslate }} {{ item.product.code }}\n        </div>\n        <!-- Variants -->\n        <ng-container *ngIf=\"item.product.baseOptions?.length\">\n          <div\n            *ngFor=\"\n              let variant of item.product.baseOptions[0]?.selected\n                ?.variantOptionQualifiers\n            \"\n            class=\"cx-property\"\n          >\n            <div class=\"cx-label\" *ngIf=\"variant.name && variant.value\">\n              {{ variant.name }}: {{ variant.value }}\n            </div>\n          </div>\n        </ng-container>\n      </div>\n      <!-- Item Price -->\n      <div\n        *ngIf=\"item.basePrice\"\n        class=\"cx-price\"\n        [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-2'\"\n      >\n        <div\n          class=\"cx-label\"\n          [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n        >\n          {{ 'cartItems.itemPrice' | cxTranslate }}\n        </div>\n        <div *ngIf=\"item.basePrice\" class=\"cx-value\">\n          {{ item.basePrice?.formattedValue }}\n        </div>\n      </div>\n      <!-- Item Quantity -->\n      <div class=\"cx-quantity\" [ngClass]=\"compact ? '' : ' col-3'\">\n        <div\n          class=\"cx-label\"\n          [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n          placement=\"left\"\n          title=\"{{ 'cartItems.quantityTitle' | cxTranslate }}\"\n        >\n          {{ 'cartItems.quantity' | cxTranslate }}\n        </div>\n        <div class=\"cx-value\">\n          <cx-item-counter\n            [control]=\"quantityControl\"\n            [readonly]=\"!item.updateable || readonly || options.isSaveForLater\"\n            [max]=\"item.product.stock?.stockLevel || 1000\"\n            [allowZero]=\"true\"\n          >\n          </cx-item-counter>\n        </div>\n      </div>\n      <!-- Total -->\n      <ng-container *ngIf=\"options.isSaveForLater; else total\">\n        <div\n          class=\"cx-total\"\n          [ngClass]=\"compact ? '' : ' col-md-3 col-lg-3 col-xl-2'\"\n        >\n          <div\n            class=\"cx-label\"\n            [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n          >\n            {{ 'saveForLaterItems.stock' | cxTranslate }}\n          </div>\n          <div\n            *ngIf=\"item.product?.stock?.stockLevel >= 0; else forceInstock\"\n            class=\"cx-value\"\n          >\n            {{ item.product.stock.stockLevel }}\n          </div>\n          <ng-template #forceInstock\n            ><div class=\"cx-value\">\n              {{ 'saveForLaterItems.forceInStock' | cxTranslate }}\n            </div></ng-template\n          >\n        </div>\n      </ng-container>\n    </div>\n    <!-- Availability -->\n    <div\n      *ngIf=\"isProductOutOfStock(item.product)\"\n      class=\"cx-availability col-12\"\n    >\n      {{ 'productSummary.outOfStock' | cxTranslate }}\n    </div>\n    <!-- Promotion -->\n\n    <ng-container\n      *ngIf=\"appliedProductPromotions$ | async as appliedProductPromotions\"\n    >\n      <cx-promotions [promotions]=\"appliedProductPromotions\"></cx-promotions>\n    </ng-container>\n\n    <!-- Actions -->\n    <div\n      *ngIf=\"(!readonly || options.isSaveForLater) && item.updateable\"\n      class=\"cx-actions col-12\"\n    >\n      <ng-container *ngIf=\"!isProductOutOfStock(item.product)\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            options.optionalBtn;\n            context: {\n              $implicit: { loading: quantityControl.disabled, item: item }\n            }\n          \"\n        ></ng-container>\n      </ng-container>\n\n      <div class=\"col-md-3 cx-remove-btn\">\n        <button\n          class=\"link cx-action-link\"\n          [disabled]=\"quantityControl.disabled\"\n          (click)=\"removeItem()\"\n        >\n          {{ 'common.remove' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<ng-template #total>\n  <div\n    *ngIf=\"item.totalPrice\"\n    class=\"cx-total\"\n    [ngClass]=\"compact ? '' : ' col-md-3 col-xl-2'\"\n  >\n    <div\n      class=\"cx-label\"\n      [ngClass]=\"compact ? '' : ' d-block d-md-none d-lg-none d-xl-none'\"\n    >\n      {{ 'cartItems.total' | cxTranslate }}\n    </div>\n    <div class=\"cx-value\">{{ item.totalPrice.formattedValue }}</div>\n  </div>\n</ng-template>\n"
                },] }
    ];
    CartItemComponent.ctorParameters = function () { return [
        { type: PromotionService }
    ]; };
    CartItemComponent.propDecorators = {
        compact: [{ type: i0.Input }],
        item: [{ type: i0.Input }],
        readonly: [{ type: i0.Input }],
        quantityControl: [{ type: i0.Input }],
        view: [{ type: i0.Output }],
        promotionLocation: [{ type: i0.Input }],
        options: [{ type: i0.Input }]
    };

    var OrderSummaryComponent = /** @class */ (function () {
        function OrderSummaryComponent() {
        }
        return OrderSummaryComponent;
    }());
    OrderSummaryComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-summary',
                    template: "<h4>{{ 'orderCost.orderSummary' | cxTranslate }}</h4>\n\n<div class=\"cx-summary-partials\" *ngIf=\"cart\">\n  <div class=\"cx-summary-row\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.subtotal' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.subTotal?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\">\n    <div class=\"col-6 cx-summary-label\">\n      {{\n        (cart.deliveryCost?.formattedValue\n          ? 'orderCost.shipping'\n          : 'orderCost.estimatedShipping'\n        ) | cxTranslate\n      }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{\n        cart.deliveryCost?.formattedValue\n          ? cart.deliveryCost.formattedValue\n          : 'TBD'\n      }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\" *ngIf=\"cart.net\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.salesTax' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.totalTax?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row cx-summary-total\">\n    <div class=\"col-6 cx-summary-label\">\n      {{ 'orderCost.total' | cxTranslate }}\n    </div>\n    <div class=\"col-6 cx-summary-amount\">\n      {{ cart.totalPriceWithTax?.formattedValue }}\n    </div>\n  </div>\n  <div class=\"cx-summary-row\" *ngIf=\"cart.totalDiscounts?.value > 0\">\n    {{ 'orderCost.discount' | cxTranslate }}\n    {{ cart.totalDiscounts?.formattedValue }}\n  </div>\n  <div class=\"cx-summary-row\" *ngIf=\"!cart.net\">\n    {{ 'orderCost.grossTax' | cxTranslate }}\n    {{ cart.totalTax?.formattedValue }}.\n  </div>\n</div>\n\n<!--\n<cx-promotions\n  *ngIf=\"cart\"\n  [promotions]=\"cart.appliedOrderPromotions\"\n></cx-promotions>\n-->\n\n<ng-container *cxFeatureLevel=\"'1.3'\">\n  <cx-applied-coupons\n    [vouchers]=\"cart.appliedVouchers\"\n    [isReadOnly]=\"true\"\n  ></cx-applied-coupons>\n</ng-container>\n"
                },] }
    ];
    OrderSummaryComponent.propDecorators = {
        cart: [{ type: i0.Input }]
    };

    var CartSharedModule = /** @class */ (function () {
        function CartSharedModule() {
        }
        return CartSharedModule;
    }());
    CartSharedModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        CartCouponModule,
                        forms.ReactiveFormsModule,
                        i1.UrlModule,
                        i1$3.NgbModule,
                        PromotionsModule,
                        i1.I18nModule,
                        MediaModule,
                        ItemCounterModule,
                        i1.FeaturesConfigModule,
                    ],
                    declarations: [
                        CartItemComponent,
                        OrderSummaryComponent,
                        CartItemListComponent,
                    ],
                    exports: [CartItemComponent, CartItemListComponent, OrderSummaryComponent],
                },] }
    ];

    var AddToCartModule = /** @class */ (function () {
        function AddToCartModule() {
        }
        return AddToCartModule;
    }());
    AddToCartModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        CartSharedModule,
                        i4.RouterModule,
                        SpinnerModule,
                        PromotionsModule,
                        i1.FeaturesConfigModule,
                        i1.UrlModule,
                        IconModule,
                        i1.I18nModule,
                        ItemCounterModule,
                        KeyboardFocusModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductAddToCartComponent: {
                                    component: AddToCartComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [AddToCartComponent, AddedToCartDialogComponent],
                    entryComponents: [AddToCartComponent, AddedToCartDialogComponent],
                    exports: [AddToCartComponent, AddedToCartDialogComponent],
                },] }
    ];

    var CartDetailsComponent = /** @class */ (function () {
        function CartDetailsComponent(activeCartService, promotionService, selectiveCartService, authService, routingService) {
            this.activeCartService = activeCartService;
            this.promotionService = promotionService;
            this.selectiveCartService = selectiveCartService;
            this.authService = authService;
            this.routingService = routingService;
            this.loggedIn = false;
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
        }
        CartDetailsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.cart$ = this.activeCartService.getActive();
            this.promotions$ = this.promotionService.getOrderPromotionsFromCart();
            this.entries$ = this.activeCartService
                .getEntries()
                .pipe(operators.filter(function (entries) { return entries.length > 0; }));
            this.selectiveCartEnabled = this.selectiveCartService.isEnabled();
            this.cartLoaded$ = rxjs.combineLatest([
                this.activeCartService.isStable(),
                this.selectiveCartEnabled
                    ? this.selectiveCartService.getLoaded()
                    : rxjs.of(false),
                this.authService.isUserLoggedIn(),
            ]).pipe(operators.tap(function (_a) {
                var _b = __read(_a, 3), loggedIn = _b[2];
                return (_this.loggedIn = loggedIn);
            }), operators.map(function (_a) {
                var _b = __read(_a, 3), cartLoaded = _b[0], sflLoaded = _b[1], loggedIn = _b[2];
                return loggedIn && _this.selectiveCartEnabled
                    ? cartLoaded && sflLoaded
                    : cartLoaded;
            }));
            this.orderPromotions$ = this.promotionService.getOrderPromotions(this.promotionLocation);
        };
        CartDetailsComponent.prototype.saveForLater = function (item) {
            if (this.loggedIn) {
                this.activeCartService.removeEntry(item);
                this.selectiveCartService.addEntry(item.product.code, item.quantity);
            }
            else {
                this.routingService.go({ cxRoute: 'login' });
            }
        };
        return CartDetailsComponent;
    }());
    CartDetailsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cart-details',
                    template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <div *ngIf=\"cart.totalItems > 0\" class=\"cart-details-wrapper\">\n      <div class=\"cx-total\">\n        {{ 'cartDetails.cartName' | cxTranslate: { code: cart.code } }}\n      </div>\n\n      <ng-container *ngIf=\"orderPromotions$ | async as orderPromotions\">\n        <cx-promotions [promotions]=\"orderPromotions\"></cx-promotions>\n      </ng-container>\n\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [cartIsLoading]=\"!(cartLoaded$ | async)\"\n        [promotionLocation]=\"promotionLocation\"\n        [options]=\"{\n          isSaveForLater: false,\n          optionalBtn: saveForLaterBtn\n        }\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template let-ctx #saveForLaterBtn>\n  <div\n    *ngIf=\"selectiveCartEnabled\"\n    class=\"col-md-3 col-lg-3 col-xl-3 cx-sfl-btn\"\n  >\n    <button\n      class=\"link cx-action-link\"\n      [disabled]=\"ctx.loading\"\n      (click)=\"saveForLater(ctx.item)\"\n      type=\"button\"\n    >\n      {{ 'saveForLaterItems.saveForLater' | cxTranslate }}\n    </button>\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CartDetailsComponent.ctorParameters = function () { return [
        { type: i1.ActiveCartService },
        { type: PromotionService },
        { type: i1.SelectiveCartService },
        { type: i1.AuthService },
        { type: i1.RoutingService }
    ]; };

    var CartDetailsModule = /** @class */ (function () {
        function CartDetailsModule() {
        }
        return CartDetailsModule;
    }());
    CartDetailsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        CartSharedModule,
                        i1$1.CommonModule,
                        CartCouponModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        PromotionsModule,
                        i1.FeaturesConfigModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CartComponent: {
                                    component: CartDetailsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [CartDetailsComponent],
                    exports: [CartDetailsComponent],
                    entryComponents: [CartDetailsComponent],
                },] }
    ];

    var CartNotEmptyGuard = /** @class */ (function () {
        function CartNotEmptyGuard(routingService, activeCartService) {
            this.routingService = routingService;
            this.activeCartService = activeCartService;
        }
        CartNotEmptyGuard.prototype.canActivate = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.activeCartService.getActive(),
                this.activeCartService.isStable(),
            ]).pipe(operators.filter(function (_a) {
                var _b = __read(_a, 2), _ = _b[0], loaded = _b[1];
                return loaded;
            }), operators.map(function (_a) {
                var _b = __read(_a, 1), cart = _b[0];
                if (_this.isEmpty(cart)) {
                    _this.routingService.go({ cxRoute: 'home' });
                    return false;
                }
                return true;
            }));
        };
        CartNotEmptyGuard.prototype.isEmpty = function (cart) {
            return cart && !cart.totalItems;
        };
        return CartNotEmptyGuard;
    }());
    CartNotEmptyGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function CartNotEmptyGuard_Factory() { return new CartNotEmptyGuard(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.ActiveCartService)); }, token: CartNotEmptyGuard, providedIn: "root" });
    CartNotEmptyGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CartNotEmptyGuard.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.ActiveCartService }
    ]; };

    var CartPageLayoutHandler = /** @class */ (function () {
        function CartPageLayoutHandler(activeCartService, selectiveCartService) {
            this.activeCartService = activeCartService;
            this.selectiveCartService = selectiveCartService;
        }
        CartPageLayoutHandler.prototype.handle = function (slots$, pageTemplate, section) {
            if (pageTemplate === 'CartPageTemplate' && !section) {
                return rxjs.combineLatest([
                    slots$,
                    this.activeCartService.getActive(),
                    this.selectiveCartService.isEnabled()
                        ? this.selectiveCartService.getCart()
                        : rxjs.of({}),
                    this.activeCartService.getLoading(),
                ]).pipe(operators.map(function (_a) {
                    var _b = __read(_a, 4), slots = _b[0], cart = _b[1], selectiveCart = _b[2], loadingCart = _b[3];
                    var exclude = function (arr, args) { return arr.filter(function (item) { return args.every(function (arg) { return arg !== item; }); }); };
                    return Object.keys(cart).length === 0 && loadingCart
                        ? exclude(slots, [
                            'TopContent',
                            'CenterRightContentSlot',
                            'EmptyCartMiddleContent',
                        ])
                        : cart.totalItems
                            ? exclude(slots, ['EmptyCartMiddleContent'])
                            : selectiveCart.totalItems
                                ? exclude(slots, [
                                    'EmptyCartMiddleContent',
                                    'CenterRightContentSlot',
                                ])
                                : exclude(slots, ['TopContent', 'CenterRightContentSlot']);
                }));
            }
            return slots$;
        };
        return CartPageLayoutHandler;
    }());
    CartPageLayoutHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function CartPageLayoutHandler_Factory() { return new CartPageLayoutHandler(i0.ɵɵinject(i1.ActiveCartService), i0.ɵɵinject(i1.SelectiveCartService)); }, token: CartPageLayoutHandler, providedIn: "root" });
    CartPageLayoutHandler.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CartPageLayoutHandler.ctorParameters = function () { return [
        { type: i1.ActiveCartService },
        { type: i1.SelectiveCartService }
    ]; };

    var CartTotalsComponent = /** @class */ (function () {
        function CartTotalsComponent(activeCartService) {
            this.activeCartService = activeCartService;
        }
        CartTotalsComponent.prototype.ngOnInit = function () {
            this.cart$ = this.activeCartService.getActive();
            this.entries$ = this.activeCartService
                .getEntries()
                .pipe(operators.filter(function (entries) { return entries.length > 0; }));
        };
        return CartTotalsComponent;
    }());
    CartTotalsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cart-totals',
                    template: "<ng-container *ngIf=\"cart$ | async as cart\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <cx-order-summary [cart]=\"cart\"></cx-order-summary>\n    <button\n      [routerLink]=\"{ cxRoute: 'checkout' } | cxUrl\"\n      *ngIf=\"entries.length\"\n      class=\"btn btn-primary btn-block\"\n      type=\"button\"\n    >\n      {{ 'cartDetails.proceedToCheckout' | cxTranslate }}\n    </button>\n  </ng-container>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CartTotalsComponent.ctorParameters = function () { return [
        { type: i1.ActiveCartService }
    ]; };

    var CartTotalsModule = /** @class */ (function () {
        function CartTotalsModule() {
        }
        return CartTotalsModule;
    }());
    CartTotalsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        CartSharedModule,
                        i1.I18nModule,
                        CartCouponModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CartTotalsComponent: {
                                    component: CartTotalsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [CartTotalsComponent],
                    exports: [CartTotalsComponent],
                    entryComponents: [CartTotalsComponent],
                },] }
    ];

    var PAGE_LAYOUT_HANDLER = new i0.InjectionToken('PageLayoutHandler');

    var MiniCartComponent = /** @class */ (function () {
        function MiniCartComponent(activeCartService) {
            this.activeCartService = activeCartService;
            this.iconTypes = exports.ICON_TYPE;
            this.quantity$ = this.activeCartService.getActive().pipe(operators.startWith({ deliveryItemsQuantity: 0 }), operators.map(function (cart) { return cart.deliveryItemsQuantity || 0; }));
            this.total$ = this.activeCartService.getActive().pipe(operators.filter(function (cart) { return !!cart.totalPrice; }), operators.map(function (cart) { return cart.totalPrice.formattedValue; }));
        }
        return MiniCartComponent;
    }());
    MiniCartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-mini-cart',
                    template: "<a\n  [attr.aria-label]=\"\n    'miniCart.item' | cxTranslate: { count: quantity$ | async }\n  \"\n  [routerLink]=\"{ cxRoute: 'cart' } | cxUrl\"\n>\n  <cx-icon [type]=\"iconTypes.CART\"></cx-icon>\n\n  <span class=\"total\">\n    {{ 'miniCart.total' | cxTranslate: { total: total$ | async } }}\n  </span>\n\n  <span class=\"count\">\n    {{ 'miniCart.count' | cxTranslate: { count: quantity$ | async } }}\n  </span>\n</a>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    MiniCartComponent.ctorParameters = function () { return [
        { type: i1.ActiveCartService }
    ]; };

    var MiniCartModule = /** @class */ (function () {
        function MiniCartModule() {
        }
        return MiniCartModule;
    }());
    MiniCartModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.UrlModule, IconModule, i1.I18nModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                MiniCartComponent: {
                                    component: MiniCartComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [MiniCartComponent],
                    exports: [MiniCartComponent],
                    entryComponents: [MiniCartComponent],
                },] }
    ];

    var AddToWishListComponent = /** @class */ (function () {
        function AddToWishListComponent(wishListService, currentProductService, authService) {
            var _this = this;
            this.wishListService = wishListService;
            this.currentProductService = currentProductService;
            this.authService = authService;
            this.product$ = this.currentProductService.getProduct().pipe(operators.filter(function (product) { return Boolean(product); }), operators.tap(function (product) { return _this.setStockInfo(product); }));
            this.wishListEntries$ = this.wishListService.getWishList().pipe(operators.filter(function (wishlist) { return Boolean(wishlist); }), operators.map(function (wishList) { return wishList.entries; }));
            this.userLoggedIn$ = this.authService.isUserLoggedIn();
            this.loading$ = this.wishListService.getWishListLoading();
            this.hasStock = false;
            this.iconTypes = exports.ICON_TYPE;
        }
        AddToWishListComponent.prototype.add = function (product) {
            this.wishListService.addEntry(product.code);
        };
        AddToWishListComponent.prototype.remove = function (entry) {
            this.wishListService.removeEntry(entry);
        };
        AddToWishListComponent.prototype.getProductInWishList = function (product, entries) {
            var item = entries.find(function (entry) { return entry.product.code === product.code; });
            return item;
        };
        AddToWishListComponent.prototype.setStockInfo = function (product) {
            this.hasStock =
                product.stock && product.stock.stockLevelStatus !== 'outOfStock';
        };
        return AddToWishListComponent;
    }());
    AddToWishListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-add-to-wishlist',
                    template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-container *ngIf=\"userLoggedIn$ | async; else loginPrompt\">\n    <ng-container *ngIf=\"wishListEntries$ | async as entries\">\n      <ng-container *ngIf=\"hasStock\">\n        <div\n          *ngIf=\"getProductInWishList(product, entries) as entry; else addItem\"\n        >\n          <button\n            class=\"btn btn-link button-remove cx-action-link\"\n            (click)=\"remove(entry)\"\n            [disabled]=\"loading$ | async\"\n          >\n            <cx-icon [type]=\"iconTypes.HEART\"></cx-icon>\n            <span class=\"button-text\">{{\n              'addToWishList.remove' | cxTranslate\n            }}</span>\n          </button>\n        </div>\n        <ng-template #addItem>\n          <button\n            class=\"btn btn-link button-add cx-action-link\"\n            (click)=\"add(product)\"\n            [disabled]=\"loading$ | async\"\n          >\n            <cx-icon [type]=\"iconTypes.EMPTY_HEART\"></cx-icon>\n            <span class=\"button-text\">{{\n              'addToWishList.add' | cxTranslate\n            }}</span>\n          </button>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #loginPrompt>\n  <ng-container *ngIf=\"hasStock\">\n    <a\n      class=\"btn btn-link button-add-link cx-action-link\"\n      [routerLink]=\"{ cxRoute: 'login' } | cxUrl\"\n    >\n      <cx-icon [type]=\"iconTypes.EMPTY_HEART\"></cx-icon>\n      <span class=\"button-text\">{{\n        'addToWishList.anonymous' | cxTranslate\n      }}</span>\n    </a>\n  </ng-container>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    AddToWishListComponent.ctorParameters = function () { return [
        { type: i1.WishListService },
        { type: CurrentProductService },
        { type: i1.AuthService }
    ]; };

    var AddToWishListModule = /** @class */ (function () {
        function AddToWishListModule() {
        }
        return AddToWishListModule;
    }());
    AddToWishListModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule, IconModule, i4.RouterModule, i1.UrlModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                AddToWishListComponent: {
                                    component: AddToWishListComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [AddToWishListComponent],
                    entryComponents: [AddToWishListComponent],
                    exports: [AddToWishListComponent],
                },] }
    ];

    var SaveForLaterComponent = /** @class */ (function () {
        function SaveForLaterComponent(cmsService, cartService, selectiveCartService) {
            this.cmsService = cmsService;
            this.cartService = cartService;
            this.selectiveCartService = selectiveCartService;
        }
        SaveForLaterComponent.prototype.ngOnInit = function () {
            this.isCartEmpty$ = this.cartService
                .getActive()
                .pipe(operators.map(function (cart) { return !(cart && cart.totalItems && cart.totalItems > 0); }));
            this.saveForLater$ = this.selectiveCartService.getCart();
            this.entries$ = this.selectiveCartService
                .getEntries()
                .pipe(operators.filter(function (entries) { return entries.length > 0; }));
            this.cartLoaded$ = rxjs.combineLatest([
                this.cartService.isStable(),
                this.selectiveCartService.getLoaded(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), cartLoaded = _b[0], sflLoaded = _b[1];
                return cartLoaded && sflLoaded;
            }));
            this.data$ = this.cmsService.getComponentData('EmptyCartParagraphComponent');
        };
        SaveForLaterComponent.prototype.moveToCart = function (item) {
            this.selectiveCartService.removeEntry(item);
            this.cartService.addEntry(item.product.code, item.quantity);
        };
        return SaveForLaterComponent;
    }());
    SaveForLaterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-save-for-later',
                    template: "<ng-container *ngIf=\"isCartEmpty$ | async\">\n  <p\n    *ngIf=\"data$ | async as data\"\n    [innerHTML]=\"data.content\"\n    class=\"cx-empty-cart-info\"\n  ></p>\n</ng-container>\n\n<ng-container *ngIf=\"saveForLater$ | async as saveForLater\">\n  <ng-container *ngIf=\"entries$ | async as entries\">\n    <div *ngIf=\"saveForLater.totalItems > 0\" class=\"cart-details-wrapper\">\n      <div class=\"cx-total\">\n        {{\n          'saveForLaterItems.itemTotal'\n            | cxTranslate: { count: saveForLater.totalItems }\n        }}\n      </div>\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [readonly]=\"false\"\n        [cartIsLoading]=\"!(cartLoaded$ | async)\"\n        [options]=\"{\n          isSaveForLater: true,\n          optionalBtn: moveToCartBtn\n        }\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template let-ctx #moveToCartBtn>\n  <div class=\"col-md-3 col-lg-3 col-xl-3 cx-sfl-btn\">\n    <button\n      class=\"link cx-action-link\"\n      [disabled]=\"ctx.loading\"\n      (click)=\"moveToCart(ctx.item)\"\n      type=\"button\"\n    >\n      {{ 'saveForLaterItems.moveToCart' | cxTranslate }}\n    </button>\n  </div>\n</ng-template>\n"
                },] }
    ];
    SaveForLaterComponent.ctorParameters = function () { return [
        { type: i1.CmsService },
        { type: i1.ActiveCartService },
        { type: i1.SelectiveCartService }
    ]; };

    var SaveForLaterModule = /** @class */ (function () {
        function SaveForLaterModule() {
        }
        return SaveForLaterModule;
    }());
    SaveForLaterModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule, CartSharedModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                SaveForLaterComponent: {
                                    component: SaveForLaterComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [SaveForLaterComponent],
                    exports: [SaveForLaterComponent],
                    entryComponents: [SaveForLaterComponent],
                },] }
    ];

    var CartComponentModule = /** @class */ (function () {
        function CartComponentModule() {
        }
        return CartComponentModule;
    }());
    CartComponentModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$3.NgbModule,
                        CartDetailsModule,
                        CartTotalsModule,
                        CartSharedModule,
                        SaveForLaterModule,
                    ],
                    exports: [
                        AddToWishListModule,
                        CartDetailsModule,
                        CartTotalsModule,
                        CartSharedModule,
                        AddToCartModule,
                        MiniCartModule,
                        i1.CartModule,
                        SaveForLaterModule,
                    ],
                    declarations: [],
                    providers: [
                        {
                            provide: PAGE_LAYOUT_HANDLER,
                            useExisting: CartPageLayoutHandler,
                            multi: true,
                        },
                    ],
                },] }
    ];

    (function (CheckoutStepType) {
        CheckoutStepType["SHIPPING_ADDRESS"] = "shippingAddress";
        CheckoutStepType["DELIVERY_MODE"] = "deliveryMode";
        CheckoutStepType["PAYMENT_DETAILS"] = "paymentDetails";
        CheckoutStepType["REVIEW_ORDER"] = "reviewOrder";
        CheckoutStepType["PAYMENT_TYPE"] = "paymentType";
    })(exports.CheckoutStepType || (exports.CheckoutStepType = {}));
    var checkoutShippingSteps = [
        exports.CheckoutStepType.SHIPPING_ADDRESS,
        exports.CheckoutStepType.DELIVERY_MODE,
    ];
    var checkoutPaymentSteps = [
        exports.CheckoutStepType.PAYMENT_DETAILS,
        exports.CheckoutStepType.PAYMENT_TYPE,
        exports.CheckoutStepType.SHIPPING_ADDRESS,
    ];

    (function (DeliveryModePreferences) {
        DeliveryModePreferences["FREE"] = "FREE";
        DeliveryModePreferences["LEAST_EXPENSIVE"] = "LEAST_EXPENSIVE";
        DeliveryModePreferences["MOST_EXPENSIVE"] = "MOST_EXPENSIVE";
    })(exports.DeliveryModePreferences || (exports.DeliveryModePreferences = {}));
    var CheckoutConfig = /** @class */ (function () {
        function CheckoutConfig() {
        }
        return CheckoutConfig;
    }());
    CheckoutConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: CheckoutConfig, providedIn: "root" });
    CheckoutConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    var defaultCheckoutConfig = {
        checkout: {
            steps: [
                {
                    id: 'shippingAddress',
                    name: 'checkoutProgress.shippingAddress',
                    routeName: 'checkoutShippingAddress',
                    type: [exports.CheckoutStepType.SHIPPING_ADDRESS],
                },
                {
                    id: 'deliveryMode',
                    name: 'checkoutProgress.deliveryMode',
                    routeName: 'checkoutDeliveryMode',
                    type: [exports.CheckoutStepType.DELIVERY_MODE],
                },
                {
                    id: 'paymentDetails',
                    name: 'checkoutProgress.paymentDetails',
                    routeName: 'checkoutPaymentDetails',
                    type: [exports.CheckoutStepType.PAYMENT_DETAILS],
                },
                {
                    id: 'reviewOrder',
                    name: 'checkoutProgress.reviewOrder',
                    routeName: 'checkoutReviewOrder',
                    type: [exports.CheckoutStepType.REVIEW_ORDER],
                },
            ],
            express: false,
            defaultDeliveryMode: [exports.DeliveryModePreferences.FREE],
            guest: false,
        },
    };

    var CheckoutConfigService = /** @class */ (function () {
        function CheckoutConfigService(checkoutConfig) {
            this.checkoutConfig = checkoutConfig;
            this.express = this.checkoutConfig.checkout.express;
            this.guest = this.checkoutConfig.checkout.guest;
            this.defaultDeliveryMode = this.checkoutConfig.checkout.defaultDeliveryMode || [];
        }
        CheckoutConfigService.prototype.compareDeliveryCost = function (deliveryMode1, deliveryMode2) {
            if (deliveryMode1.deliveryCost.value > deliveryMode2.deliveryCost.value) {
                return 1;
            }
            else if (deliveryMode1.deliveryCost.value < deliveryMode2.deliveryCost.value) {
                return -1;
            }
            return 0;
        };
        CheckoutConfigService.prototype.findMatchingDeliveryMode = function (deliveryModes, index) {
            var _this = this;
            if (index === void 0) { index = 0; }
            switch (this.defaultDeliveryMode[index]) {
                case exports.DeliveryModePreferences.FREE:
                    if (deliveryModes[0].deliveryCost.value === 0) {
                        return deliveryModes[0].code;
                    }
                    break;
                case exports.DeliveryModePreferences.LEAST_EXPENSIVE:
                    var leastExpensiveFound = deliveryModes.find(function (deliveryMode) { return deliveryMode.deliveryCost.value !== 0; });
                    if (leastExpensiveFound) {
                        return leastExpensiveFound.code;
                    }
                    break;
                case exports.DeliveryModePreferences.MOST_EXPENSIVE:
                    return deliveryModes[deliveryModes.length - 1].code;
                default:
                    var codeFound = deliveryModes.find(function (deliveryMode) { return deliveryMode.code === _this.defaultDeliveryMode[index]; });
                    if (codeFound) {
                        return codeFound.code;
                    }
            }
            var lastMode = this.defaultDeliveryMode.length - 1 <= index;
            return lastMode
                ? deliveryModes[0].code
                : this.findMatchingDeliveryMode(deliveryModes, index + 1);
        };
        CheckoutConfigService.prototype.getPreferredDeliveryMode = function (deliveryModes) {
            deliveryModes.sort(this.compareDeliveryCost);
            return this.findMatchingDeliveryMode(deliveryModes);
        };
        CheckoutConfigService.prototype.isExpressCheckout = function () {
            return this.express;
        };
        CheckoutConfigService.prototype.isGuestCheckout = function () {
            return this.guest;
        };
        return CheckoutConfigService;
    }());
    CheckoutConfigService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutConfigService_Factory() { return new CheckoutConfigService(i0.ɵɵinject(CheckoutConfig)); }, token: CheckoutConfigService, providedIn: "root" });
    CheckoutConfigService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutConfigService.ctorParameters = function () { return [
        { type: CheckoutConfig }
    ]; };

    var CheckoutAuthGuard = /** @class */ (function () {
        function CheckoutAuthGuard(routingService, authService, authRedirectService, checkoutConfigService, activeCartService, userService, globalMessageService) {
            this.routingService = routingService;
            this.authService = authService;
            this.authRedirectService = authRedirectService;
            this.checkoutConfigService = checkoutConfigService;
            this.activeCartService = activeCartService;
            this.userService = userService;
            this.globalMessageService = globalMessageService;
        }
        CheckoutAuthGuard.prototype.canActivate = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.authService.getUserToken(),
                this.activeCartService.getAssignedUser(),
                this.userService.get(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), token = _b[0], cartUser = _b[1], user = _b[2];
                if (!token.access_token) {
                    if (_this.activeCartService.isGuestCart()) {
                        return Boolean(cartUser);
                    }
                    if (_this.checkoutConfigService.isGuestCheckout()) {
                        _this.routingService.go({ cxRoute: 'login' }, { forced: true });
                    }
                    else {
                        _this.routingService.go({ cxRoute: 'login' });
                    }
                    _this.authRedirectService.reportAuthGuard();
                }
                else if ('roles' in user) {
                    var roles = user.roles;
                    if (roles.includes(i1.B2BUserGroup.B2B_CUSTOMER_GROUP)) {
                        return true;
                    }
                    else {
                        _this.globalMessageService.add({ key: 'checkout.invalid.accountType' }, i1.GlobalMessageType.MSG_TYPE_WARNING);
                        return false;
                    }
                }
                return !!token.access_token;
            }));
        };
        return CheckoutAuthGuard;
    }());
    CheckoutAuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutAuthGuard_Factory() { return new CheckoutAuthGuard(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i1.AuthRedirectService), i0.ɵɵinject(CheckoutConfigService), i0.ɵɵinject(i1.ActiveCartService), i0.ɵɵinject(i1.UserService), i0.ɵɵinject(i1.GlobalMessageService)); }, token: CheckoutAuthGuard, providedIn: "root" });
    CheckoutAuthGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutAuthGuard.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.AuthService },
        { type: i1.AuthRedirectService },
        { type: CheckoutConfigService },
        { type: i1.ActiveCartService },
        { type: i1.UserService },
        { type: i1.GlobalMessageService }
    ]; };

    var CheckoutStepService = /** @class */ (function () {
        function CheckoutStepService(routingService, checkoutConfig, routingConfigService) {
            var _this = this;
            this.routingService = routingService;
            this.checkoutConfig = checkoutConfig;
            this.routingConfigService = routingConfigService;
            this.steps$ = new rxjs.BehaviorSubject(undefined);
            this.activeStepIndex$ = this.routingService.getRouterState().pipe(operators.switchMap(function (router) {
                var activeStepUrl = router.state.context.id;
                return _this.steps$.pipe(operators.map(function (steps) {
                    var activeIndex;
                    steps.forEach(function (step, index) {
                        var routeUrl = "/" + _this.routingConfigService.getRouteConfig(step.routeName).paths[0];
                        if (routeUrl === activeStepUrl) {
                            activeIndex = index;
                        }
                    });
                    return activeIndex;
                }));
            }));
            this.resetSteps();
        }
        CheckoutStepService.prototype.back = function (activatedRoute) {
            var previousUrl = this.getPreviousCheckoutStepUrl(activatedRoute);
            this.routingService.go(previousUrl === null ? 'cart' : previousUrl);
        };
        CheckoutStepService.prototype.next = function (activatedRoute) {
            var nextUrl = this.getNextCheckoutStepUrl(activatedRoute);
            this.routingService.go(nextUrl);
        };
        CheckoutStepService.prototype.goToStepWithIndex = function (stepIndex) {
            this.routingService.go(this.getStepUrlFromStepRoute(this.allSteps[stepIndex].routeName));
        };
        CheckoutStepService.prototype.getBackBntText = function (activatedRoute) {
            if (this.getPreviousCheckoutStepUrl(activatedRoute) === null) {
                return 'checkout.backToCart';
            }
            return 'common.back';
        };
        CheckoutStepService.prototype.resetSteps = function () {
            this.allSteps = this.checkoutConfig.checkout.steps
                .filter(function (step) { return !step.disabled; })
                .map(function (x) { return Object.assign({}, x); });
            this.steps$.next(this.allSteps);
        };
        CheckoutStepService.prototype.disableEnableStep = function (currentStepType, disabled) {
            var currentStep = this.allSteps.find(function (step) { return step.type.includes(currentStepType); });
            if (currentStep && currentStep.disabled !== disabled) {
                currentStep.disabled = disabled;
                this.steps$.next(this.allSteps.filter(function (step) { return !step.disabled; }));
            }
        };
        CheckoutStepService.prototype.getCheckoutStep = function (currentStepType) {
            return this.allSteps[this.getCheckoutStepIndex('type', currentStepType)];
        };
        CheckoutStepService.prototype.getCheckoutStepRoute = function (currentStepType) {
            return this.getCheckoutStep(currentStepType).routeName;
        };
        CheckoutStepService.prototype.getFirstCheckoutStepRoute = function () {
            return this.allSteps[0].routeName;
        };
        CheckoutStepService.prototype.getNextCheckoutStepUrl = function (activatedRoute) {
            var stepIndex = this.getCurrentStepIndex(activatedRoute);
            if (stepIndex >= 0) {
                var i = 1;
                while (this.allSteps[stepIndex + i] &&
                    this.allSteps[stepIndex + i].disabled) {
                    i++;
                }
                var nextStep = this.allSteps[stepIndex + i];
                if (nextStep) {
                    return this.getStepUrlFromStepRoute(nextStep.routeName);
                }
            }
            return null;
        };
        CheckoutStepService.prototype.getPreviousCheckoutStepUrl = function (activatedRoute) {
            var stepIndex = this.getCurrentStepIndex(activatedRoute);
            if (stepIndex >= 0) {
                var i = 1;
                while (this.allSteps[stepIndex - i] &&
                    this.allSteps[stepIndex - i].disabled) {
                    i++;
                }
                var previousStep = this.allSteps[stepIndex - i];
                if (previousStep) {
                    return this.getStepUrlFromStepRoute(previousStep.routeName);
                }
            }
            return null;
        };
        CheckoutStepService.prototype.getCurrentStepIndex = function (activatedRoute) {
            var _this = this;
            var currentStepUrl = this.getStepUrlFromActivatedRoute(activatedRoute);
            var stepIndex = this.allSteps.findIndex(function (step) { return currentStepUrl === "/" + _this.getStepUrlFromStepRoute(step.routeName); });
            return stepIndex === -1 ? null : stepIndex;
        };
        CheckoutStepService.prototype.getStepUrlFromActivatedRoute = function (activatedRoute) {
            return activatedRoute &&
                activatedRoute.snapshot &&
                activatedRoute.snapshot.url
                ? "/" + activatedRoute.snapshot.url.join('/')
                : null;
        };
        CheckoutStepService.prototype.getStepUrlFromStepRoute = function (stepRoute) {
            return this.routingConfigService.getRouteConfig(stepRoute).paths[0];
        };
        CheckoutStepService.prototype.getCheckoutStepIndex = function (key, value) {
            return key && value
                ? this.allSteps.findIndex(function (step) { return step[key].includes(value); })
                : null;
        };
        return CheckoutStepService;
    }());
    CheckoutStepService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutStepService_Factory() { return new CheckoutStepService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(CheckoutConfig), i0.ɵɵinject(i1.RoutingConfigService)); }, token: CheckoutStepService, providedIn: "root" });
    CheckoutStepService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutStepService.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: CheckoutConfig },
        { type: i1.RoutingConfigService }
    ]; };

    var CheckoutDetailsService = /** @class */ (function () {
        function CheckoutDetailsService(checkoutService, checkoutDeliveryService, checkoutPaymentService, activeCartService) {
            var _this = this;
            this.checkoutService = checkoutService;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.checkoutPaymentService = checkoutPaymentService;
            this.activeCartService = activeCartService;
            this.cartId$ = this.activeCartService.getActive().pipe(operators.map(function (cartData) {
                if ((cartData.user && cartData.user.uid === i1.OCC_USER_ID_ANONYMOUS) ||
                    _this.activeCartService.isGuestCart()) {
                    return cartData.guid;
                }
                return cartData.code;
            }), operators.filter(function (cartId) { return !!cartId; }));
            this.getCheckoutDetailsLoaded$ = this.cartId$.pipe(operators.tap(function (cartId) { return _this.checkoutService.loadCheckoutDetails(cartId); }), operators.shareReplay(1), operators.switchMap(function () { return _this.checkoutService.getCheckoutDetailsLoaded(); }), operators.skipWhile(function (loaded) { return !loaded; }));
        }
        CheckoutDetailsService.prototype.getDeliveryAddress = function () {
            var _this = this;
            return this.getCheckoutDetailsLoaded$.pipe(operators.switchMap(function () { return _this.checkoutDeliveryService.getDeliveryAddress(); }));
        };
        CheckoutDetailsService.prototype.getSelectedDeliveryModeCode = function () {
            var _this = this;
            return this.getCheckoutDetailsLoaded$.pipe(operators.switchMap(function () { return _this.checkoutDeliveryService.getSelectedDeliveryModeCode(); }));
        };
        CheckoutDetailsService.prototype.getPaymentDetails = function () {
            var _this = this;
            return this.getCheckoutDetailsLoaded$.pipe(operators.switchMap(function () { return _this.checkoutPaymentService.getPaymentDetails(); }));
        };
        return CheckoutDetailsService;
    }());
    CheckoutDetailsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutDetailsService_Factory() { return new CheckoutDetailsService(i0.ɵɵinject(i1.CheckoutService), i0.ɵɵinject(i1.CheckoutDeliveryService), i0.ɵɵinject(i1.CheckoutPaymentService), i0.ɵɵinject(i1.ActiveCartService)); }, token: CheckoutDetailsService, providedIn: "root" });
    CheckoutDetailsService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutDetailsService.ctorParameters = function () { return [
        { type: i1.CheckoutService },
        { type: i1.CheckoutDeliveryService },
        { type: i1.CheckoutPaymentService },
        { type: i1.ActiveCartService }
    ]; };

    var ExpressCheckoutService = /** @class */ (function () {
        function ExpressCheckoutService(userAddressService, userPaymentService, checkoutDeliveryService, checkoutPaymentService, checkoutDetailsService, checkoutConfigService) {
            this.userAddressService = userAddressService;
            this.userPaymentService = userPaymentService;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.checkoutPaymentService = checkoutPaymentService;
            this.checkoutDetailsService = checkoutDetailsService;
            this.checkoutConfigService = checkoutConfigService;
            this.setShippingAddress();
            this.setDeliveryMode();
            this.setPaymentMethod();
        }
        ExpressCheckoutService.prototype.setShippingAddress = function () {
            var _this = this;
            this.shippingAddressSet$ = rxjs.combineLatest([
                this.userAddressService.getAddresses(),
                this.userAddressService.getAddressesLoadedSuccess(),
                this.checkoutDeliveryService.getSetDeliveryAddressProcess(),
            ]).pipe(operators.debounceTime(0), operators.tap(function (_a) {
                var _b = __read(_a, 2), addressesLoadedSuccess = _b[1];
                if (!addressesLoadedSuccess) {
                    _this.userAddressService.loadAddresses();
                }
            }), operators.filter(function (_a) {
                var _b = __read(_a, 2), addressesLoadedSuccess = _b[1];
                return addressesLoadedSuccess;
            }), operators.switchMap(function (_a) {
                var _b = __read(_a, 3), addresses = _b[0], setDeliveryAddressProcess = _b[2];
                var defaultAddress = addresses.find(function (address) { return address.defaultAddress; }) || addresses[0];
                if (defaultAddress && Object.keys(defaultAddress).length) {
                    if (!(setDeliveryAddressProcess.success ||
                        setDeliveryAddressProcess.error ||
                        setDeliveryAddressProcess.loading)) {
                        _this.checkoutDeliveryService.setDeliveryAddress(defaultAddress);
                    }
                    return rxjs.of(setDeliveryAddressProcess).pipe(operators.filter(function (setDeliveryAddressProcessState) {
                        return ((setDeliveryAddressProcessState.success ||
                            setDeliveryAddressProcessState.error) &&
                            !setDeliveryAddressProcessState.loading);
                    }), operators.switchMap(function (setDeliveryAddressProcessState) {
                        if (setDeliveryAddressProcessState.success) {
                            return _this.checkoutDetailsService.getDeliveryAddress();
                        }
                        return rxjs.of(false);
                    }), operators.map(function (data) { return Boolean(data && Object.keys(data).length); }));
                }
                return rxjs.of(false);
            }));
        };
        ExpressCheckoutService.prototype.setPaymentMethod = function () {
            var _this = this;
            this.paymentMethodSet$ = rxjs.combineLatest([
                this.userPaymentService.getPaymentMethods(),
                this.userPaymentService.getPaymentMethodsLoadedSuccess(),
                this.checkoutPaymentService.getSetPaymentDetailsResultProcess(),
            ]).pipe(operators.debounceTime(0), operators.tap(function (_a) {
                var _b = __read(_a, 2), paymentMethodsLoadedSuccess = _b[1];
                if (!paymentMethodsLoadedSuccess) {
                    _this.userPaymentService.loadPaymentMethods();
                }
            }), operators.filter(function (_a) {
                var _b = __read(_a, 2), success = _b[1];
                return success;
            }), operators.switchMap(function (_a) {
                var _b = __read(_a, 3), payments = _b[0], setPaymentDetailsProcess = _b[2];
                var defaultPayment = payments.find(function (address) { return address.defaultPayment; }) || payments[0];
                if (defaultPayment && Object.keys(defaultPayment).length) {
                    if (!(setPaymentDetailsProcess.success ||
                        setPaymentDetailsProcess.error ||
                        setPaymentDetailsProcess.loading)) {
                        _this.checkoutPaymentService.setPaymentDetails(defaultPayment);
                    }
                    return rxjs.of(setPaymentDetailsProcess).pipe(operators.filter(function (setPaymentDetailsProcessState) {
                        return ((setPaymentDetailsProcessState.success ||
                            setPaymentDetailsProcessState.error) &&
                            !setPaymentDetailsProcessState.loading);
                    }), operators.switchMap(function (setPaymentDetailsProcessState) {
                        if (setPaymentDetailsProcessState.success) {
                            return _this.checkoutDetailsService.getPaymentDetails();
                        }
                        return rxjs.of(false);
                    }), operators.map(function (data) { return Boolean(data && Object.keys(data).length); }));
                }
                return rxjs.of(false);
            }));
        };
        ExpressCheckoutService.prototype.setDeliveryMode = function () {
            var _this = this;
            this.deliveryModeSet$ = rxjs.combineLatest([
                this.shippingAddressSet$,
                this.checkoutDeliveryService.getSupportedDeliveryModes(),
                this.checkoutDeliveryService.getSetDeliveryModeProcess(),
                this.checkoutDeliveryService.getLoadSupportedDeliveryModeProcess(),
            ]).pipe(operators.debounceTime(0), operators.switchMap(function (_a) {
                var _b = __read(_a, 4), addressSet = _b[0], supportedDeliveryModes = _b[1], setDeliveryModeStatusFlag = _b[2], loadSupportedDeliveryModeStatus = _b[3];
                if (addressSet) {
                    return rxjs.of([
                        supportedDeliveryModes,
                        setDeliveryModeStatusFlag,
                        loadSupportedDeliveryModeStatus,
                    ]).pipe(operators.filter(function (_a) {
                        var _b = __read(_a, 3), supportedDeliveryModeStatus = _b[2];
                        return supportedDeliveryModeStatus.success;
                    }), operators.switchMap(function (_a) {
                        var _b = __read(_a, 3), deliveryModes = _b[0], setDeliveryModeStatus = _b[1];
                        if (Boolean(deliveryModes.length)) {
                            var preferredDeliveryMode = _this.checkoutConfigService.getPreferredDeliveryMode(deliveryModes);
                            return rxjs.of([
                                preferredDeliveryMode,
                                setDeliveryModeStatus,
                            ]).pipe(operators.tap(function (_a) {
                                var _b = __read(_a, 2), deliveryMode = _b[0], deliveryModeLoadingStatus = _b[1];
                                if (deliveryMode &&
                                    !(deliveryModeLoadingStatus.success ||
                                        deliveryModeLoadingStatus.error ||
                                        deliveryModeLoadingStatus.loading)) {
                                    _this.checkoutDeliveryService.setDeliveryMode(deliveryMode);
                                }
                            }), operators.filter(function (_a) {
                                var _b = __read(_a, 2), deliveryModeLoadingStatus = _b[1];
                                return ((deliveryModeLoadingStatus.success ||
                                    deliveryModeLoadingStatus.error) &&
                                    !deliveryModeLoadingStatus.loading);
                            }), operators.switchMap(function (_a) {
                                var _b = __read(_a, 2), deliveryModeLoadingStatus = _b[1];
                                if (deliveryModeLoadingStatus.success) {
                                    return _this.checkoutDetailsService.getSelectedDeliveryModeCode();
                                }
                                return rxjs.of(false);
                            }), operators.map(function (data) { return Boolean(data); }));
                        }
                        return rxjs.of(false);
                    }));
                }
                else {
                    return rxjs.of(false);
                }
            }));
        };
        ExpressCheckoutService.prototype.resetCheckoutProcesses = function () {
            this.checkoutDeliveryService.resetSetDeliveryAddressProcess();
            this.checkoutPaymentService.resetSetPaymentDetailsProcess();
            this.checkoutDeliveryService.resetSetDeliveryModeProcess();
        };
        ExpressCheckoutService.prototype.trySetDefaultCheckoutDetails = function () {
            this.resetCheckoutProcesses();
            return rxjs.combineLatest([this.deliveryModeSet$, this.paymentMethodSet$]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), deliveryModeSet = _b[0], paymentMethodSet = _b[1];
                return Boolean(deliveryModeSet && paymentMethodSet);
            }));
        };
        return ExpressCheckoutService;
    }());
    ExpressCheckoutService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ExpressCheckoutService_Factory() { return new ExpressCheckoutService(i0.ɵɵinject(i1.UserAddressService), i0.ɵɵinject(i1.UserPaymentService), i0.ɵɵinject(i1.CheckoutDeliveryService), i0.ɵɵinject(i1.CheckoutPaymentService), i0.ɵɵinject(CheckoutDetailsService), i0.ɵɵinject(CheckoutConfigService)); }, token: ExpressCheckoutService, providedIn: "root" });
    ExpressCheckoutService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ExpressCheckoutService.ctorParameters = function () { return [
        { type: i1.UserAddressService },
        { type: i1.UserPaymentService },
        { type: i1.CheckoutDeliveryService },
        { type: i1.CheckoutPaymentService },
        { type: CheckoutDetailsService },
        { type: CheckoutConfigService }
    ]; };

    var CheckoutGuard = /** @class */ (function () {
        function CheckoutGuard(router, routingConfigService, checkoutConfigService, checkoutStepService, expressCheckoutService, activeCartService) {
            this.router = router;
            this.routingConfigService = routingConfigService;
            this.checkoutConfigService = checkoutConfigService;
            this.checkoutStepService = checkoutStepService;
            this.expressCheckoutService = expressCheckoutService;
            this.activeCartService = activeCartService;
            this.firstStep$ = rxjs.of(this.router.parseUrl(this.routingConfigService.getRouteConfig(this.checkoutStepService.getFirstCheckoutStepRoute()).paths[0]));
        }
        CheckoutGuard.prototype.canActivate = function () {
            var _this = this;
            if (this.checkoutConfigService.isExpressCheckout() &&
                !this.activeCartService.isGuestCart()) {
                return this.expressCheckoutService.trySetDefaultCheckoutDetails().pipe(operators.switchMap(function (expressCheckoutPossible) {
                    return expressCheckoutPossible
                        ? rxjs.of(_this.router.parseUrl(_this.routingConfigService.getRouteConfig(_this.checkoutStepService.getCheckoutStepRoute(exports.CheckoutStepType.REVIEW_ORDER)).paths[0]))
                        : _this.firstStep$;
                }));
            }
            return this.firstStep$;
        };
        return CheckoutGuard;
    }());
    CheckoutGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutGuard_Factory() { return new CheckoutGuard(i0.ɵɵinject(i4.Router), i0.ɵɵinject(i1.RoutingConfigService), i0.ɵɵinject(CheckoutConfigService), i0.ɵɵinject(CheckoutStepService), i0.ɵɵinject(ExpressCheckoutService), i0.ɵɵinject(i1.ActiveCartService)); }, token: CheckoutGuard, providedIn: "root" });
    CheckoutGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutGuard.ctorParameters = function () { return [
        { type: i4.Router },
        { type: i1.RoutingConfigService },
        { type: CheckoutConfigService },
        { type: CheckoutStepService },
        { type: ExpressCheckoutService },
        { type: i1.ActiveCartService }
    ]; };

    var CheckoutOrchestratorComponent = /** @class */ (function () {
        function CheckoutOrchestratorComponent() {
        }
        return CheckoutOrchestratorComponent;
    }());
    CheckoutOrchestratorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-checkout-orchestrator',
                    template: "",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CheckoutOrchestratorComponent.ctorParameters = function () { return []; };

    var CheckoutOrchestratorModule = /** @class */ (function () {
        function CheckoutOrchestratorModule() {
        }
        return CheckoutOrchestratorModule;
    }());
    CheckoutOrchestratorModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    providers: [
                        i1.provideDefaultConfig(defaultCheckoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutOrchestrator: {
                                    component: CheckoutOrchestratorComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutOrchestratorComponent],
                    entryComponents: [CheckoutOrchestratorComponent],
                    exports: [CheckoutOrchestratorComponent],
                },] }
    ];

    var CheckoutOrderSummaryComponent = /** @class */ (function () {
        function CheckoutOrderSummaryComponent(activeCartService) {
            this.activeCartService = activeCartService;
            this.cart$ = this.activeCartService.getActive();
        }
        return CheckoutOrderSummaryComponent;
    }());
    CheckoutOrderSummaryComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-checkout-order-summary',
                    template: "<cx-order-summary [cart]=\"cart$ | async\"></cx-order-summary>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CheckoutOrderSummaryComponent.ctorParameters = function () { return [
        { type: i1.ActiveCartService }
    ]; };

    var CheckoutOrderSummaryModule = /** @class */ (function () {
        function CheckoutOrderSummaryModule() {
        }
        return CheckoutOrderSummaryModule;
    }());
    CheckoutOrderSummaryModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, CartSharedModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutOrderSummary: {
                                    component: CheckoutOrderSummaryComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutOrderSummaryComponent],
                    entryComponents: [CheckoutOrderSummaryComponent],
                    exports: [CheckoutOrderSummaryComponent],
                },] }
    ];

    var CheckoutProgressMobileBottomComponent = /** @class */ (function () {
        function CheckoutProgressMobileBottomComponent(checkoutStepService) {
            var _this = this;
            this.checkoutStepService = checkoutStepService;
            this._steps$ = this.checkoutStepService
                .steps$;
            this.activeStepIndex$ = this.checkoutStepService.activeStepIndex$.pipe(operators.tap(function (index) { return (_this.activeStepIndex = index); }));
        }
        Object.defineProperty(CheckoutProgressMobileBottomComponent.prototype, "steps$", {
            get: function () {
                return this._steps$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        return CheckoutProgressMobileBottomComponent;
    }());
    CheckoutProgressMobileBottomComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-checkout-progress-mobile-bottom',
                    template: "<div *ngIf=\"(activeStepIndex$ | async) !== undefined\">\n  <div class=\"cx-media\">\n    <div *ngFor=\"let step of steps$ | async; let i = index\">\n      <div class=\"cx-list-media\" *ngIf=\"i > activeStepIndex\">\n        <div>{{ i + 1 }}. {{ step.name | cxTranslate }}</div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CheckoutProgressMobileBottomComponent.ctorParameters = function () { return [
        { type: CheckoutStepService }
    ]; };

    var CheckoutStepsSetGuard = /** @class */ (function () {
        function CheckoutStepsSetGuard(paymentTypeService, checkoutStepService, checkoutDetailsService, routingConfigService, checkoutCostCenterService, router) {
            this.paymentTypeService = paymentTypeService;
            this.checkoutStepService = checkoutStepService;
            this.checkoutDetailsService = checkoutDetailsService;
            this.routingConfigService = routingConfigService;
            this.checkoutCostCenterService = checkoutCostCenterService;
            this.router = router;
        }
        CheckoutStepsSetGuard.prototype.canActivate = function (route, _) {
            var _this = this;
            var currentIndex = -1;
            var currentRouteUrl = '/' + route.url.join('/');
            // check whether the previous step is set
            return rxjs.combineLatest([
                this.checkoutStepService.steps$,
                this.paymentTypeService.isAccountPayment(),
            ]).pipe(operators.tap(function (_a) {
                var _b = __read(_a, 2), isAccount = _b[1];
                _this.checkoutStepService.disableEnableStep(exports.CheckoutStepType.PAYMENT_DETAILS, isAccount);
            }), operators.take(1), operators.switchMap(function (_a) {
                var _b = __read(_a, 2), steps = _b[0], isAccount = _b[1];
                currentIndex = steps.findIndex(function (step) {
                    var stepRouteUrl = "/" + _this.routingConfigService.getRouteConfig(step.routeName).paths[0];
                    return stepRouteUrl === currentRouteUrl;
                });
                // get current step
                var currentStep;
                if (currentIndex >= 0) {
                    currentStep = steps[currentIndex];
                }
                if (Boolean(currentStep)) {
                    return _this.isStepSet(steps[currentIndex - 1], isAccount);
                }
                else {
                    if (i0.isDevMode()) {
                        console.warn("Missing step with route '" + currentRouteUrl + "' in checkout configuration or this step is disabled.");
                    }
                    return rxjs.of(_this.getUrl('checkout'));
                }
            }));
        };
        CheckoutStepsSetGuard.prototype.isStepSet = function (step, isAccountPayment) {
            if (step && !step.disabled) {
                switch (step.type[0]) {
                    case exports.CheckoutStepType.PAYMENT_TYPE: {
                        return this.isPaymentTypeSet(step);
                    }
                    case exports.CheckoutStepType.SHIPPING_ADDRESS: {
                        return this.isShippingAddressAndCostCenterSet(step, isAccountPayment);
                    }
                    case exports.CheckoutStepType.DELIVERY_MODE: {
                        return this.isDeliveryModeSet(step);
                    }
                    case exports.CheckoutStepType.PAYMENT_DETAILS: {
                        return this.isPaymentDetailsSet(step);
                    }
                    case exports.CheckoutStepType.REVIEW_ORDER: {
                        break;
                    }
                }
            }
            return rxjs.of(true);
        };
        CheckoutStepsSetGuard.prototype.isPaymentTypeSet = function (step) {
            var _this = this;
            return this.paymentTypeService.getSelectedPaymentType().pipe(operators.map(function (paymentType) {
                if (Boolean(paymentType)) {
                    return true;
                }
                else {
                    return _this.getUrl(step.routeName);
                }
            }));
        };
        CheckoutStepsSetGuard.prototype.isShippingAddressAndCostCenterSet = function (step, isAccountPayment) {
            var _this = this;
            return rxjs.combineLatest([
                this.checkoutDetailsService.getDeliveryAddress(),
                this.checkoutCostCenterService.getCostCenter(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), deliveryAddress = _b[0], costCenter = _b[1];
                if (isAccountPayment) {
                    if (deliveryAddress &&
                        Object.keys(deliveryAddress).length &&
                        Boolean(costCenter)) {
                        return true;
                    }
                    else {
                        return _this.getUrl(step.routeName);
                    }
                }
                else {
                    if (deliveryAddress &&
                        Object.keys(deliveryAddress).length &&
                        costCenter === undefined) {
                        return true;
                    }
                    else {
                        return _this.getUrl(step.routeName);
                    }
                }
            }));
        };
        CheckoutStepsSetGuard.prototype.isDeliveryModeSet = function (step) {
            var _this = this;
            return this.checkoutDetailsService
                .getSelectedDeliveryModeCode()
                .pipe(operators.map(function (mode) { return mode && mode.length ? true : _this.getUrl(step.routeName); }));
        };
        CheckoutStepsSetGuard.prototype.isPaymentDetailsSet = function (step) {
            var _this = this;
            return this.checkoutDetailsService
                .getPaymentDetails()
                .pipe(operators.map(function (paymentDetails) { return paymentDetails && Object.keys(paymentDetails).length !== 0
                ? true
                : _this.getUrl(step.routeName); }));
        };
        CheckoutStepsSetGuard.prototype.getUrl = function (routeName) {
            return this.router.parseUrl(this.routingConfigService.getRouteConfig(routeName).paths[0]);
        };
        return CheckoutStepsSetGuard;
    }());
    CheckoutStepsSetGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutStepsSetGuard_Factory() { return new CheckoutStepsSetGuard(i0.ɵɵinject(i1.PaymentTypeService), i0.ɵɵinject(CheckoutStepService), i0.ɵɵinject(CheckoutDetailsService), i0.ɵɵinject(i1.RoutingConfigService), i0.ɵɵinject(i1.CheckoutCostCenterService), i0.ɵɵinject(i4.Router)); }, token: CheckoutStepsSetGuard, providedIn: "root" });
    CheckoutStepsSetGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutStepsSetGuard.ctorParameters = function () { return [
        { type: i1.PaymentTypeService },
        { type: CheckoutStepService },
        { type: CheckoutDetailsService },
        { type: i1.RoutingConfigService },
        { type: i1.CheckoutCostCenterService },
        { type: i4.Router }
    ]; };

    var CheckoutProgressMobileBottomModule = /** @class */ (function () {
        function CheckoutProgressMobileBottomModule() {
        }
        return CheckoutProgressMobileBottomModule;
    }());
    CheckoutProgressMobileBottomModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.UrlModule, i1.I18nModule, i4.RouterModule],
                    providers: [
                        i1.provideDefaultConfig(defaultCheckoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutProgressMobileBottom: {
                                    component: CheckoutProgressMobileBottomComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutProgressMobileBottomComponent],
                    entryComponents: [CheckoutProgressMobileBottomComponent],
                    exports: [CheckoutProgressMobileBottomComponent],
                },] }
    ];

    var CheckoutProgressMobileTopComponent = /** @class */ (function () {
        function CheckoutProgressMobileTopComponent(checkoutStepService, activeCartService) {
            var _this = this;
            this.checkoutStepService = checkoutStepService;
            this.activeCartService = activeCartService;
            this._steps$ = this.checkoutStepService
                .steps$;
            this.activeStepIndex$ = this.checkoutStepService.activeStepIndex$.pipe(operators.tap(function (index) { return (_this.activeStepIndex = index); }));
        }
        Object.defineProperty(CheckoutProgressMobileTopComponent.prototype, "steps$", {
            get: function () {
                return this._steps$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        CheckoutProgressMobileTopComponent.prototype.ngOnInit = function () {
            this.cart$ = this.activeCartService.getActive();
        };
        return CheckoutProgressMobileTopComponent;
    }());
    CheckoutProgressMobileTopComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-checkout-progress-mobile-top',
                    template: "<div *ngIf=\"(activeStepIndex$ | async) !== undefined\">\n  <div *ngIf=\"cart$ | async as cart\">\n    <div class=\"cx-media\">\n      <div class=\"cx-list-media\" *ngIf=\"cart?.totalItems && cart?.subTotal\">\n        {{ 'cartItems.cartTotal' | cxTranslate: { count: cart.totalItems } }}:\n        {{ cart.subTotal.formattedValue }}\n      </div>\n      <div *ngFor=\"let step of steps$ | async; let i = index\">\n        <div class=\"cx-list-media\" *ngIf=\"i < activeStepIndex\">\n          <div>{{ i + 1 }}. {{ step.name | cxTranslate }}</div>\n          <button\n            class=\"btn btn-link\"\n            [routerLink]=\"{ cxRoute: step.routeName } | cxUrl\"\n          >\n            {{ 'common.edit' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"cx-list-media is-active\" *ngIf=\"i === activeStepIndex\">\n          <div>{{ i + 1 }}. {{ step.name | cxTranslate }}</div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CheckoutProgressMobileTopComponent.ctorParameters = function () { return [
        { type: CheckoutStepService },
        { type: i1.ActiveCartService }
    ]; };

    var CheckoutProgressMobileTopModule = /** @class */ (function () {
        function CheckoutProgressMobileTopModule() {
        }
        return CheckoutProgressMobileTopModule;
    }());
    CheckoutProgressMobileTopModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.UrlModule, i1.I18nModule, i4.RouterModule],
                    providers: [
                        i1.provideDefaultConfig(defaultCheckoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutProgressMobileTop: {
                                    component: CheckoutProgressMobileTopComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutProgressMobileTopComponent],
                    entryComponents: [CheckoutProgressMobileTopComponent],
                    exports: [CheckoutProgressMobileTopComponent],
                },] }
    ];

    var CheckoutProgressComponent = /** @class */ (function () {
        function CheckoutProgressComponent(checkoutStepService) {
            var _this = this;
            this.checkoutStepService = checkoutStepService;
            this._steps$ = this.checkoutStepService
                .steps$;
            this.activeStepIndex$ = this.checkoutStepService.activeStepIndex$.pipe(operators.tap(function (index) { return (_this.activeStepIndex = index); }));
        }
        Object.defineProperty(CheckoutProgressComponent.prototype, "steps$", {
            get: function () {
                return this._steps$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        CheckoutProgressComponent.prototype.getTabIndex = function (stepIndex) {
            return !this.isActive(stepIndex) && !this.isDisabled(stepIndex) ? 0 : -1;
        };
        CheckoutProgressComponent.prototype.isActive = function (index) {
            return index === this.activeStepIndex;
        };
        CheckoutProgressComponent.prototype.isDisabled = function (index) {
            return index > this.activeStepIndex;
        };
        return CheckoutProgressComponent;
    }());
    CheckoutProgressComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-checkout-progress',
                    template: "<section *ngIf=\"(activeStepIndex$ | async) !== undefined\">\n  <div class=\"cx-nav d-none d-lg-block d-xl-block\">\n    <ul class=\"cx-list\">\n      <ng-container *ngFor=\"let step of steps$ | async; let i = index\">\n        <li\n          class=\"cx-item\"\n          [class.active]=\"isActive(i)\"\n          [class.disabled]=\"isDisabled(i)\"\n        >\n          <a\n            [routerLink]=\"{ cxRoute: step.routeName } | cxUrl\"\n            class=\"cx-link\"\n            [class.active]=\"isActive(i)\"\n            [class.disabled]=\"isDisabled(i)\"\n            [tabindex]=\"getTabIndex(i)\"\n            [innerHTML]=\"step.name | cxTranslate | cxMultiLine\"\n          >\n          </a>\n        </li>\n      </ng-container>\n    </ul>\n  </div>\n</section>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CheckoutProgressComponent.ctorParameters = function () { return [
        { type: CheckoutStepService }
    ]; };

    var MultiLinePipe = /** @class */ (function () {
        function MultiLinePipe() {
        }
        MultiLinePipe.prototype.transform = function (value) {
            var lastIndex = value.lastIndexOf(' ');
            if (lastIndex === -1)
                return value;
            return (value.substring(0, lastIndex) +
                '<br />' +
                value.substring(lastIndex, value.length).trim());
        };
        return MultiLinePipe;
    }());
    MultiLinePipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'cxMultiLine',
                },] }
    ];

    var CheckoutProgressModule = /** @class */ (function () {
        function CheckoutProgressModule() {
        }
        return CheckoutProgressModule;
    }());
    CheckoutProgressModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.UrlModule, i1.I18nModule, i4.RouterModule],
                    declarations: [CheckoutProgressComponent, MultiLinePipe],
                    entryComponents: [CheckoutProgressComponent],
                    exports: [CheckoutProgressComponent],
                    providers: [
                        i1.provideDefaultConfig(defaultCheckoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutProgress: {
                                    component: CheckoutProgressComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard, CheckoutStepsSetGuard],
                                },
                            },
                        }),
                    ],
                },] }
    ];

    var CheckoutDetailsLoadedGuard = /** @class */ (function () {
        function CheckoutDetailsLoadedGuard(checkoutDetailsService) {
            this.checkoutDetailsService = checkoutDetailsService;
        }
        CheckoutDetailsLoadedGuard.prototype.canActivate = function () {
            return this.checkoutDetailsService.getCheckoutDetailsLoaded$;
        };
        return CheckoutDetailsLoadedGuard;
    }());
    CheckoutDetailsLoadedGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutDetailsLoadedGuard_Factory() { return new CheckoutDetailsLoadedGuard(i0.ɵɵinject(CheckoutDetailsService)); }, token: CheckoutDetailsLoadedGuard, providedIn: "root" });
    CheckoutDetailsLoadedGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutDetailsLoadedGuard.ctorParameters = function () { return [
        { type: CheckoutDetailsService }
    ]; };

    var NotCheckoutAuthGuard = /** @class */ (function () {
        function NotCheckoutAuthGuard(routingService, authService, activeCartService) {
            this.routingService = routingService;
            this.authService = authService;
            this.activeCartService = activeCartService;
        }
        NotCheckoutAuthGuard.prototype.canActivate = function () {
            var _this = this;
            return this.authService.getUserToken().pipe(operators.map(function (token) {
                if (token.access_token) {
                    _this.routingService.go({ cxRoute: 'home' });
                }
                else if (_this.activeCartService.isGuestCart()) {
                    _this.routingService.go({ cxRoute: 'cart' });
                    return false;
                }
                return !token.access_token;
            }));
        };
        return NotCheckoutAuthGuard;
    }());
    NotCheckoutAuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function NotCheckoutAuthGuard_Factory() { return new NotCheckoutAuthGuard(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i1.ActiveCartService)); }, token: NotCheckoutAuthGuard, providedIn: "root" });
    NotCheckoutAuthGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    NotCheckoutAuthGuard.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.AuthService },
        { type: i1.ActiveCartService }
    ]; };

    var DeliveryModeSetGuard = /** @class */ (function () {
        function DeliveryModeSetGuard(checkoutDetailsService, checkoutStepService, routingConfigService, router) {
            this.checkoutDetailsService = checkoutDetailsService;
            this.checkoutStepService = checkoutStepService;
            this.routingConfigService = routingConfigService;
            this.router = router;
        }
        DeliveryModeSetGuard.prototype.canActivate = function () {
            var _this = this;
            var checkoutStep = this.checkoutStepService.getCheckoutStep(exports.CheckoutStepType.DELIVERY_MODE);
            if (!checkoutStep && i0.isDevMode()) {
                console.warn("Missing step with type " + exports.CheckoutStepType.DELIVERY_MODE + " in checkout configuration.");
            }
            if (checkoutStep && checkoutStep.disabled) {
                return rxjs.of(true);
            }
            return this.checkoutDetailsService
                .getSelectedDeliveryModeCode()
                .pipe(operators.map(function (mode) { return mode && mode.length
                ? true
                : _this.router.parseUrl(checkoutStep &&
                    _this.routingConfigService.getRouteConfig(checkoutStep.routeName).paths[0]); }));
        };
        return DeliveryModeSetGuard;
    }());
    DeliveryModeSetGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeliveryModeSetGuard_Factory() { return new DeliveryModeSetGuard(i0.ɵɵinject(CheckoutDetailsService), i0.ɵɵinject(CheckoutStepService), i0.ɵɵinject(i1.RoutingConfigService), i0.ɵɵinject(i4.Router)); }, token: DeliveryModeSetGuard, providedIn: "root" });
    DeliveryModeSetGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    DeliveryModeSetGuard.ctorParameters = function () { return [
        { type: CheckoutDetailsService },
        { type: CheckoutStepService },
        { type: i1.RoutingConfigService },
        { type: i4.Router }
    ]; };

    var PaymentDetailsSetGuard = /** @class */ (function () {
        function PaymentDetailsSetGuard(checkoutDetailsService, checkoutStepService, routingConfigService, router) {
            this.checkoutDetailsService = checkoutDetailsService;
            this.checkoutStepService = checkoutStepService;
            this.routingConfigService = routingConfigService;
            this.router = router;
        }
        PaymentDetailsSetGuard.prototype.canActivate = function () {
            var _this = this;
            var checkoutStep = this.checkoutStepService.getCheckoutStep(exports.CheckoutStepType.PAYMENT_DETAILS);
            if (!checkoutStep && i0.isDevMode()) {
                console.warn("Missing step with type " + exports.CheckoutStepType.PAYMENT_DETAILS + " in checkout configuration.");
            }
            return this.checkoutDetailsService
                .getPaymentDetails()
                .pipe(operators.map(function (paymentDetails) { return paymentDetails && Object.keys(paymentDetails).length !== 0
                ? true
                : _this.router.parseUrl(checkoutStep &&
                    _this.routingConfigService.getRouteConfig(checkoutStep.routeName).paths[0]); }));
        };
        return PaymentDetailsSetGuard;
    }());
    PaymentDetailsSetGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function PaymentDetailsSetGuard_Factory() { return new PaymentDetailsSetGuard(i0.ɵɵinject(CheckoutDetailsService), i0.ɵɵinject(CheckoutStepService), i0.ɵɵinject(i1.RoutingConfigService), i0.ɵɵinject(i4.Router)); }, token: PaymentDetailsSetGuard, providedIn: "root" });
    PaymentDetailsSetGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    PaymentDetailsSetGuard.ctorParameters = function () { return [
        { type: CheckoutDetailsService },
        { type: CheckoutStepService },
        { type: i1.RoutingConfigService },
        { type: i4.Router }
    ]; };

    var ShippingAddressSetGuard = /** @class */ (function () {
        function ShippingAddressSetGuard(checkoutDetailsService, checkoutStepService, routingConfigService, router) {
            this.checkoutDetailsService = checkoutDetailsService;
            this.checkoutStepService = checkoutStepService;
            this.routingConfigService = routingConfigService;
            this.router = router;
        }
        ShippingAddressSetGuard.prototype.canActivate = function () {
            var _this = this;
            var checkoutStep = this.checkoutStepService.getCheckoutStep(exports.CheckoutStepType.SHIPPING_ADDRESS);
            if (!checkoutStep && i0.isDevMode()) {
                console.warn("Missing step with type " + exports.CheckoutStepType.SHIPPING_ADDRESS + " in checkout configuration.");
            }
            if (checkoutStep && checkoutStep.disabled) {
                return rxjs.of(true);
            }
            return this.checkoutDetailsService
                .getDeliveryAddress()
                .pipe(operators.map(function (deliveryAddress) { return deliveryAddress && Object.keys(deliveryAddress).length
                ? true
                : _this.router.parseUrl(checkoutStep &&
                    _this.routingConfigService.getRouteConfig(checkoutStep.routeName).paths[0]); }));
        };
        return ShippingAddressSetGuard;
    }());
    ShippingAddressSetGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function ShippingAddressSetGuard_Factory() { return new ShippingAddressSetGuard(i0.ɵɵinject(CheckoutDetailsService), i0.ɵɵinject(CheckoutStepService), i0.ɵɵinject(i1.RoutingConfigService), i0.ɵɵinject(i4.Router)); }, token: ShippingAddressSetGuard, providedIn: "root" });
    ShippingAddressSetGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ShippingAddressSetGuard.ctorParameters = function () { return [
        { type: CheckoutDetailsService },
        { type: CheckoutStepService },
        { type: i1.RoutingConfigService },
        { type: i4.Router }
    ]; };

    var CostCenterComponent = /** @class */ (function () {
        function CostCenterComponent(userCostCenterService, checkoutCostCenterService, paymentTypeService) {
            var _this = this;
            this.userCostCenterService = userCostCenterService;
            this.checkoutCostCenterService = checkoutCostCenterService;
            this.paymentTypeService = paymentTypeService;
            this.cartCostCenter$ = this.checkoutCostCenterService.getCostCenter();
            this.isAccountPayment$ = this.paymentTypeService.isAccountPayment();
            this.costCenters$ = this.userCostCenterService.getActiveCostCenters().pipe(operators.filter(function (costCenters) { return Boolean(costCenters); }), operators.tap(function (costCenters) {
                if (!Boolean(_this.costCenterId)) {
                    _this.setCostCenter(costCenters[0].code);
                }
            }));
        }
        CostCenterComponent.prototype.setCostCenter = function (selectCostCenter) {
            this.costCenterId = selectCostCenter;
            this.checkoutCostCenterService.setCostCenter(this.costCenterId);
        };
        return CostCenterComponent;
    }());
    CostCenterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cost-center',
                    template: "<ng-container *ngIf=\"isAccountPayment$ | async\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-xl-10\">\n      <ng-container *ngIf=\"costCenters$ | async as costCenters\">\n        <div *ngIf=\"costCenters.length !== 0\">\n          <label>\n            <span class=\"label-content required\">{{\n              'checkoutPO.costCenter' | cxTranslate\n            }}</span>\n            <select (change)=\"setCostCenter($event.target.value)\">\n              <option\n                *ngFor=\"let costCenter of costCenters\"\n                value=\"{{ costCenter.code }}\"\n                [selected]=\"(cartCostCenter$ | async) === costCenter.code\"\n              >\n                {{ costCenter.name }}\n              </option>\n            </select>\n            <span class=\"label-content\">{{\n              'checkoutPO.availableLabel' | cxTranslate\n            }}</span>\n          </label>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CostCenterComponent.ctorParameters = function () { return [
        { type: i1.UserCostCenterService },
        { type: i1.CheckoutCostCenterService },
        { type: i1.PaymentTypeService }
    ]; };

    var CostCenterModule = /** @class */ (function () {
        function CostCenterModule() {
        }
        return CostCenterModule;
    }());
    CostCenterModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        i1.ConfigModule.withConfig({
                            cmsComponents: {
                                CheckoutCostCenterComponent: {
                                    component: CostCenterComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CostCenterComponent],
                    entryComponents: [CostCenterComponent],
                },] }
    ];

    var DeliveryModeComponent = /** @class */ (function () {
        function DeliveryModeComponent(fb, checkoutDeliveryService, checkoutConfigService, checkoutStepService, activatedRoute) {
            this.fb = fb;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.checkoutConfigService = checkoutConfigService;
            this.checkoutStepService = checkoutStepService;
            this.activatedRoute = activatedRoute;
            this.allowRedirect = false;
            this.backBtnText = this.checkoutStepService.getBackBntText(this.activatedRoute);
            this.mode = this.fb.group({
                deliveryModeId: ['', forms.Validators.required],
            });
        }
        DeliveryModeComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.supportedDeliveryModes$ = this.checkoutDeliveryService.getSupportedDeliveryModes();
            // Reload delivery modes on error
            this.checkoutDeliveryService
                .getLoadSupportedDeliveryModeProcess()
                .pipe(operators.takeWhile(function (state) { return (state === null || state === void 0 ? void 0 : state.success) === false; }))
                .subscribe(function (state) {
                if (state.error && !state.loading) {
                    _this.checkoutDeliveryService.loadSupportedDeliveryModes();
                }
            });
            this.deliveryModeSub = this.supportedDeliveryModes$
                .pipe(operators.withLatestFrom(this.checkoutDeliveryService
                .getSelectedDeliveryMode()
                .pipe(operators.map(function (deliveryMode) { return deliveryMode && deliveryMode.code ? deliveryMode.code : null; }))))
                .subscribe(function (_a) {
                var _b = __read(_a, 2), deliveryModes = _b[0], code = _b[1];
                if (!code && deliveryModes && deliveryModes.length) {
                    code = _this.checkoutConfigService.getPreferredDeliveryMode(deliveryModes);
                }
                if (_this.allowRedirect &&
                    !!code &&
                    code === _this.currentDeliveryModeId) {
                    _this.checkoutStepService.next(_this.activatedRoute);
                }
                if (code) {
                    _this.mode.controls['deliveryModeId'].setValue(code);
                    if (code !== _this.currentDeliveryModeId) {
                        _this.checkoutDeliveryService.setDeliveryMode(code);
                    }
                }
                _this.currentDeliveryModeId = code;
            });
        };
        DeliveryModeComponent.prototype.changeMode = function (code) {
            if (code !== this.currentDeliveryModeId) {
                this.checkoutDeliveryService.setDeliveryMode(code);
                this.currentDeliveryModeId = code;
            }
        };
        DeliveryModeComponent.prototype.next = function () {
            this.allowRedirect = true;
            if (this.mode.valid && this.mode.value) {
                if (!this.currentDeliveryModeId) {
                    this.currentDeliveryModeId = this.mode.value.deliveryModeId;
                }
                this.checkoutDeliveryService.setDeliveryMode(this.currentDeliveryModeId);
            }
        };
        DeliveryModeComponent.prototype.back = function () {
            this.checkoutStepService.back(this.activatedRoute);
        };
        Object.defineProperty(DeliveryModeComponent.prototype, "deliveryModeInvalid", {
            get: function () {
                return this.mode.controls['deliveryModeId'].invalid;
            },
            enumerable: false,
            configurable: true
        });
        DeliveryModeComponent.prototype.ngOnDestroy = function () {
            if (this.deliveryModeSub) {
                this.deliveryModeSub.unsubscribe();
            }
        };
        return DeliveryModeComponent;
    }());
    DeliveryModeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-delivery-mode',
                    template: "<div [formGroup]=\"mode\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-lg-9\">\n      <h3 class=\"cx-checkout-title d-none d-lg-block d-xl-block\">\n        {{ 'checkoutShipping.shippingMethod' | cxTranslate }}\n      </h3>\n\n      <ng-container\n        *ngIf=\"(supportedDeliveryModes$ | async)?.length; else loading\"\n      >\n        <div\n          class=\"form-check\"\n          *ngFor=\"let mode of supportedDeliveryModes$ | async\"\n        >\n          <input\n            class=\"form-check-input\"\n            role=\"radio\"\n            type=\"radio\"\n            id=\"deliveryMode-{{ mode.code }}\"\n            aria-checked=\"true\"\n            (change)=\"changeMode(mode.code)\"\n            [value]=\"mode.code\"\n            formControlName=\"deliveryModeId\"\n          />\n          <label\n            class=\"cx-delivery-label form-check-label form-radio-label\"\n            for=\"deliveryMode-{{ mode.code }}\"\n          >\n            <div class=\"cx-delivery-mode\">{{ mode.name }}</div>\n            <div class=\"cx-delivery-price\">\n              {{ mode.deliveryCost.formattedValue }}\n            </div>\n            <div class=\"cx-delivery-details\">{{ mode.description }}</div>\n          </label>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n\n  <div class=\"row cx-checkout-btns\">\n    <div class=\"col-md-12 col-lg-6\">\n      <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n        {{ backBtnText | cxTranslate }}\n      </button>\n    </div>\n    <div class=\"col-md-12 col-lg-6\">\n      <button\n        class=\"btn btn-block btn-primary\"\n        [disabled]=\"deliveryModeInvalid\"\n        (click)=\"next()\"\n      >\n        {{ 'common.continue' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    DeliveryModeComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder },
        { type: i1.CheckoutDeliveryService },
        { type: CheckoutConfigService },
        { type: CheckoutStepService },
        { type: i4.ActivatedRoute }
    ]; };

    var DeliveryModeModule = /** @class */ (function () {
        function DeliveryModeModule() {
        }
        return DeliveryModeModule;
    }());
    DeliveryModeModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, forms.ReactiveFormsModule, i1.I18nModule, SpinnerModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutDeliveryMode: {
                                    component: DeliveryModeComponent,
                                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard here?
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [DeliveryModeComponent],
                    entryComponents: [DeliveryModeComponent],
                    exports: [DeliveryModeComponent],
                },] }
    ];

    var SuggestedAddressDialogComponent = /** @class */ (function () {
        function SuggestedAddressDialogComponent(modalService) {
            this.modalService = modalService;
            this.iconTypes = exports.ICON_TYPE;
        }
        SuggestedAddressDialogComponent.prototype.ngOnInit = function () {
            this.selectedAddress = this.suggestedAddresses.length
                ? this.suggestedAddresses[0]
                : this.enteredAddress;
        };
        SuggestedAddressDialogComponent.prototype.closeModal = function (reason) {
            this.modalService.closeActiveModal(reason);
        };
        return SuggestedAddressDialogComponent;
    }());
    SuggestedAddressDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-suggested-addresses-dialog',
                    template: "<div class=\"cx-dialog-header modal-header\">\n  <div class=\"cx-dialog-title modal-title\">\n    {{ 'checkoutAddress.verifyYourAddress' | cxTranslate }}\n  </div>\n  <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"closeModal()\">\n    <span aria-hidden=\"true\">\n      <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </span>\n  </button>\n</div>\n<div class=\"cx-dialog-body modal-body\" ngForm>\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"cx-dialog-info col-md-12\">\n        <p>\n          {{ 'checkoutAddress.ensureAccuracySuggestChange' | cxTranslate }}\n          {{ 'checkoutAddress.chooseAddressToUse' | cxTranslate }}\n        </p>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"cx-dialog-options col-md-12\">\n        <div\n          class=\"form-check\"\n          *ngFor=\"let suggestedAddress of suggestedAddresses; let i = index\"\n        >\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"suggestedAddress\"\n            [id]=\"'suggested-addresses--suggested-' + i\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            [for]=\"'suggested-addresses--suggested-' + i\"\n          >\n            {{ 'checkoutAddress.suggestedAddress' | cxTranslate }}\n            {{ suggestedAddresses?.length > 1 ? i + 1 : null }}\n          </label>\n          <div class=\"cx-dialog-suggested\">\n            {{ suggestedAddress?.firstName }} {{ suggestedAddress?.lastName\n            }}<br />\n            {{ suggestedAddress?.line1 }}<br />\n            <span>{{ suggestedAddress?.line2 }}</span\n            ><br />\n            {{ suggestedAddress?.town }} {{ suggestedAddress?.region?.isocode\n            }}<br />\n            {{ suggestedAddress?.postalCode }}\n          </div>\n        </div>\n        <div class=\"form-check\">\n          <input\n            class=\"form-check-input\"\n            type=\"radio\"\n            name=\"selectedAddress\"\n            [(ngModel)]=\"selectedAddress\"\n            [value]=\"enteredAddress\"\n            id=\"suggested-addresses--entered\"\n          />\n          <label\n            class=\"form-check-label cx-dialog-label\"\n            for=\"suggested-addresses--entered\"\n          >\n            {{ 'checkoutAddress.enteredAddress' | cxTranslate }}\n          </label>\n          <div class=\"cx-dialog-entered\">\n            {{ enteredAddress?.firstName }} {{ enteredAddress?.lastName }}<br />\n            {{ enteredAddress?.line1 }}<br />\n            <span>{{ enteredAddress?.line2 }}</span\n            ><br />\n            {{ enteredAddress?.town }} {{ enteredAddress?.region?.isocode\n            }}<br />\n            {{ enteredAddress?.postalCode }}\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"cx-dialog-actions col-sm-12 col-md-6 offset-md-6\">\n        <button\n          class=\"btn btn-secondary btn-block cx-dialog-buttons\"\n          (click)=\"closeModal()\"\n        >\n          {{ 'checkoutAddress.editAddress' | cxTranslate }}\n        </button>\n        <button\n          cxAutoFocus\n          class=\"btn btn-primary btn-block cx-dialog-buttons\"\n          (click)=\"closeModal(selectedAddress)\"\n        >\n          {{ 'checkoutAddress.saveAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    SuggestedAddressDialogComponent.ctorParameters = function () { return [
        { type: ModalService }
    ]; };
    SuggestedAddressDialogComponent.propDecorators = {
        suggestedAddresses: [{ type: i0.Input }],
        enteredAddress: [{ type: i0.Input }]
    };

    var PaymentFormComponent = /** @class */ (function () {
        function PaymentFormComponent(checkoutPaymentService, checkoutDeliveryService, userPaymentService, globalMessageService, fb, modalService, userAddressService) {
            this.checkoutPaymentService = checkoutPaymentService;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.userPaymentService = userPaymentService;
            this.globalMessageService = globalMessageService;
            this.fb = fb;
            this.modalService = modalService;
            this.userAddressService = userAddressService;
            this.iconTypes = exports.ICON_TYPE;
            this.months = [];
            this.years = [];
            this.sameAsShippingAddress = true;
            this.selectedCountry$ = new rxjs.BehaviorSubject('');
            this.goBack = new i0.EventEmitter();
            this.closeForm = new i0.EventEmitter();
            this.setPaymentDetails = new i0.EventEmitter();
            this.paymentForm = this.fb.group({
                cardType: this.fb.group({
                    code: [null, forms.Validators.required],
                }),
                accountHolderName: ['', forms.Validators.required],
                cardNumber: ['', forms.Validators.required],
                expiryMonth: [null, forms.Validators.required],
                expiryYear: [null, forms.Validators.required],
                cvn: ['', forms.Validators.required],
                defaultPayment: [false],
            });
            this.billingAddressForm = this.fb.group({
                firstName: ['', forms.Validators.required],
                lastName: ['', forms.Validators.required],
                line1: ['', forms.Validators.required],
                line2: [''],
                town: ['', forms.Validators.required],
                region: this.fb.group({
                    isocodeShort: [null, forms.Validators.required],
                }),
                country: this.fb.group({
                    isocode: [null, forms.Validators.required],
                }),
                postalCode: ['', forms.Validators.required],
            });
        }
        PaymentFormComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.expMonthAndYear();
            this.countries$ = this.userPaymentService.getAllBillingCountries().pipe(operators.tap(function (countries) {
                // If the store is empty fetch countries. This is also used when changing language.
                if (Object.keys(countries).length === 0) {
                    _this.userPaymentService.loadBillingCountries();
                }
            }));
            this.cardTypes$ = this.checkoutPaymentService.getCardTypes().pipe(operators.tap(function (cardTypes) {
                if (Object.keys(cardTypes).length === 0) {
                    _this.checkoutPaymentService.loadSupportedCardTypes();
                }
            }));
            this.shippingAddress$ = this.checkoutDeliveryService.getDeliveryAddress();
            this.loading$ = this.checkoutPaymentService.getSetPaymentDetailsResultProcess();
            this.showSameAsShippingAddressCheckbox$ = rxjs.combineLatest([
                this.countries$,
                this.shippingAddress$,
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), countries = _b[0], address = _b[1];
                return ((address === null || address === void 0 ? void 0 : address.country) &&
                    !!countries.filter(function (country) { return country.isocode === address.country.isocode; }).length);
            }), operators.tap(function (shouldShowCheckbox) {
                _this.sameAsShippingAddress = shouldShowCheckbox;
            }));
            // verify the new added address
            this.addressVerifySub = this.checkoutDeliveryService
                .getAddressVerificationResults()
                .subscribe(function (results) {
                if (results.decision === 'FAIL') {
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                }
                else if (results.decision === 'ACCEPT') {
                    _this.next();
                }
                else if (results.decision === 'REJECT') {
                    _this.globalMessageService.add({ key: 'addressForm.invalidAddress' }, i1.GlobalMessageType.MSG_TYPE_ERROR);
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                }
                else if (results.decision === 'REVIEW') {
                    _this.openSuggestedAddress(results);
                }
            });
            this.regions$ = this.selectedCountry$.pipe(operators.switchMap(function (country) { return _this.userAddressService.getRegions(country); }), operators.tap(function (regions) {
                var regionControl = _this.billingAddressForm.get('region.isocodeShort');
                if (regions.length > 0) {
                    regionControl.enable();
                }
                else {
                    regionControl.disable();
                }
            }));
        };
        PaymentFormComponent.prototype.expMonthAndYear = function () {
            var year = new Date().getFullYear();
            for (var i = 0; i < 10; i++) {
                this.years.push(year + i);
            }
            for (var j = 1; j <= 12; j++) {
                if (j < 10) {
                    this.months.push("0" + j);
                }
                else {
                    this.months.push(j.toString());
                }
            }
        };
        PaymentFormComponent.prototype.toggleDefaultPaymentMethod = function () {
            this.paymentForm.value.defaultPayment = !this.paymentForm.value
                .defaultPayment;
        };
        PaymentFormComponent.prototype.toggleSameAsShippingAddress = function () {
            this.sameAsShippingAddress = !this.sameAsShippingAddress;
        };
        PaymentFormComponent.prototype.getAddressCardContent = function (address) {
            var region = '';
            if (address.region && address.region.isocode) {
                region = address.region.isocode + ', ';
            }
            return {
                textBold: address.firstName + ' ' + address.lastName,
                text: [
                    address.line1,
                    address.line2,
                    address.town + ', ' + region + address.country.isocode,
                    address.postalCode,
                    address.phone,
                ],
            };
        };
        PaymentFormComponent.prototype.openSuggestedAddress = function (results) {
            var _this = this;
            if (!this.suggestedAddressModalRef) {
                this.suggestedAddressModalRef = this.modalService.open(SuggestedAddressDialogComponent, { centered: true, size: 'lg' });
                this.suggestedAddressModalRef.componentInstance.enteredAddress = this.billingAddressForm.value;
                this.suggestedAddressModalRef.componentInstance.suggestedAddresses =
                    results.suggestedAddresses;
                this.suggestedAddressModalRef.result
                    .then(function () {
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                    _this.suggestedAddressModalRef = null;
                })
                    .catch(function () {
                    // this  callback is called when modal is closed with Esc key or clicking backdrop
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                    _this.suggestedAddressModalRef = null;
                });
            }
        };
        PaymentFormComponent.prototype.close = function () {
            this.closeForm.emit();
        };
        PaymentFormComponent.prototype.back = function () {
            this.goBack.emit();
        };
        PaymentFormComponent.prototype.verifyAddress = function () {
            if (this.sameAsShippingAddress) {
                this.next();
            }
            else {
                this.checkoutDeliveryService.verifyAddress(this.billingAddressForm.value);
            }
        };
        PaymentFormComponent.prototype.countrySelected = function (country) {
            this.billingAddressForm.get('country.isocode').setValue(country.isocode);
            this.selectedCountry$.next(country.isocode);
        };
        PaymentFormComponent.prototype.next = function () {
            if (this.paymentForm.valid) {
                if (this.sameAsShippingAddress) {
                    this.setPaymentDetails.emit({
                        paymentDetails: this.paymentForm.value,
                        billingAddress: null,
                    });
                }
                else {
                    if (this.billingAddressForm.valid) {
                        this.setPaymentDetails.emit({
                            paymentDetails: this.paymentForm.value,
                            billingAddress: this.billingAddressForm.value,
                        });
                    }
                    else {
                        this.billingAddressForm.markAllAsTouched();
                    }
                }
            }
            else {
                this.paymentForm.markAllAsTouched();
                if (!this.sameAsShippingAddress) {
                    this.billingAddressForm.markAllAsTouched();
                }
            }
        };
        PaymentFormComponent.prototype.ngOnDestroy = function () {
            if (this.addressVerifySub) {
                this.addressVerifySub.unsubscribe();
            }
        };
        return PaymentFormComponent;
    }());
    PaymentFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-payment-form',
                    template: "<!-- FORM -->\n<ng-container *ngIf=\"!(loading$ | async).loading; else spinner\">\n  <form (ngSubmit)=\"next()\" [formGroup]=\"paymentForm\">\n    <div class=\"row\">\n      <div class=\"col-md-12 col-xl-10\">\n        <div class=\"form-group\" formGroupName=\"cardType\">\n          <ng-container *ngIf=\"cardTypes$ | async as cardTypes\">\n            <div *ngIf=\"cardTypes.length !== 0\">\n              <label aria-required=\"true\">\n                <span class=\"label-content required\">{{\n                  'paymentForm.paymentType' | cxTranslate\n                }}</span>\n                <ng-select\n                  [searchable]=\"false\"\n                  [clearable]=\"false\"\n                  [items]=\"cardTypes\"\n                  bindLabel=\"name\"\n                  bindValue=\"code\"\n                  placeholder=\"{{ 'paymentForm.selectOne' | cxTranslate }}\"\n                  formControlName=\"code\"\n                >\n                </ng-select>\n                <cx-form-errors\n                  [control]=\"paymentForm.get('cardType.code')\"\n                ></cx-form-errors>\n              </label>\n            </div>\n          </ng-container>\n        </div>\n\n        <div class=\"form-group\">\n          <label>\n            <span class=\"label-content\">{{\n              'paymentForm.accountHolderName.label' | cxTranslate\n            }}</span>\n            <input\n              class=\"form-control\"\n              type=\"text\"\n              placeholder=\"{{\n                'paymentForm.accountHolderName.placeholder' | cxTranslate\n              }}\"\n              formControlName=\"accountHolderName\"\n            />\n            <cx-form-errors\n              [control]=\"paymentForm.get('accountHolderName')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n\n        <div class=\"form-group\">\n          <label>\n            <span class=\"label-content\">{{\n              'paymentForm.cardNumber' | cxTranslate\n            }}</span>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              formControlName=\"cardNumber\"\n            />\n            <cx-form-errors\n              [control]=\"paymentForm.get('cardNumber')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"form-group col-md-8\">\n            <label>\n              <span class=\"label-content\">{{\n                'paymentForm.expirationDate' | cxTranslate\n              }}</span>\n              <div class=\"cx-payment-form-exp-date\">\n                <div class=\"cx-payment-form-exp-date-wrapper\">\n                  <ng-select\n                    [searchable]=\"false\"\n                    [clearable]=\"false\"\n                    [items]=\"months\"\n                    placeholder=\"{{ 'paymentForm.monthMask' | cxTranslate }}\"\n                    formControlName=\"expiryMonth\"\n                  >\n                  </ng-select>\n                  <cx-form-errors\n                    [control]=\"paymentForm.get('expiryMonth')\"\n                  ></cx-form-errors>\n                </div>\n                <div class=\"cx-payment-form-exp-date-wrapper\">\n                  <ng-select\n                    [searchable]=\"false\"\n                    [clearable]=\"false\"\n                    [items]=\"years\"\n                    placeholder=\"{{ 'paymentForm.yearMask' | cxTranslate }}\"\n                    formControlName=\"expiryYear\"\n                  >\n                  </ng-select>\n                  <cx-form-errors\n                    [control]=\"paymentForm.get('expiryYear')\"\n                  ></cx-form-errors>\n                </div>\n              </div>\n            </label>\n          </div>\n\n          <div class=\"form-group col-md-4\">\n            <label>\n              <span class=\"label-content\">\n                {{ 'paymentForm.securityCode' | cxTranslate }}\n                <cx-icon\n                  [type]=\"iconTypes.INFO\"\n                  class=\"cx-payment-form-tooltip\"\n                  placement=\"right\"\n                  title=\"{{ 'paymentForm.securityCodeTitle' | cxTranslate }}\"\n                  alt=\"\"\n                ></cx-icon>\n              </span>\n              <input\n                type=\"text\"\n                class=\"form-control\"\n                id=\"cVVNumber\"\n                formControlName=\"cvn\"\n              />\n              <cx-form-errors\n                [control]=\"paymentForm.get('cvn')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n        </div>\n\n        <div class=\"form-group\" *ngIf=\"setAsDefaultField\">\n          <div class=\"form-check\">\n            <label>\n              <input\n                type=\"checkbox\"\n                class=\"form-check-input\"\n                (change)=\"toggleDefaultPaymentMethod()\"\n              />\n              <span class=\"form-check-label\">{{\n                'paymentForm.setAsDefault' | cxTranslate\n              }}</span>\n            </label>\n          </div>\n        </div>\n\n        <!-- BILLING -->\n        <div class=\"cx-payment-form-billing\">\n          <div class=\"cx-payment-form-billing-address\">\n            {{ 'paymentForm.billingAddress' | cxTranslate }}\n          </div>\n\n          <!-- SAME AS SHIPPING CHECKBOX -->\n          <ng-container *ngIf=\"showSameAsShippingAddressCheckbox$ | async\">\n            <div class=\"form-group\">\n              <div class=\"form-check\">\n                <label>\n                  <input\n                    type=\"checkbox\"\n                    class=\"form-check-input\"\n                    [checked]=\"sameAsShippingAddress\"\n                    (change)=\"toggleSameAsShippingAddress()\"\n                  />\n                  <span class=\"form-check-label\">{{\n                    'paymentForm.sameAsShippingAddress' | cxTranslate\n                  }}</span>\n                </label>\n              </div>\n            </div>\n          </ng-container>\n\n          <!-- BILLING INFO COMPONENT -->\n          <ng-container\n            *ngIf=\"\n              sameAsShippingAddress && shippingAddress$\n                | async as shippingAddress;\n              else billingAddress\n            \"\n          >\n            <cx-card\n              [content]=\"getAddressCardContent(shippingAddress)\"\n            ></cx-card>\n          </ng-container>\n\n          <ng-template #billingAddress>\n            <div [formGroup]=\"billingAddressForm\">\n              <div class=\"form-group\" formGroupName=\"country\">\n                <ng-container *ngIf=\"countries$ | async as countries\">\n                  <div *ngIf=\"countries.length !== 0\">\n                    <label aria-required=\"true\">\n                      <span class=\"label-content required\">{{\n                        'addressForm.country' | cxTranslate\n                      }}</span>\n                      <ng-select\n                        [searchable]=\"true\"\n                        [clearable]=\"false\"\n                        [items]=\"countries\"\n                        bindLabel=\"name\"\n                        bindValue=\"isocode\"\n                        placeholder=\"{{\n                          'addressForm.selectOne' | cxTranslate\n                        }}\"\n                        (change)=\"countrySelected($event)\"\n                        formControlName=\"isocode\"\n                      >\n                      </ng-select>\n                      <cx-form-errors\n                        [control]=\"billingAddressForm.get('country.isocode')\"\n                      ></cx-form-errors>\n                    </label>\n                  </div>\n                </ng-container>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content required\">{{\n                    'addressForm.firstName.label' | cxTranslate\n                  }}</span>\n                  <input\n                    class=\"form-control\"\n                    type=\"text\"\n                    placeholder=\"{{\n                      'addressForm.firstName.placeholder' | cxTranslate\n                    }}\"\n                    formControlName=\"firstName\"\n                  />\n                  <cx-form-errors\n                    [control]=\"billingAddressForm.get('firstName')\"\n                  ></cx-form-errors>\n                </label>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content required\">{{\n                    'addressForm.lastName.label' | cxTranslate\n                  }}</span>\n                  <input\n                    type=\"text\"\n                    class=\"form-control\"\n                    placeholder=\"{{\n                      'addressForm.lastName.placeholder' | cxTranslate\n                    }}\"\n                    formControlName=\"lastName\"\n                  />\n                  <cx-form-errors\n                    [control]=\"billingAddressForm.get('lastName')\"\n                  ></cx-form-errors>\n                </label>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content required\">{{\n                    'addressForm.address1' | cxTranslate\n                  }}</span>\n                  <input\n                    type=\"text\"\n                    class=\"form-control\"\n                    placeholder=\"{{\n                      'addressForm.streetAddress' | cxTranslate\n                    }}\"\n                    formControlName=\"line1\"\n                  />\n                  <cx-form-errors\n                    [control]=\"billingAddressForm.get('line1')\"\n                  ></cx-form-errors>\n                </label>\n              </div>\n              <div class=\"form-group\">\n                <label>\n                  <span class=\"label-content\">{{\n                    'addressForm.address2' | cxTranslate\n                  }}</span>\n                  <input\n                    type=\"text\"\n                    class=\"form-control\"\n                    placeholder=\"{{ 'addressForm.aptSuite' | cxTranslate }}\"\n                    formControlName=\"line2\"\n                  />\n                </label>\n              </div>\n              <div class=\"row\">\n                <div class=\"form-group col-md-6\">\n                  <label>\n                    <span class=\"label-content required\">{{\n                      'addressForm.city.label' | cxTranslate\n                    }}</span>\n                    <input\n                      type=\"text\"\n                      class=\"form-control\"\n                      placeholder=\"{{\n                        'addressForm.city.placeholder' | cxTranslate\n                      }}\"\n                      formControlName=\"town\"\n                    />\n                    <cx-form-errors\n                      [control]=\"billingAddressForm.get('town')\"\n                    ></cx-form-errors>\n                  </label>\n                </div>\n                <div class=\"form-group col-md-6\">\n                  <label>\n                    <span class=\"label-content required\">{{\n                      'addressForm.zipCode.label' | cxTranslate\n                    }}</span>\n                    <input\n                      type=\"text\"\n                      class=\"form-control\"\n                      placeholder=\"{{\n                        'addressForm.zipCode.placeholder' | cxTranslate\n                      }}\"\n                      formControlName=\"postalCode\"\n                    />\n                    <cx-form-errors\n                      [control]=\"billingAddressForm.get('postalCode')\"\n                    ></cx-form-errors>\n                  </label>\n                </div>\n                <ng-container\n                  *ngIf=\"regions$ | async as regions\"\n                  formGroupName=\"region\"\n                >\n                  <ng-container *ngIf=\"regions.length !== 0\">\n                    <div class=\"form-group col-md-6\">\n                      <label aria-required=\"true\">\n                        <span class=\"label-content required\">{{\n                          'addressForm.state' | cxTranslate\n                        }}</span>\n                        <ng-select\n                          class=\"region-select\"\n                          formControlName=\"isocodeShort\"\n                          [searchable]=\"true\"\n                          [clearable]=\"false\"\n                          [items]=\"regions\"\n                          bindLabel=\"{{\n                            regions[0].name ? 'name' : 'isocodeShort'\n                          }}\"\n                          bindValue=\"{{\n                            regions[0].name ? 'isocodeShort' : 'region'\n                          }}\"\n                          placeholder=\"{{\n                            'addressForm.selectOne' | cxTranslate\n                          }}\"\n                        >\n                        </ng-select>\n                        <cx-form-errors\n                          [control]=\"\n                            billingAddressForm.get('region.isocodeShort')\n                          \"\n                        ></cx-form-errors>\n                      </label>\n                    </div>\n                  </ng-container>\n                </ng-container>\n              </div>\n            </div>\n          </ng-template>\n        </div>\n      </div>\n    </div>\n\n    <!-- BUTTON SECTION -->\n    <div class=\"cx-checkout-btns row\">\n      <div class=\"col-md-12 col-lg-6\">\n        <button\n          *ngIf=\"paymentMethodsCount === 0\"\n          class=\"btn btn-block btn-action\"\n          (click)=\"back()\"\n        >\n          {{ 'common.back' | cxTranslate }}\n        </button>\n        <button\n          *ngIf=\"paymentMethodsCount > 0\"\n          class=\"btn btn-block btn-action\"\n          (click)=\"close()\"\n        >\n          {{ 'paymentForm.changePayment' | cxTranslate }}\n        </button>\n      </div>\n      <div class=\"col-md-12 col-lg-6\">\n        <button class=\"btn btn-block btn-primary\" type=\"submit\">\n          {{ 'common.continue' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n  </form>\n</ng-container>\n\n<ng-template #spinner>\n  <cx-spinner></cx-spinner>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PaymentFormComponent.ctorParameters = function () { return [
        { type: i1.CheckoutPaymentService },
        { type: i1.CheckoutDeliveryService },
        { type: i1.UserPaymentService },
        { type: i1.GlobalMessageService },
        { type: forms.FormBuilder },
        { type: ModalService },
        { type: i1.UserAddressService }
    ]; };
    PaymentFormComponent.propDecorators = {
        setAsDefaultField: [{ type: i0.Input }],
        paymentMethodsCount: [{ type: i0.Input }],
        goBack: [{ type: i0.Output }],
        closeForm: [{ type: i0.Output }],
        setPaymentDetails: [{ type: i0.Output }]
    };

    var PaymentFormModule = /** @class */ (function () {
        function PaymentFormModule() {
        }
        return PaymentFormModule;
    }());
    PaymentFormModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        ngSelect.NgSelectModule,
                        CardModule,
                        i1.I18nModule,
                        IconModule,
                        SpinnerModule,
                        FormErrorsModule,
                    ],
                    declarations: [PaymentFormComponent],
                    entryComponents: [PaymentFormComponent],
                    exports: [PaymentFormComponent],
                },] }
    ];

    var PaymentMethodComponent = /** @class */ (function () {
        function PaymentMethodComponent(userPaymentService, checkoutService, checkoutDeliveryService, checkoutPaymentService, globalMessageService, activatedRoute, translation, activeCartService, checkoutStepService) {
            this.userPaymentService = userPaymentService;
            this.checkoutService = checkoutService;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.checkoutPaymentService = checkoutPaymentService;
            this.globalMessageService = globalMessageService;
            this.activatedRoute = activatedRoute;
            this.translation = translation;
            this.activeCartService = activeCartService;
            this.checkoutStepService = checkoutStepService;
            this.iconTypes = exports.ICON_TYPE;
            this.isGuestCheckout = false;
            this.newPaymentFormManuallyOpened = false;
            this.backBtnText = this.checkoutStepService.getBackBntText(this.activatedRoute);
        }
        PaymentMethodComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.shouldRedirect = false;
            this.isLoading$ = this.userPaymentService.getPaymentMethodsLoading();
            if (!this.activeCartService.isGuestCart()) {
                this.userPaymentService.loadPaymentMethods();
            }
            else {
                this.isGuestCheckout = true;
            }
            this.checkoutDeliveryService
                .getDeliveryAddress()
                .pipe(operators.take(1))
                .subscribe(function (address) {
                _this.deliveryAddress = address;
            });
            this.existingPaymentMethods$ = this.userPaymentService.getPaymentMethods();
            this.selectedMethod$ = this.checkoutPaymentService.getPaymentDetails().pipe(operators.tap(function (paymentInfo) {
                if (paymentInfo && !!Object.keys(paymentInfo).length) {
                    if (paymentInfo['hasError']) {
                        Object.keys(paymentInfo).forEach(function (key) {
                            if (key.startsWith('InvalidField')) {
                                _this.sendPaymentMethodFailGlobalMessage(paymentInfo[key]);
                            }
                        });
                        _this.checkoutService.clearCheckoutStep(3);
                    }
                    else if (_this.shouldRedirect) {
                        _this.next();
                    }
                }
            }));
            this.cards$ = rxjs.combineLatest([
                this.existingPaymentMethods$.pipe(operators.switchMap(function (methods) {
                    return !(methods === null || methods === void 0 ? void 0 : methods.length)
                        ? rxjs.of([])
                        : rxjs.combineLatest(methods.map(function (method) { return rxjs.combineLatest([
                            rxjs.of(method),
                            _this.translation.translate('paymentCard.expires', {
                                month: method.expiryMonth,
                                year: method.expiryYear,
                            }),
                        ]).pipe(operators.map(function (_a) {
                            var _b = __read(_a, 2), payment = _b[0], translation = _b[1];
                            return ({
                                payment: payment,
                                expiryTranslation: translation,
                            });
                        })); }));
                })),
                this.selectedMethod$,
                this.translation.translate('paymentForm.useThisPayment'),
                this.translation.translate('paymentCard.defaultPaymentMethod'),
                this.translation.translate('paymentCard.selected'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 5), paymentMethods = _b[0], selectedMethod = _b[1], textUseThisPayment = _b[2], textDefaultPaymentMethod = _b[3], textSelected = _b[4];
                if (paymentMethods.length &&
                    (!selectedMethod || Object.keys(selectedMethod).length === 0)) {
                    var defaultPaymentMethod = paymentMethods.find(function (paymentMethod) { return paymentMethod.payment.defaultPayment; });
                    if (defaultPaymentMethod) {
                        selectedMethod = defaultPaymentMethod.payment;
                        _this.checkoutPaymentService.setPaymentDetails(selectedMethod);
                    }
                }
                return paymentMethods.map(function (payment) { return ({
                    content: _this.createCard(payment.payment, {
                        textExpires: payment.expiryTranslation,
                        textUseThisPayment: textUseThisPayment,
                        textDefaultPaymentMethod: textDefaultPaymentMethod,
                        textSelected: textSelected,
                    }, selectedMethod),
                    paymentMethod: payment.payment,
                }); });
            }));
        };
        PaymentMethodComponent.prototype.selectPaymentMethod = function (paymentDetails) {
            this.checkoutPaymentService.setPaymentDetails(paymentDetails);
        };
        PaymentMethodComponent.prototype.showNewPaymentForm = function () {
            this.newPaymentFormManuallyOpened = true;
        };
        PaymentMethodComponent.prototype.hideNewPaymentForm = function () {
            this.newPaymentFormManuallyOpened = false;
        };
        PaymentMethodComponent.prototype.setPaymentDetails = function (_a) {
            var paymentDetails = _a.paymentDetails, billingAddress = _a.billingAddress;
            var details = Object.assign({}, paymentDetails);
            details.billingAddress = billingAddress || this.deliveryAddress;
            this.checkoutPaymentService.createPaymentDetails(details);
            this.shouldRedirect = true;
        };
        PaymentMethodComponent.prototype.ngOnDestroy = function () {
            this.checkoutPaymentService.paymentProcessSuccess();
        };
        PaymentMethodComponent.prototype.getCardIcon = function (code) {
            var ccIcon;
            if (code === 'visa') {
                ccIcon = this.iconTypes.VISA;
            }
            else if (code === 'master' || code === 'mastercard_eurocard') {
                ccIcon = this.iconTypes.MASTER_CARD;
            }
            else if (code === 'diners') {
                ccIcon = this.iconTypes.DINERS_CLUB;
            }
            else if (code === 'amex') {
                ccIcon = this.iconTypes.AMEX;
            }
            else {
                ccIcon = this.iconTypes.CREDIT_CARD;
            }
            return ccIcon;
        };
        PaymentMethodComponent.prototype.sendPaymentMethodFailGlobalMessage = function (field) {
            this.globalMessageService.add({
                key: 'paymentMethods.invalidField',
                params: { field: field },
            }, i1.GlobalMessageType.MSG_TYPE_ERROR);
        };
        PaymentMethodComponent.prototype.createCard = function (paymentDetails, cardLabels, selected) {
            return {
                title: paymentDetails.defaultPayment
                    ? cardLabels.textDefaultPaymentMethod
                    : '',
                textBold: paymentDetails.accountHolderName,
                text: [paymentDetails.cardNumber, cardLabels.textExpires],
                img: this.getCardIcon(paymentDetails.cardType.code),
                actions: [{ name: cardLabels.textUseThisPayment, event: 'send' }],
                header: (selected === null || selected === void 0 ? void 0 : selected.id) === paymentDetails.id
                    ? cardLabels.textSelected
                    : undefined,
            };
        };
        PaymentMethodComponent.prototype.next = function () {
            this.checkoutStepService.next(this.activatedRoute);
        };
        PaymentMethodComponent.prototype.back = function () {
            this.checkoutStepService.back(this.activatedRoute);
        };
        return PaymentMethodComponent;
    }());
    PaymentMethodComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-payment-method',
                    template: "<ng-container *ngIf=\"cards$ | async as cards\">\n  <h3 class=\"cx-checkout-title d-none d-lg-block d-xl-block\">\n    {{ 'paymentForm.payment' | cxTranslate }}\n  </h3>\n  <ng-container *ngIf=\"!(isLoading$ | async); else loading\">\n    <ng-container\n      *ngIf=\"\n        cards?.length && !newPaymentFormManuallyOpened;\n        else newPaymentForm\n      \"\n    >\n      <p class=\"cx-checkout-text\">\n        {{ 'paymentForm.choosePaymentMethod' | cxTranslate }}\n      </p>\n      <div class=\"cx-checkout-btns row\">\n        <div class=\"col-md-12 col-lg-6\">\n          <button\n            class=\"btn btn-block btn-action\"\n            (click)=\"showNewPaymentForm()\"\n          >\n            {{ 'paymentForm.addNewPayment' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"cx-checkout-body row\">\n        <div\n          class=\"cx-payment-card col-md-12 col-lg-6\"\n          *ngFor=\"let card of cards; let i = index\"\n        >\n          <div class=\"cx-payment-card-inner\">\n            <cx-card\n              [border]=\"true\"\n              [fitToContainer]=\"true\"\n              [content]=\"card.content\"\n              (sendCard)=\"selectPaymentMethod(card.paymentMethod)\"\n            ></cx-card>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"row cx-checkout-btns\">\n        <div class=\"col-md-12 col-lg-6\">\n          <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n            {{ backBtnText | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-md-12 col-lg-6\">\n          <button\n            class=\"btn btn-block btn-primary\"\n            [disabled]=\"!(selectedMethod$ | async)?.id\"\n            (click)=\"next()\"\n          >\n            {{ 'common.continue' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </ng-container>\n\n    <ng-template #newPaymentForm>\n      <cx-payment-form\n        (setPaymentDetails)=\"setPaymentDetails($event)\"\n        (closeForm)=\"hideNewPaymentForm()\"\n        (goBack)=\"back()\"\n        [paymentMethodsCount]=\"cards?.length || 0\"\n        [setAsDefaultField]=\"!isGuestCheckout\"\n      ></cx-payment-form>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\"><cx-spinner></cx-spinner></div>\n  </ng-template>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PaymentMethodComponent.ctorParameters = function () { return [
        { type: i1.UserPaymentService },
        { type: i1.CheckoutService },
        { type: i1.CheckoutDeliveryService },
        { type: i1.CheckoutPaymentService },
        { type: i1.GlobalMessageService },
        { type: i4.ActivatedRoute },
        { type: i1.TranslationService },
        { type: i1.ActiveCartService },
        { type: CheckoutStepService }
    ]; };

    var PaymentMethodModule = /** @class */ (function () {
        function PaymentMethodModule() {
        }
        return PaymentMethodModule;
    }());
    PaymentMethodModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        PaymentFormModule,
                        CardModule,
                        SpinnerModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutPaymentDetails: {
                                    component: PaymentMethodComponent,
                                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard and others here?
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PaymentMethodComponent],
                    entryComponents: [PaymentMethodComponent],
                    exports: [PaymentMethodComponent],
                },] }
    ];

    var PaymentTypeComponent = /** @class */ (function () {
        function PaymentTypeComponent(paymentTypeService, checkoutStepService, activatedRoute) {
            var _this = this;
            this.paymentTypeService = paymentTypeService;
            this.checkoutStepService = checkoutStepService;
            this.activatedRoute = activatedRoute;
            this.paymentTypes$ = this.paymentTypeService.getPaymentTypes();
            this.typeSelected$ = this.paymentTypeService.getSelectedPaymentType().pipe(operators.filter(function (selected) { return selected !== undefined; }), operators.distinctUntilChanged(), operators.tap(function (selected) {
                _this.typeSelected = selected;
                _this.checkoutStepService.resetSteps();
                _this.checkoutStepService.disableEnableStep(exports.CheckoutStepType.PAYMENT_DETAILS, selected === i1.B2BPaymentTypeEnum.ACCOUNT_PAYMENT);
            }));
            this.cartPoNumber$ = this.paymentTypeService.getPoNumber().pipe(operators.filter(function (po) { return po !== undefined; }), operators.tap(function (po) {
                return (_this.cartPoNumber = po);
            }));
        }
        PaymentTypeComponent.prototype.changeType = function (code) {
            this.paymentTypeService.setPaymentType(code);
            this.typeSelected = code;
        };
        PaymentTypeComponent.prototype.next = function () {
            // set po number to cart
            var poNumInput = this._poNumberInput.nativeElement.value;
            if (this.typeSelected && poNumInput !== this.cartPoNumber) {
                this.paymentTypeService.setPaymentType(this.typeSelected, poNumInput);
            }
            this.checkoutStepService.next(this.activatedRoute);
        };
        PaymentTypeComponent.prototype.back = function () {
            this.checkoutStepService.back(this.activatedRoute);
        };
        return PaymentTypeComponent;
    }());
    PaymentTypeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-payment-type',
                    template: "<div class=\"row\">\n  <div class=\"col-md-12 col-lg-6\">\n    <label>\n      <span class=\"label-content\">{{\n        'checkoutPO.poNumber' | cxTranslate\n      }}</span>\n      <input\n        #poNumber\n        class=\"form-control\"\n        type=\"text\"\n        placeholder=\"{{ 'checkoutPO.placeholder' | cxTranslate }}\"\n        value=\"{{ cartPoNumber$ | async }}\"\n      />\n    </label>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"col-md-12 col-lg-6\">\n    <ng-container\n      *ngIf=\"\n        (paymentTypes$ | async)?.length && typeSelected$ | async;\n        else loading\n      \"\n    >\n      <label class=\"cx-payment-type-container\">\n        <span class=\"label-content\">{{\n          'paymentTypes.title' | cxTranslate\n        }}</span>\n        <div class=\"form-check\" *ngFor=\"let type of paymentTypes$ | async\">\n          <input\n            id=\"paymentType-{{ type.code }}\"\n            class=\"form-check-input\"\n            role=\"radio\"\n            type=\"radio\"\n            aria-checked=\"true\"\n            (change)=\"changeType(type.code)\"\n            [value]=\"type.code\"\n            [checked]=\"type.code == typeSelected\"\n          />\n          <label\n            class=\"cx-payment-type-label form-check-label form-radio-label\"\n            for=\"paymentType-{{ type.code }}\"\n          >\n            <div class=\"cx-payment-type\">\n              {{\n                'paymentTypes.paymentType' | cxTranslate: { context: type.code }\n              }}\n            </div>\n          </label>\n        </div>\n      </label>\n    </ng-container>\n  </div>\n</div>\n\n<div class=\"cx-checkout-btns row\">\n  <div class=\"col-md-12 col-lg-6\">\n    <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n      {{ 'checkout.backToCart' | cxTranslate }}\n    </button>\n  </div>\n  <div class=\"col-md-12 col-lg-6\">\n    <button class=\"btn btn-block btn-primary\" (click)=\"next()\">\n      {{ 'common.continue' | cxTranslate }}\n    </button>\n  </div>\n</div>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PaymentTypeComponent.ctorParameters = function () { return [
        { type: i1.PaymentTypeService },
        { type: CheckoutStepService },
        { type: i4.ActivatedRoute }
    ]; };
    PaymentTypeComponent.propDecorators = {
        _poNumberInput: [{ type: i0.ViewChild, args: ['poNumber', { static: false },] }]
    };

    var PaymentTypeModule = /** @class */ (function () {
        function PaymentTypeModule() {
        }
        return PaymentTypeModule;
    }());
    PaymentTypeModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        SpinnerModule,
                        i1.ConfigModule.withConfig({
                            cmsComponents: {
                                CheckoutPaymentType: {
                                    component: PaymentTypeComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PaymentTypeComponent],
                    entryComponents: [PaymentTypeComponent],
                    exports: [PaymentTypeComponent],
                },] }
    ];

    var defaultPlaceOrderSpinnerLayoutConfig = {
        launch: {
            PLACE_ORDER_SPINNER: {
                inline: true,
                component: SpinnerComponent,
                dialogType: exports.DIALOG_TYPE.POPOVER_CENTER_BACKDROP,
            },
        },
    };

    var CheckoutReplenishmentFormService = /** @class */ (function () {
        function CheckoutReplenishmentFormService() {
            /**
             * Default form data
             */
            this.defaultFormData = {
                daysOfWeek: [i1.DaysOfWeek.MONDAY],
                nthDayOfMonth: '1',
                numberOfDays: '14',
                numberOfWeeks: '1',
                recurrencePeriod: i1.recurrencePeriod.DAILY,
                replenishmentStartDate: new Date().toISOString(),
            };
            this.scheduleReplenishmentFormData$ = new rxjs.BehaviorSubject(this.defaultFormData);
        }
        CheckoutReplenishmentFormService.prototype.getScheduleReplenishmentFormData = function () {
            return this.scheduleReplenishmentFormData$.asObservable();
        };
        CheckoutReplenishmentFormService.prototype.setScheduleReplenishmentFormData = function (formData) {
            this.scheduleReplenishmentFormData$.next(formData);
        };
        CheckoutReplenishmentFormService.prototype.resetScheduleReplenishmentFormData = function () {
            this.scheduleReplenishmentFormData$.next(this.defaultFormData);
        };
        return CheckoutReplenishmentFormService;
    }());
    CheckoutReplenishmentFormService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CheckoutReplenishmentFormService_Factory() { return new CheckoutReplenishmentFormService(); }, token: CheckoutReplenishmentFormService, providedIn: "root" });
    CheckoutReplenishmentFormService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CheckoutReplenishmentFormService.ctorParameters = function () { return []; };

    var PlaceOrderComponent = /** @class */ (function () {
        function PlaceOrderComponent(checkoutService, checkoutReplenishmentFormService, routingService, launchDialogService, fb, vcr) {
            this.checkoutService = checkoutService;
            this.checkoutReplenishmentFormService = checkoutReplenishmentFormService;
            this.routingService = routingService;
            this.launchDialogService = launchDialogService;
            this.fb = fb;
            this.vcr = vcr;
            this.subscription = new rxjs.Subscription();
            this.daysOfWeekNotChecked$ = new rxjs.BehaviorSubject(false);
            this.checkoutSubmitForm = this.fb.group({
                termsAndConditions: [false, forms.Validators.requiredTrue],
            });
        }
        Object.defineProperty(PlaceOrderComponent.prototype, "termsAndConditionInvalid", {
            get: function () {
                return this.checkoutSubmitForm.invalid;
            },
            enumerable: false,
            configurable: true
        });
        PlaceOrderComponent.prototype.submitForm = function () {
            if (this.checkoutSubmitForm.valid && Boolean(this.currentOrderType)) {
                switch (this.currentOrderType) {
                    case i1.ORDER_TYPE.PLACE_ORDER: {
                        this.checkoutService.placeOrder(this.checkoutSubmitForm.valid);
                        break;
                    }
                    case i1.ORDER_TYPE.SCHEDULE_REPLENISHMENT_ORDER: {
                        this.checkoutService.scheduleReplenishmentOrder(this.scheduleReplenishmentFormData, this.checkoutSubmitForm.valid);
                        break;
                    }
                }
            }
            else {
                this.checkoutSubmitForm.markAllAsTouched();
            }
        };
        PlaceOrderComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(rxjs.combineLatest([
                this.checkoutService.getPlaceOrderLoading(),
                this.checkoutService.getPlaceOrderSuccess(),
                this.checkoutService.getPlaceOrderError(),
            ]).subscribe(function (_a) {
                var _b = __read(_a, 3), orderLoading = _b[0], orderSuccess = _b[1], orderError = _b[2];
                if (orderLoading) {
                    _this.placedOrder = _this.launchDialogService.launch(exports.LAUNCH_CALLER.PLACE_ORDER_SPINNER, _this.vcr);
                }
                if (orderError) {
                    if (_this.placedOrder) {
                        _this.placedOrder
                            .subscribe(function (component) {
                            _this.launchDialogService.clear(exports.LAUNCH_CALLER.PLACE_ORDER_SPINNER);
                            component.destroy();
                        })
                            .unsubscribe();
                        _this.checkoutService.clearPlaceOrderState();
                    }
                }
                if (orderSuccess) {
                    _this.onSuccess(orderSuccess);
                }
            }));
            this.subscription.add(this.checkoutService
                .getCurrentOrderType()
                .subscribe(function (orderType) { return (_this.currentOrderType = orderType); }));
            this.subscription.add(this.checkoutReplenishmentFormService
                .getScheduleReplenishmentFormData()
                .subscribe(function (data) {
                _this.scheduleReplenishmentFormData = data;
                _this.daysOfWeekNotChecked$.next(data.daysOfWeek.length === 0 &&
                    data.recurrencePeriod === i1.recurrencePeriod.WEEKLY);
            }));
        };
        PlaceOrderComponent.prototype.onSuccess = function (data) {
            if (data) {
                switch (this.currentOrderType) {
                    case i1.ORDER_TYPE.PLACE_ORDER: {
                        this.routingService.go({ cxRoute: 'orderConfirmation' });
                        break;
                    }
                    case i1.ORDER_TYPE.SCHEDULE_REPLENISHMENT_ORDER: {
                        this.routingService.go({ cxRoute: 'replenishmentConfirmation' });
                        break;
                    }
                }
                this.checkoutReplenishmentFormService.resetScheduleReplenishmentFormData();
            }
        };
        PlaceOrderComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.launchDialogService.clear(exports.LAUNCH_CALLER.PLACE_ORDER_SPINNER);
            this.checkoutService.clearPlaceOrderState();
        };
        return PlaceOrderComponent;
    }());
    PlaceOrderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-place-order',
                    template: "<form\n  (ngSubmit)=\"submitForm()\"\n  class=\"cx-place-order-form form-check\"\n  [formGroup]=\"checkoutSubmitForm\"\n>\n  <div class=\"form-group\">\n    <label>\n      <input\n        formControlName=\"termsAndConditions\"\n        class=\"scaled-input form-check-input\"\n        type=\"checkbox\"\n      />\n      <span class=\"form-check-label\">\n        {{ 'checkoutReview.confirmThatRead' | cxTranslate }}\n        <a\n          [routerLink]=\"{ cxRoute: 'termsAndConditions' } | cxUrl\"\n          class=\"cx-tc-link\"\n          target=\"_blank\"\n        >\n          {{ 'checkoutReview.termsAndConditions' | cxTranslate }}\n        </a>\n      </span>\n    </label>\n  </div>\n\n  <button\n    type=\"submit\"\n    class=\"btn btn-primary btn-block\"\n    [disabled]=\"termsAndConditionInvalid || (daysOfWeekNotChecked$ | async)\"\n  >\n    {{ 'checkoutReview.placeOrder' | cxTranslate }}\n  </button>\n</form>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PlaceOrderComponent.ctorParameters = function () { return [
        { type: i1.CheckoutService },
        { type: CheckoutReplenishmentFormService },
        { type: i1.RoutingService },
        { type: LaunchDialogService },
        { type: forms.FormBuilder },
        { type: i0.ViewContainerRef }
    ]; };

    var PlaceOrderModule = /** @class */ (function () {
        function PlaceOrderModule() {
        }
        return PlaceOrderModule;
    }());
    PlaceOrderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        forms.ReactiveFormsModule,
                    ],
                    providers: [
                        i1.provideConfig(defaultPlaceOrderSpinnerLayoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutPlaceOrder: {
                                    component: PlaceOrderComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PlaceOrderComponent],
                    entryComponents: [PlaceOrderComponent],
                    exports: [PlaceOrderComponent],
                },] }
    ];

    var ReviewSubmitComponent = /** @class */ (function () {
        function ReviewSubmitComponent(checkoutDeliveryService, checkoutPaymentService, userAddressService, activeCartService, translation, checkoutStepService, promotionService, paymentTypeService, checkoutCostCenterService, userCostCenterService) {
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.checkoutPaymentService = checkoutPaymentService;
            this.userAddressService = userAddressService;
            this.activeCartService = activeCartService;
            this.translation = translation;
            this.checkoutStepService = checkoutStepService;
            this.promotionService = promotionService;
            this.paymentTypeService = paymentTypeService;
            this.checkoutCostCenterService = checkoutCostCenterService;
            this.userCostCenterService = userCostCenterService;
            this.iconTypes = exports.ICON_TYPE;
            this.checkoutStepType = exports.CheckoutStepType;
            this.promotionLocation = i1.PromotionLocation.ActiveCart;
        }
        Object.defineProperty(ReviewSubmitComponent.prototype, "cart$", {
            get: function () {
                return this.activeCartService.getActive();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "entries$", {
            get: function () {
                return this.activeCartService.getEntries();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "steps$", {
            get: function () {
                return this.checkoutStepService.steps$;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "deliveryAddress$", {
            get: function () {
                return this.checkoutDeliveryService.getDeliveryAddress();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "deliveryMode$", {
            get: function () {
                var _this = this;
                return this.checkoutDeliveryService.getSelectedDeliveryMode().pipe(operators.tap(function (selected) {
                    if (selected === null) {
                        _this.checkoutDeliveryService.loadSupportedDeliveryModes();
                    }
                }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "paymentDetails$", {
            get: function () {
                return this.checkoutPaymentService.getPaymentDetails();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "orderPromotions$", {
            get: function () {
                return this.promotionService.getOrderPromotions(this.promotionLocation);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "countryName$", {
            get: function () {
                var _this = this;
                return this.deliveryAddress$.pipe(operators.switchMap(function (address) { var _a; return _this.userAddressService.getCountry((_a = address === null || address === void 0 ? void 0 : address.country) === null || _a === void 0 ? void 0 : _a.isocode); }), operators.tap(function (country) {
                    if (country === null) {
                        _this.userAddressService.loadDeliveryCountries();
                    }
                }), operators.map(function (country) { return country && country.name; }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "poNumber$", {
            get: function () {
                return this.paymentTypeService.getPoNumber();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "paymentType$", {
            get: function () {
                return this.paymentTypeService.getSelectedPaymentType();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "isAccountPayment$", {
            get: function () {
                return this.paymentTypeService.isAccountPayment();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReviewSubmitComponent.prototype, "costCenter$", {
            get: function () {
                var _this = this;
                return this.userCostCenterService.getActiveCostCenters().pipe(operators.filter(function (costCenters) { return Boolean(costCenters); }), operators.switchMap(function (costCenters) {
                    return _this.checkoutCostCenterService.getCostCenter().pipe(operators.map(function (code) {
                        return costCenters.find(function (cc) { return cc.code === code; });
                    }));
                }));
            },
            enumerable: false,
            configurable: true
        });
        ReviewSubmitComponent.prototype.getShippingAddressCard = function (deliveryAddress, countryName) {
            return rxjs.combineLatest([
                this.translation.translate('addressCard.shipTo'),
            ]).pipe(operators.map(function (_m) {
                var _o = __read(_m, 1), textTitle = _o[0];
                var _a;
                if (!countryName) {
                    countryName = (_a = deliveryAddress === null || deliveryAddress === void 0 ? void 0 : deliveryAddress.country) === null || _a === void 0 ? void 0 : _a.isocode;
                }
                var region = '';
                if (deliveryAddress &&
                    deliveryAddress.region &&
                    deliveryAddress.region.isocode) {
                    region = deliveryAddress.region.isocode + ', ';
                }
                return {
                    title: textTitle,
                    textBold: deliveryAddress.firstName + ' ' + deliveryAddress.lastName,
                    text: [
                        deliveryAddress.line1,
                        deliveryAddress.line2,
                        deliveryAddress.town + ', ' + region + countryName,
                        deliveryAddress.postalCode,
                        deliveryAddress.phone,
                    ],
                };
            }));
        };
        ReviewSubmitComponent.prototype.getCostCenterCard = function (costCenter) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutPO.costCenter'),
            ]).pipe(operators.map(function (_m) {
                var _o = __read(_m, 1), textTitle = _o[0];
                return {
                    title: textTitle,
                    textBold: costCenter === null || costCenter === void 0 ? void 0 : costCenter.name,
                    text: ['(' + (costCenter === null || costCenter === void 0 ? void 0 : costCenter.unit.name) + ')'],
                };
            }));
        };
        ReviewSubmitComponent.prototype.getDeliveryModeCard = function (deliveryMode) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutShipping.shippingMethod'),
            ]).pipe(operators.map(function (_m) {
                var _o = __read(_m, 1), textTitle = _o[0];
                var _a, _b;
                return {
                    title: textTitle,
                    textBold: deliveryMode.name,
                    text: [
                        deliveryMode.description,
                        ((_a = deliveryMode.deliveryCost) === null || _a === void 0 ? void 0 : _a.formattedValue) ? (_b = deliveryMode.deliveryCost) === null || _b === void 0 ? void 0 : _b.formattedValue : '',
                    ],
                };
            }));
        };
        ReviewSubmitComponent.prototype.getPaymentMethodCard = function (paymentDetails) {
            return rxjs.combineLatest([
                this.translation.translate('paymentForm.payment'),
                this.translation.translate('paymentCard.expires', {
                    month: paymentDetails.expiryMonth,
                    year: paymentDetails.expiryYear,
                }),
                this.translation.translate('paymentForm.billingAddress'),
            ]).pipe(operators.map(function (_m) {
                var _o = __read(_m, 3), textTitle = _o[0], textExpires = _o[1], billingAddress = _o[2];
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                var region = ((_b = (_a = paymentDetails.billingAddress) === null || _a === void 0 ? void 0 : _a.region) === null || _b === void 0 ? void 0 : _b.isocode) ? ((_d = (_c = paymentDetails.billingAddress) === null || _c === void 0 ? void 0 : _c.region) === null || _d === void 0 ? void 0 : _d.isocode) + ', '
                    : '';
                return {
                    title: textTitle,
                    textBold: paymentDetails.accountHolderName,
                    text: [paymentDetails.cardNumber, textExpires],
                    paragraphs: [
                        {
                            title: billingAddress + ':',
                            text: [
                                ((_e = paymentDetails.billingAddress) === null || _e === void 0 ? void 0 : _e.firstName) +
                                    ' ' + ((_f = paymentDetails.billingAddress) === null || _f === void 0 ? void 0 : _f.lastName),
                                (_g = paymentDetails.billingAddress) === null || _g === void 0 ? void 0 : _g.line1,
                                ((_h = paymentDetails.billingAddress) === null || _h === void 0 ? void 0 : _h.town) +
                                    ', ' +
                                    region + ((_k = (_j = paymentDetails.billingAddress) === null || _j === void 0 ? void 0 : _j.country) === null || _k === void 0 ? void 0 : _k.isocode),
                                (_l = paymentDetails.billingAddress) === null || _l === void 0 ? void 0 : _l.postalCode,
                            ],
                        },
                    ],
                };
            }));
        };
        ReviewSubmitComponent.prototype.getPoNumberCard = function (poNumber) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutReview.poNumber'),
                this.translation.translate('checkoutPO.noPoNumber'),
            ]).pipe(operators.map(function (_m) {
                var _o = __read(_m, 2), textTitle = _o[0], noneTextTitle = _o[1];
                return {
                    title: textTitle,
                    textBold: poNumber ? poNumber : noneTextTitle,
                };
            }));
        };
        ReviewSubmitComponent.prototype.getPaymentTypeCard = function (paymentType) {
            return rxjs.combineLatest([
                this.translation.translate('checkoutProgress.methodOfPayment'),
                this.translation.translate('paymentTypes.paymentType', {
                    context: paymentType,
                }),
            ]).pipe(operators.map(function (_m) {
                var _o = __read(_m, 2), textTitle = _o[0], paymentTypeTranslation = _o[1];
                return {
                    title: textTitle,
                    textBold: paymentTypeTranslation,
                };
            }));
        };
        ReviewSubmitComponent.prototype.getCheckoutStepUrl = function (stepType) {
            var step = this.checkoutStepService.getCheckoutStep(stepType);
            return step && step.routeName;
        };
        ReviewSubmitComponent.prototype.shippingSteps = function (steps) {
            return steps.filter(function (step) { return checkoutShippingSteps.includes(step.type[0]); });
        };
        ReviewSubmitComponent.prototype.paymentSteps = function (steps) {
            return steps.filter(function (step) { return checkoutPaymentSteps.includes(step.type[0]); });
        };
        return ReviewSubmitComponent;
    }());
    ReviewSubmitComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-review-submit',
                    template: "<div class=\"cx-review\">\n  <!-- TITLE -->\n  <h3 class=\"cx-review-title d-none d-lg-block d-xl-block\">\n    {{ 'checkoutReview.review' | cxTranslate }}\n  </h3>\n\n  <div class=\"cx-review-summary row\">\n    <ng-container *ngIf=\"(steps$ | async).slice(0, -1) as steps\">\n      <div class=\"col-md-12 col-lg-6 col-xl-6 cx-review-payment-col\">\n        <ng-container *ngFor=\"let step of paymentSteps(steps)\">\n          <ng-container [ngSwitch]=\"step.type[0]\">\n            <ng-container *ngSwitchCase=\"checkoutStepType.PAYMENT_TYPE\">\n              <ng-container *ngTemplateOutlet=\"poNumber\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.PAYMENT_TYPE\">\n              <ng-container *ngTemplateOutlet=\"paymentType\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.PAYMENT_DETAILS\">\n              <ng-container *ngTemplateOutlet=\"paymentMethod\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.SHIPPING_ADDRESS\">\n              <ng-container *ngTemplateOutlet=\"costCenter\"></ng-container>\n            </ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n      <div class=\"col-md-12 col-lg-6 col-xl-6 cx-review-shipping-col\">\n        <ng-container *ngFor=\"let step of shippingSteps(steps)\">\n          <ng-container [ngSwitch]=\"step.type[0]\">\n            <ng-container *ngSwitchCase=\"checkoutStepType.SHIPPING_ADDRESS\">\n              <ng-container *ngTemplateOutlet=\"shippingAddress\"></ng-container>\n            </ng-container>\n            <ng-container *ngSwitchCase=\"checkoutStepType.DELIVERY_MODE\">\n              <ng-container *ngTemplateOutlet=\"deliveryMode\"></ng-container>\n            </ng-container>\n          </ng-container>\n        </ng-container>\n      </div>\n    </ng-container>\n  </div>\n\n  <!-- PO NUMBER SECTION -->\n  <ng-template #poNumber>\n    <div class=\"cx-review-summary-card\">\n      <cx-card [content]=\"getPoNumberCard(poNumber$ | async) | async\"></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [routerLink]=\"\n            {\n              cxRoute: getCheckoutStepUrl(checkoutStepType.PAYMENT_TYPE)\n            } | cxUrl\n          \"\n          ><cx-icon [type]=\"iconTypes.PENCIL\"></cx-icon\n        ></a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- PAYMENT TYPE SECTION -->\n  <ng-template #paymentType>\n    <div class=\"cx-review-summary-card\">\n      <cx-card\n        [content]=\"getPaymentTypeCard(paymentType$ | async) | async\"\n      ></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [routerLink]=\"\n            {\n              cxRoute: getCheckoutStepUrl(checkoutStepType.PAYMENT_TYPE)\n            } | cxUrl\n          \"\n          ><cx-icon [type]=\"iconTypes.PENCIL\"></cx-icon\n        ></a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- COST CENTER SECTION -->\n  <ng-template #costCenter>\n    <ng-container *ngIf=\"isAccountPayment$ | async\">\n      <div class=\"cx-review-summary-card\">\n        <cx-card\n          [content]=\"getCostCenterCard(costCenter$ | async) | async\"\n        ></cx-card>\n        <div class=\"cx-review-summary-edit-step\">\n          <a\n            [routerLink]=\"\n              {\n                cxRoute: getCheckoutStepUrl(checkoutStepType.SHIPPING_ADDRESS)\n              } | cxUrl\n            \"\n            ><cx-icon [type]=\"iconTypes.PENCIL\"></cx-icon\n          ></a>\n        </div>\n      </div>\n    </ng-container>\n  </ng-template>\n\n  <!-- SHIPPING ADDRESS SECTION -->\n  <ng-template #shippingAddress>\n    <div class=\"cx-review-summary-card cx-review-card-address\">\n      <cx-card\n        *ngIf=\"deliveryAddress$ | async as deliveryAddress\"\n        [content]=\"\n          getShippingAddressCard(deliveryAddress, countryName$ | async) | async\n        \"\n      ></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [routerLink]=\"\n            {\n              cxRoute: getCheckoutStepUrl(checkoutStepType.SHIPPING_ADDRESS)\n            } | cxUrl\n          \"\n          ><cx-icon [type]=\"iconTypes.PENCIL\"></cx-icon\n        ></a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- DELIVERY MODE SECTION -->\n  <ng-template #deliveryMode>\n    <div class=\"cx-review-summary-card cx-review-card-shipping\">\n      <cx-card\n        *ngIf=\"deliveryMode$ | async as deliveryMode\"\n        [content]=\"getDeliveryModeCard(deliveryMode) | async\"\n      ></cx-card>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [routerLink]=\"\n            { cxRoute: getCheckoutStepUrl(checkoutStepType.DELIVERY_MODE) }\n              | cxUrl\n          \"\n        >\n          <cx-icon [type]=\"iconTypes.PENCIL\"></cx-icon>\n        </a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- PAYMENT METHOD SECTION -->\n  <ng-template #paymentMethod>\n    <div class=\"cx-review-summary-card cx-review-card-payment\">\n      <div>\n        <cx-card\n          *ngIf=\"paymentDetails$ | async as paymentDetails\"\n          [content]=\"getPaymentMethodCard(paymentDetails) | async\"\n        ></cx-card>\n      </div>\n      <div class=\"cx-review-summary-edit-step\">\n        <a\n          [routerLink]=\"\n            { cxRoute: getCheckoutStepUrl(checkoutStepType.PAYMENT_DETAILS) }\n              | cxUrl\n          \"\n        >\n          <cx-icon [type]=\"iconTypes.PENCIL\"></cx-icon>\n        </a>\n      </div>\n    </div>\n  </ng-template>\n\n  <!-- CART ITEM SECTION -->\n  <ng-container *ngIf=\"cart$ | async as cart\">\n    <div class=\"cx-review-cart-total d-none d-lg-block d-xl-block\">\n      {{\n        'cartItems.cartTotal'\n          | cxTranslate: { count: cart.deliveryItemsQuantity }\n      }}:\n      {{ cart.totalPrice?.formattedValue }}\n    </div>\n    <h4 class=\"cx-review-cart-heading d-block d-lg-none d-xl-none\">\n      {{ 'checkoutReview.placeOrder' | cxTranslate }}\n    </h4>\n    <div\n      class=\"cx-review-cart-item col-md-12\"\n      *ngIf=\"entries$ | async as entries\"\n    >\n      <ng-container *ngIf=\"orderPromotions$ | async as orderPromotions\">\n        <cx-promotions [promotions]=\"orderPromotions\"></cx-promotions>\n      </ng-container>\n\n      <cx-cart-item-list\n        [items]=\"entries\"\n        [readonly]=\"true\"\n        [promotionLocation]=\"promotionLocation\"\n      ></cx-cart-item-list>\n    </div>\n  </ng-container>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ReviewSubmitComponent.ctorParameters = function () { return [
        { type: i1.CheckoutDeliveryService },
        { type: i1.CheckoutPaymentService },
        { type: i1.UserAddressService },
        { type: i1.ActiveCartService },
        { type: i1.TranslationService },
        { type: CheckoutStepService },
        { type: PromotionService },
        { type: i1.PaymentTypeService },
        { type: i1.CheckoutCostCenterService },
        { type: i1.UserCostCenterService }
    ]; };

    var ReviewSubmitModule = /** @class */ (function () {
        function ReviewSubmitModule() {
        }
        return ReviewSubmitModule;
    }());
    ReviewSubmitModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        CardModule,
                        CartSharedModule,
                        i1.I18nModule,
                        i1.UrlModule,
                        i4.RouterModule,
                        PromotionsModule,
                        IconModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutReviewOrder: {
                                    component: ReviewSubmitComponent,
                                    // TODO(#8880): Shouldn't we keep ShippingAddressSetGuard and others here?
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ReviewSubmitComponent],
                    entryComponents: [ReviewSubmitComponent],
                    exports: [ReviewSubmitComponent],
                },] }
    ];

    var ScheduleReplenishmentOrderComponent = /** @class */ (function () {
        function ScheduleReplenishmentOrderComponent(checkoutService, checkoutReplenishmentFormService) {
            this.checkoutService = checkoutService;
            this.checkoutReplenishmentFormService = checkoutReplenishmentFormService;
            this.subscription = new rxjs.Subscription();
            this.iconTypes = exports.ICON_TYPE;
            this.orderTypes = i1.ORDER_TYPE;
            this.daysOfWeek = Object.keys(i1.DaysOfWeek).map(function (key) { return i1.DaysOfWeek[key]; });
            this.recurrencePeriodType = Object.keys(i1.recurrencePeriod).map(function (key) { return i1.recurrencePeriod[key]; });
            this.selectedOrderType$ = this.checkoutService.getCurrentOrderType();
            this.isMonthly = false;
            this.isWeekly = false;
            this.currentDaysOfWeek = [];
        }
        ScheduleReplenishmentOrderComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.checkoutReplenishmentFormService
                .getScheduleReplenishmentFormData()
                .subscribe(function (data) {
                _this.scheduleReplenishmentFormData = data;
            }));
            this.initConfig();
        };
        ScheduleReplenishmentOrderComponent.prototype.changeOrderType = function (orderType) {
            this.checkoutService.setOrderType(orderType);
        };
        ScheduleReplenishmentOrderComponent.prototype.changeNumberOfDays = function (nDays) {
            this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { numberOfDays: nDays }));
        };
        ScheduleReplenishmentOrderComponent.prototype.changeNumberOfWeeks = function (nWeeks) {
            this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { numberOfWeeks: nWeeks }));
        };
        ScheduleReplenishmentOrderComponent.prototype.changeRecurrencePeriodType = function (type) {
            this.isWeekly = type === i1.recurrencePeriod.WEEKLY;
            this.isMonthly = type === i1.recurrencePeriod.MONTHLY;
            this.numberOfDays = this.isMonthly
                ? this.createNumberStringArray(31)
                : this.createNumberStringArray(30);
            this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { recurrencePeriod: type }));
        };
        ScheduleReplenishmentOrderComponent.prototype.changeDayOfTheMonth = function (dayOfMonth) {
            this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { nthDayOfMonth: dayOfMonth }));
        };
        ScheduleReplenishmentOrderComponent.prototype.changeReplenishmentStartDate = function (date) {
            if (Boolean(date)) {
                this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { replenishmentStartDate: date }));
            }
        };
        ScheduleReplenishmentOrderComponent.prototype.changeRepeatDays = function (day, isChecked) {
            if (isChecked) {
                this.currentDaysOfWeek = __spread(this.currentDaysOfWeek);
                this.currentDaysOfWeek.push(day);
                this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { daysOfWeek: this.currentDaysOfWeek }));
            }
            else {
                var foundDay = this.currentDaysOfWeek.find(function (data) { return day === data; });
                if (!foundDay)
                    return;
                var index = this.currentDaysOfWeek.indexOf(foundDay);
                this.currentDaysOfWeek.splice(index, 1);
                this.checkoutReplenishmentFormService.setScheduleReplenishmentFormData(Object.assign(Object.assign({}, this.scheduleReplenishmentFormData), { daysOfWeek: this.currentDaysOfWeek }));
            }
        };
        ScheduleReplenishmentOrderComponent.prototype.hasDaysOfWeekChecked = function (day) {
            return this.currentDaysOfWeek.includes(day);
        };
        ScheduleReplenishmentOrderComponent.prototype.currentISODate = function (date) {
            return date.split('T')[0];
        };
        ScheduleReplenishmentOrderComponent.prototype.initConfig = function () {
            this.isMonthly =
                this.scheduleReplenishmentFormData.recurrencePeriod ===
                    i1.recurrencePeriod.MONTHLY;
            this.isWeekly =
                this.scheduleReplenishmentFormData.recurrencePeriod ===
                    i1.recurrencePeriod.WEEKLY;
            this.currentDaysOfWeek = __spread(this.scheduleReplenishmentFormData.daysOfWeek);
            this.numberOfDays = this.isMonthly
                ? this.createNumberStringArray(31)
                : this.createNumberStringArray(30);
            this.numberOfWeeks = this.createNumberStringArray(12);
            this.currentDate = this.scheduleReplenishmentFormData.replenishmentStartDate;
        };
        ScheduleReplenishmentOrderComponent.prototype.createNumberStringArray = function (n) {
            return Array(n)
                .fill(0)
                .map(function (_, y) { return (y + 1).toString(); });
        };
        ScheduleReplenishmentOrderComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return ScheduleReplenishmentOrderComponent;
    }());
    ScheduleReplenishmentOrderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-schedule-replenishment-order',
                    template: "<div class=\"cx-order-type-card\">\n  <div class=\"cx-label-container\">\n    <h5 class=\"cx-order-replenishment-header\">\n      {{ 'checkoutReview.autoReplenishOrder' | cxTranslate }}\n    </h5>\n    <cx-icon [type]=\"iconTypes.CLOCK\"></cx-icon>\n  </div>\n  <div\n    class=\"cx-order-type-container form-check\"\n    *ngFor=\"let type of orderTypes | keyvalue\"\n  >\n    <input\n      id=\"orderType-{{ type.value }}\"\n      class=\"scaled-input form-check-input\"\n      role=\"radio\"\n      type=\"radio\"\n      aria-checked=\"true\"\n      (change)=\"changeOrderType(type.value)\"\n      [value]=\"type.value\"\n      [checked]=\"type.value == (selectedOrderType$ | async)\"\n    />\n    <label\n      class=\"order-type-label form-check-label form-radio-label\"\n      for=\"orderType-{{ type.value }}\"\n    >\n      <div class=\"order-type\">\n        {{ 'checkoutReview.orderType' | cxTranslate: { context: type.value } }}\n      </div>\n    </label>\n  </div>\n  <ng-container\n    *ngIf=\"\n      scheduleReplenishmentFormData &&\n      (selectedOrderType$ | async) === orderTypes.SCHEDULE_REPLENISHMENT_ORDER\n    \"\n  >\n    <div class=\"cx-replenishment-form-data-container\">\n      <span class=\"form-data-label\">{{\n        'checkoutReview.every' | cxTranslate\n      }}</span>\n      <div *ngIf=\"!isMonthly\" class=\"cx-days\">\n        <ng-container *ngIf=\"isWeekly; else isDaily\">\n          <select\n            class=\"form-control\"\n            (change)=\"changeNumberOfWeeks($event.target.value)\"\n          >\n            <option\n              *ngFor=\"let nWeeks of numberOfWeeks\"\n              [value]=\"nWeeks\"\n              [selected]=\"\n                nWeeks === scheduleReplenishmentFormData.numberOfWeeks\n              \"\n            >\n              {{ nWeeks }}\n            </option>\n          </select>\n        </ng-container>\n        <ng-template #isDaily>\n          <select\n            class=\"form-control\"\n            (change)=\"changeNumberOfDays($event.target.value)\"\n          >\n            <option\n              *ngFor=\"let nDays of numberOfDays\"\n              [value]=\"nDays\"\n              [selected]=\"nDays === scheduleReplenishmentFormData.numberOfDays\"\n            >\n              {{ nDays }}\n            </option>\n          </select>\n        </ng-template>\n      </div>\n      <div class=\"cx-month\">\n        <select\n          class=\"form-control\"\n          (change)=\"changeRecurrencePeriodType($event.target.value)\"\n        >\n          <option\n            *ngFor=\"let type of recurrencePeriodType\"\n            [value]=\"type\"\n            [selected]=\"type === scheduleReplenishmentFormData.recurrencePeriod\"\n          >\n            {{\n              'checkoutReview.recurrencePeriodType'\n                | cxTranslate: { context: type }\n            }}\n          </option>\n        </select>\n      </div>\n    </div>\n\n    <div *ngIf=\"isMonthly\" class=\"cx-replenishment-form-data-container\">\n      <span class=\"form-data-label\">{{\n        'checkoutReview.dayOfMonth' | cxTranslate\n      }}</span>\n      <div class=\"cx-day-of-month\">\n        <select\n          class=\"form-control\"\n          (change)=\"changeDayOfTheMonth($event.target.value)\"\n        >\n          <option\n            *ngFor=\"let nDays of numberOfDays\"\n            [value]=\"nDays\"\n            [selected]=\"nDays === scheduleReplenishmentFormData.nthDayOfMonth\"\n          >\n            {{ nDays }}\n          </option>\n        </select>\n      </div>\n    </div>\n\n    <div class=\"cx-replenishment-form-data-container\">\n      <span class=\"form-data-label\">{{\n        'checkoutReview.startOn' | cxTranslate\n      }}</span>\n      <div class=\"cx-replenishment-date\">\n        <input\n          type=\"date\"\n          placeholder=\"yyyy-mm-dd\"\n          [value]=\"currentISODate(currentDate)\"\n          (change)=\"changeReplenishmentStartDate($event.target.value)\"\n        />\n      </div>\n    </div>\n\n    <div\n      *ngIf=\"isWeekly\"\n      class=\"cx-replenishment-form-data-container cx-repeat-days-container\"\n    >\n      <span class=\"cx-repeat-days form-data-label\">{{\n        'checkoutReview.repeatOnDays' | cxTranslate\n      }}</span>\n      <div *ngFor=\"let day of daysOfWeek\" class=\"form-check\">\n        <label for=\"day-{{ day }}\" class=\"cx-week-day\">{{\n          day | titlecase\n        }}</label\n        ><input\n          id=\"day-{{ day }}\"\n          type=\"checkbox\"\n          class=\"form-check-input\"\n          [checked]=\"hasDaysOfWeekChecked(day)\"\n          (change)=\"changeRepeatDays(day, $event.target.checked)\"\n        />\n      </div>\n    </div>\n  </ng-container>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ScheduleReplenishmentOrderComponent.ctorParameters = function () { return [
        { type: i1.CheckoutService },
        { type: CheckoutReplenishmentFormService }
    ]; };

    var ScheduleReplenishmentOrderModule = /** @class */ (function () {
        function ScheduleReplenishmentOrderModule() {
        }
        return ScheduleReplenishmentOrderModule;
    }());
    ScheduleReplenishmentOrderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.I18nModule, IconModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutScheduleReplenishmentOrder: {
                                    component: ScheduleReplenishmentOrderComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ScheduleReplenishmentOrderComponent],
                    entryComponents: [ScheduleReplenishmentOrderComponent],
                    exports: [ScheduleReplenishmentOrderComponent],
                },] }
    ];

    var AddressFormComponent = /** @class */ (function () {
        function AddressFormComponent(fb, checkoutDeliveryService, userService, userAddressService, globalMessageService, modalService) {
            this.fb = fb;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.userService = userService;
            this.userAddressService = userAddressService;
            this.globalMessageService = globalMessageService;
            this.modalService = modalService;
            this.selectedCountry$ = new rxjs.BehaviorSubject('');
            this.setAsDefaultField = true;
            this.showCancelBtn = true;
            this.submitAddress = new i0.EventEmitter();
            this.backToAddress = new i0.EventEmitter();
            this.addressForm = this.fb.group({
                country: this.fb.group({
                    isocode: [null, forms.Validators.required],
                }),
                titleCode: [''],
                firstName: ['', forms.Validators.required],
                lastName: ['', forms.Validators.required],
                line1: ['', forms.Validators.required],
                line2: [''],
                town: ['', forms.Validators.required],
                region: this.fb.group({
                    isocode: [null, forms.Validators.required],
                }),
                postalCode: ['', forms.Validators.required],
                phone: '',
                defaultAddress: [false],
            });
        }
        AddressFormComponent.prototype.ngOnInit = function () {
            var _this = this;
            // Fetching countries
            this.countries$ = this.userAddressService.getDeliveryCountries().pipe(operators.tap(function (countries) {
                if (Object.keys(countries).length === 0) {
                    _this.userAddressService.loadDeliveryCountries();
                }
            }));
            // Fetching titles
            this.titles$ = this.userService.getTitles().pipe(operators.map(function (titles) {
                titles.sort(sortTitles);
                var noneTitle = { code: '', name: 'Title' };
                return __spread([noneTitle], titles);
            }));
            // Fetching regions
            this.regions$ = this.selectedCountry$.pipe(operators.switchMap(function (country) { return _this.userAddressService.getRegions(country); }), operators.tap(function (regions) {
                var regionControl = _this.addressForm.get('region.isocode');
                if (regions && regions.length > 0) {
                    regionControl.enable();
                }
                else {
                    regionControl.disable();
                }
            }));
            // verify the new added address
            this.addressVerifySub = this.checkoutDeliveryService
                .getAddressVerificationResults()
                .subscribe(function (results) {
                if (results.decision === 'FAIL') {
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                }
                else if (results.decision === 'ACCEPT') {
                    _this.submitAddress.emit(_this.addressForm.value);
                }
                else if (results.decision === 'REJECT') {
                    // TODO: Workaround: allow server for decide is titleCode mandatory (if yes, provide personalized message)
                    if (results.errors.errors.some(function (error) { return error.subject === 'titleCode'; })) {
                        _this.globalMessageService.add({ key: 'addressForm.titleRequired' }, i1.GlobalMessageType.MSG_TYPE_ERROR);
                    }
                    else {
                        _this.globalMessageService.add({ key: 'addressForm.invalidAddress' }, i1.GlobalMessageType.MSG_TYPE_ERROR);
                    }
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                }
                else if (results.decision === 'REVIEW') {
                    _this.openSuggestedAddress(results);
                }
            });
            if (this.addressData && Object.keys(this.addressData).length !== 0) {
                this.addressForm.patchValue(this.addressData);
                this.countrySelected(this.addressData.country);
                if (this.addressData.region) {
                    this.regionSelected(this.addressData.region);
                }
            }
            this.addresses$ = this.userAddressService.getAddresses();
        };
        AddressFormComponent.prototype.countrySelected = function (country) {
            this.addressForm['controls'].country['controls'].isocode.setValue(country.isocode);
            this.selectedCountry$.next(country.isocode);
        };
        AddressFormComponent.prototype.regionSelected = function (region) {
            this.addressForm['controls'].region['controls'].isocode.setValue(region.isocode);
        };
        AddressFormComponent.prototype.toggleDefaultAddress = function () {
            this.addressForm['controls'].defaultAddress.setValue(this.addressForm.value.defaultAddress);
        };
        AddressFormComponent.prototype.back = function () {
            this.backToAddress.emit();
        };
        AddressFormComponent.prototype.verifyAddress = function () {
            var _this = this;
            if (this.addressForm.valid) {
                if (this.addressForm.get('region').value.isocode) {
                    this.regionsSub = this.regions$.pipe(operators.take(1)).subscribe(function (regions) {
                        var obj = regions.find(function (region) { return region.isocode ===
                            _this.addressForm.controls['region'].value.isocode; });
                        Object.assign(_this.addressForm.value.region, {
                            isocodeShort: obj.isocodeShort,
                        });
                    });
                }
                if (this.addressForm.dirty) {
                    this.checkoutDeliveryService.verifyAddress(this.addressForm.value);
                }
                else {
                    // address form value not changed
                    // ignore duplicate address
                    this.submitAddress.emit(undefined);
                }
            }
            else {
                this.addressForm.markAllAsTouched();
            }
        };
        AddressFormComponent.prototype.openSuggestedAddress = function (results) {
            var _this = this;
            if (!this.suggestedAddressModalRef) {
                this.suggestedAddressModalRef = this.modalService.open(SuggestedAddressDialogComponent, { centered: true, size: 'lg' });
                this.suggestedAddressModalRef.componentInstance.enteredAddress = this.addressForm.value;
                this.suggestedAddressModalRef.componentInstance.suggestedAddresses =
                    results.suggestedAddresses;
                this.suggestedAddressModalRef.result
                    .then(function (address) {
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                    if (address) {
                        address = Object.assign({
                            titleCode: _this.addressForm.value.titleCode,
                            phone: _this.addressForm.value.phone,
                            selected: true,
                        }, address);
                        _this.submitAddress.emit(address);
                    }
                    _this.suggestedAddressModalRef = null;
                })
                    .catch(function () {
                    // this  callback is called when modal is closed with Esc key or clicking backdrop
                    _this.checkoutDeliveryService.clearAddressVerificationResults();
                    var address = Object.assign({
                        selected: true,
                    }, _this.addressForm.value);
                    _this.submitAddress.emit(address);
                    _this.suggestedAddressModalRef = null;
                });
            }
        };
        AddressFormComponent.prototype.ngOnDestroy = function () {
            this.checkoutDeliveryService.clearAddressVerificationResults();
            if (this.addressVerifySub) {
                this.addressVerifySub.unsubscribe();
            }
            if (this.regionsSub) {
                this.regionsSub.unsubscribe();
            }
        };
        return AddressFormComponent;
    }());
    AddressFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-address-form',
                    template: "<form (ngSubmit)=\"verifyAddress()\" [formGroup]=\"addressForm\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-lg-9\">\n      <div class=\"form-group\" formGroupName=\"country\">\n        <ng-container *ngIf=\"countries$ | async as countries\">\n          <div *ngIf=\"countries.length !== 0\">\n            <label aria-required=\"true\">\n              <span class=\"label-content required\">{{\n                'addressForm.country' | cxTranslate\n              }}</span>\n              <ng-select\n                class=\"country-select\"\n                formControlName=\"isocode\"\n                [searchable]=\"true\"\n                [clearable]=\"false\"\n                [items]=\"countries\"\n                bindLabel=\"name\"\n                bindValue=\"isocode\"\n                placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n                (change)=\"countrySelected($event)\"\n              >\n              </ng-select>\n              <cx-form-errors\n                [control]=\"addressForm.get('country.isocode')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n        </ng-container>\n      </div>\n      <div class=\"form-group\" *ngIf=\"showTitleCode\">\n        <ng-container *ngIf=\"titles$ | async as titles\">\n          <div *ngIf=\"titles.length !== 0\">\n            <label aria-required=\"true\">\n              <span class=\"label-content required\">{{\n                'addressForm.title' | cxTranslate\n              }}</span>\n              <ng-select\n                formControlName=\"titleCode\"\n                [searchable]=\"false\"\n                [clearable]=\"false\"\n                [items]=\"titles\"\n                bindLabel=\"name\"\n                bindValue=\"code\"\n              >\n              </ng-select>\n            </label>\n          </div>\n        </ng-container>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.firstName.label' | cxTranslate\n          }}</span>\n          <input\n            class=\"form-control\"\n            type=\"text\"\n            placeholder=\"{{\n              'addressForm.firstName.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"firstName\"\n          />\n          <cx-form-errors\n            [control]=\"addressForm.get('firstName')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.lastName.label' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.lastName.placeholder' | cxTranslate }}\"\n            formControlName=\"lastName\"\n          />\n          <cx-form-errors\n            [control]=\"addressForm.get('lastName')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content required\">{{\n            'addressForm.address1' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.streetAddress' | cxTranslate }}\"\n            formControlName=\"line1\"\n          />\n          <cx-form-errors [control]=\"addressForm.get('line1')\"></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'addressForm.address2' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            placeholder=\"{{ 'addressForm.aptSuite' | cxTranslate }}\"\n            formControlName=\"line2\"\n          />\n        </label>\n      </div>\n      <div class=\"row\">\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.city.label' | cxTranslate\n            }}</span>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{ 'addressForm.city.placeholder' | cxTranslate }}\"\n              formControlName=\"town\"\n            />\n            <cx-form-errors\n              [control]=\"addressForm.get('town')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n        <div class=\"form-group col-md-6\">\n          <label>\n            <span class=\"label-content required\">{{\n              'addressForm.zipCode.label' | cxTranslate\n            }}</span>\n            <input\n              type=\"text\"\n              class=\"form-control\"\n              placeholder=\"{{\n                'addressForm.zipCode.placeholder' | cxTranslate\n              }}\"\n              formControlName=\"postalCode\"\n            />\n            <cx-form-errors\n              [control]=\"addressForm.get('postalCode')\"\n            ></cx-form-errors>\n          </label>\n        </div>\n        <ng-container\n          *ngIf=\"regions$ | async as regions\"\n          formGroupName=\"region\"\n        >\n          <ng-container *ngIf=\"regions.length !== 0\">\n            <div class=\"form-group col-md-6\">\n              <label aria-required=\"true\">\n                <span class=\"label-content required\">{{\n                  'addressForm.state' | cxTranslate\n                }}</span>\n                <ng-select\n                  class=\"region-select\"\n                  formControlName=\"isocode\"\n                  [searchable]=\"true\"\n                  [clearable]=\"false\"\n                  [items]=\"regions\"\n                  bindLabel=\"{{ regions[0].name ? 'name' : 'isocode' }}\"\n                  bindValue=\"{{ regions[0].name ? 'isocode' : 'region' }}\"\n                  placeholder=\"{{ 'addressForm.selectOne' | cxTranslate }}\"\n                >\n                </ng-select>\n                <cx-form-errors\n                  [control]=\"addressForm.get('region.isocode')\"\n                ></cx-form-errors>\n              </label>\n            </div>\n          </ng-container>\n        </ng-container>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'addressForm.phoneNumber.label' | cxTranslate\n          }}</span>\n          <input\n            type=\"tel\"\n            class=\"form-control\"\n            placeholder=\"{{\n              'addressForm.phoneNumber.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"phone\"\n          />\n        </label>\n      </div>\n      <div\n        class=\"form-group\"\n        *ngIf=\"(addresses$ | async).length && setAsDefaultField\"\n      >\n        <div class=\"form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              formControlName=\"defaultAddress\"\n              (change)=\"toggleDefaultAddress()\"\n            />\n            <span class=\"form-check-label\">{{\n              'addressForm.setAsDefault' | cxTranslate\n            }}</span>\n          </label>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"cx-checkout-btns row\">\n    <div class=\"col-md-12 col-lg-6\" *ngIf=\"showCancelBtn\">\n      <button class=\"btn btn-block btn-action\" (click)=\"back()\">\n        {{ cancelBtnLabel || ('addressForm.chooseAddress' | cxTranslate) }}\n      </button>\n    </div>\n    <div class=\"col-md-12 col-lg-6\">\n      <button class=\"btn btn-block btn-primary\" type=\"submit\">\n        {{ actionBtnLabel || ('common.continue' | cxTranslate) }}\n      </button>\n    </div>\n  </div>\n</form>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    AddressFormComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder },
        { type: i1.CheckoutDeliveryService },
        { type: i1.UserService },
        { type: i1.UserAddressService },
        { type: i1.GlobalMessageService },
        { type: ModalService }
    ]; };
    AddressFormComponent.propDecorators = {
        addressData: [{ type: i0.Input }],
        actionBtnLabel: [{ type: i0.Input }],
        cancelBtnLabel: [{ type: i0.Input }],
        setAsDefaultField: [{ type: i0.Input }],
        showTitleCode: [{ type: i0.Input }],
        showCancelBtn: [{ type: i0.Input }],
        submitAddress: [{ type: i0.Output }],
        backToAddress: [{ type: i0.Output }]
    };

    var AddressFormModule = /** @class */ (function () {
        function AddressFormModule() {
        }
        return AddressFormModule;
    }());
    AddressFormModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        forms.FormsModule,
                        i4.RouterModule,
                        ngSelect.NgSelectModule,
                        IconModule,
                        i1.I18nModule,
                        FormErrorsModule,
                    ],
                    declarations: [AddressFormComponent, SuggestedAddressDialogComponent],
                    entryComponents: [SuggestedAddressDialogComponent],
                    exports: [AddressFormComponent, SuggestedAddressDialogComponent],
                },] }
    ];

    var ShippingAddressComponent = /** @class */ (function () {
        function ShippingAddressComponent(userAddressService, checkoutDeliveryService, activatedRoute, translation, activeCartService, checkoutStepService, paymentTypeService, userCostCenterService, checkoutCostCenterService) {
            this.userAddressService = userAddressService;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.activatedRoute = activatedRoute;
            this.translation = translation;
            this.activeCartService = activeCartService;
            this.checkoutStepService = checkoutStepService;
            this.paymentTypeService = paymentTypeService;
            this.userCostCenterService = userCostCenterService;
            this.checkoutCostCenterService = checkoutCostCenterService;
            this.addressFormOpened = false;
            this.forceLoader = false; // this helps with smoother steps transition
            this.doneAutoSelect = false;
            this.isAccountPayment = false;
        }
        Object.defineProperty(ShippingAddressComponent.prototype, "isGuestCheckout", {
            get: function () {
                return this.activeCartService.isGuestCart();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ShippingAddressComponent.prototype, "backBtnText", {
            get: function () {
                return this.checkoutStepService.getBackBntText(this.activatedRoute);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ShippingAddressComponent.prototype, "isLoading$", {
            get: function () {
                return this.userAddressService.getAddressesLoading();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ShippingAddressComponent.prototype, "selectedAddress$", {
            get: function () {
                var _this = this;
                return this.checkoutDeliveryService.getDeliveryAddress().pipe(operators.tap(function (address) {
                    if (address &&
                        (_this.selectedAddress === undefined ||
                            _this.selectedAddress.id !== address.id)) {
                        _this.selectedAddress = address;
                        if (_this.forceLoader) {
                            _this.next();
                        }
                    }
                }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ShippingAddressComponent.prototype, "cards$", {
            get: function () {
                var _this = this;
                return rxjs.combineLatest([
                    this.getSupportedAddresses(),
                    this.selectedAddress$,
                    this.translation.translate('checkoutAddress.defaultShippingAddress'),
                    this.translation.translate('checkoutAddress.shipToThisAddress'),
                    this.translation.translate('addressCard.selected'),
                ]).pipe(operators.tap(function (_a) {
                    var _b = __read(_a, 2), addresses = _b[0], selected = _b[1];
                    return _this.selectDefaultAddress(addresses, selected);
                }), operators.map(function (_a) {
                    var _b = __read(_a, 5), addresses = _b[0], selected = _b[1], textDefault = _b[2], textShipTo = _b[3], textSelected = _b[4];
                    return addresses.map(function (address) { return ({
                        address: address,
                        card: _this.getCardContent(address, selected, textDefault, textShipTo, textSelected),
                    }); });
                }));
            },
            enumerable: false,
            configurable: true
        });
        ShippingAddressComponent.prototype.getSupportedAddresses = function () {
            var _this = this;
            if (this.isAccountPayment) {
                return this.checkoutCostCenterService.getCostCenter().pipe(operators.distinctUntilChanged(), operators.switchMap(function (selected) {
                    _this.doneAutoSelect = false;
                    return _this.userCostCenterService.getCostCenterAddresses(selected);
                }));
            }
            return this.userAddressService.getAddresses();
        };
        ShippingAddressComponent.prototype.selectDefaultAddress = function (addresses, selected) {
            if (!this.doneAutoSelect &&
                addresses &&
                addresses.length &&
                (!selected || Object.keys(selected).length === 0)) {
                if (this.isAccountPayment) {
                    if (addresses.length === 1) {
                        this.selectAddress(addresses[0]);
                    }
                }
                else {
                    selected = addresses.find(function (address) { return address.defaultAddress; });
                    if (selected) {
                        this.selectAddress(selected);
                    }
                }
                this.doneAutoSelect = true;
            }
        };
        ShippingAddressComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this.paymentTypeService &&
                this.userCostCenterService &&
                this.checkoutCostCenterService) {
                this.paymentTypeService
                    .isAccountPayment()
                    .pipe(operators.take(1))
                    .subscribe(function (isAccount) { return (_this.isAccountPayment = isAccount); });
            }
            if (!this.isGuestCheckout && !this.isAccountPayment) {
                this.userAddressService.loadAddresses();
            }
        };
        ShippingAddressComponent.prototype.getCardContent = function (address, selected, textDefaultShippingAddress, textShipToThisAddress, textSelected) {
            var region = '';
            if (address.region && address.region.isocode) {
                region = address.region.isocode + ', ';
            }
            return {
                title: address.defaultAddress ? textDefaultShippingAddress : '',
                textBold: address.firstName + ' ' + address.lastName,
                text: [
                    address.line1,
                    address.line2,
                    address.town + ', ' + region + address.country.isocode,
                    address.postalCode,
                    address.phone,
                ],
                actions: [{ name: textShipToThisAddress, event: 'send' }],
                header: selected && selected.id === address.id ? textSelected : '',
            };
        };
        ShippingAddressComponent.prototype.selectAddress = function (address) {
            this.checkoutDeliveryService.setDeliveryAddress(address);
        };
        ShippingAddressComponent.prototype.addAddress = function (address) {
            this.forceLoader = true;
            this.checkoutDeliveryService.createAndSetAddress(address);
        };
        ShippingAddressComponent.prototype.showNewAddressForm = function () {
            this.addressFormOpened = true;
        };
        ShippingAddressComponent.prototype.hideNewAddressForm = function (goPrevious) {
            if (goPrevious === void 0) { goPrevious = false; }
            this.addressFormOpened = false;
            if (goPrevious) {
                this.back();
            }
        };
        ShippingAddressComponent.prototype.next = function () {
            this.checkoutStepService.next(this.activatedRoute);
        };
        ShippingAddressComponent.prototype.back = function () {
            this.checkoutStepService.back(this.activatedRoute);
        };
        return ShippingAddressComponent;
    }());
    ShippingAddressComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-shipping-address',
                    template: "<ng-container *ngIf=\"cards$ | async as cards\">\n  <h3 class=\"cx-checkout-title d-none d-lg-block d-xl-block\">\n    {{ 'checkoutAddress.shippingAddress' | cxTranslate }}\n  </h3>\n  <ng-container *ngIf=\"!forceLoader && !(isLoading$ | async); else loading\">\n    <ng-container\n      *ngIf=\"\n        isAccountPayment || (cards?.length && !addressFormOpened);\n        else newAddressForm\n      \"\n    >\n      <p class=\"cx-checkout-text\">\n        {{ 'checkoutAddress.selectYourShippingAddress' | cxTranslate }}\n      </p>\n      <div class=\"cx-checkout-btns row\" *ngIf=\"!isAccountPayment\">\n        <div class=\"col-sm-12 col-md-12 col-lg-6\">\n          <button\n            class=\"btn btn-block btn-action\"\n            (click)=\"showNewAddressForm()\"\n          >\n            {{ 'checkoutAddress.addNewAddress' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n\n      <div class=\"cx-checkout-body row\">\n        <div\n          class=\"cx-shipping-address-card col-md-12 col-lg-6\"\n          *ngFor=\"let card of cards; let i = index\"\n        >\n          <div\n            class=\"cx-shipping-address-card-inner\"\n            (click)=\"selectAddress(card.address)\"\n          >\n            <cx-card\n              [border]=\"true\"\n              [fitToContainer]=\"true\"\n              [content]=\"card.card\"\n              (sendCard)=\"selectAddress(card.address)\"\n            ></cx-card>\n          </div>\n        </div>\n      </div>\n\n      <div class=\"cx-checkout-btns row\">\n        <div class=\"col-md-12 col-lg-6\">\n          <button class=\"cx-btn btn btn-block btn-action\" (click)=\"back()\">\n            {{ backBtnText | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-md-12 col-lg-6\">\n          <button\n            class=\"cx-btn btn btn-block btn-primary\"\n            [disabled]=\"!selectedAddress?.id\"\n            (click)=\"next()\"\n          >\n            {{ 'common.continue' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </ng-container>\n\n    <ng-template #newAddressForm>\n      <cx-address-form\n        *ngIf=\"cards.length; else initialAddressForm\"\n        [showTitleCode]=\"true\"\n        (backToAddress)=\"hideNewAddressForm(false)\"\n        (submitAddress)=\"addAddress($event)\"\n      ></cx-address-form>\n      <ng-template #initialAddressForm>\n        <cx-address-form\n          [showTitleCode]=\"true\"\n          [setAsDefaultField]=\"!isGuestCheckout\"\n          [addressData]=\"selectedAddress\"\n          cancelBtnLabel=\"{{ backBtnText | cxTranslate }}\"\n          (backToAddress)=\"hideNewAddressForm(true)\"\n          (submitAddress)=\"addAddress($event)\"\n        ></cx-address-form>\n      </ng-template>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ShippingAddressComponent.ctorParameters = function () { return [
        { type: i1.UserAddressService },
        { type: i1.CheckoutDeliveryService },
        { type: i4.ActivatedRoute },
        { type: i1.TranslationService },
        { type: i1.ActiveCartService },
        { type: CheckoutStepService },
        { type: i1.PaymentTypeService },
        { type: i1.UserCostCenterService },
        { type: i1.CheckoutCostCenterService }
    ]; };

    var ShippingAddressModule = /** @class */ (function () {
        function ShippingAddressModule() {
        }
        return ShippingAddressModule;
    }());
    ShippingAddressModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        AddressFormModule,
                        CardModule,
                        SpinnerModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CheckoutShippingAddress: {
                                    component: ShippingAddressComponent,
                                    guards: [CheckoutAuthGuard, CartNotEmptyGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ShippingAddressComponent],
                    entryComponents: [ShippingAddressComponent],
                    exports: [ShippingAddressComponent],
                },] }
    ];

    var CheckoutComponentModule = /** @class */ (function () {
        function CheckoutComponentModule() {
        }
        return CheckoutComponentModule;
    }());
    CheckoutComponentModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        CheckoutOrchestratorModule,
                        CheckoutOrderSummaryModule,
                        CheckoutProgressModule,
                        CheckoutProgressMobileTopModule,
                        CheckoutProgressMobileBottomModule,
                        PaymentTypeModule,
                        DeliveryModeModule,
                        PaymentMethodModule,
                        PlaceOrderModule,
                        ScheduleReplenishmentOrderModule,
                        PromotionsModule,
                        ReviewSubmitModule,
                        ShippingAddressModule,
                        CostCenterModule,
                    ],
                },] }
    ];

    var SkipLinkConfig = /** @class */ (function () {
        function SkipLinkConfig() {
        }
        return SkipLinkConfig;
    }());
    SkipLinkConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function SkipLinkConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: SkipLinkConfig, providedIn: "root" });
    SkipLinkConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];
    var SkipLink = /** @class */ (function () {
        function SkipLink() {
        }
        return SkipLink;
    }());
    (function (SkipLinkScrollPosition) {
        SkipLinkScrollPosition["BEFORE"] = "BEFORE";
        SkipLinkScrollPosition["AFTER"] = "AFTER";
    })(exports.SkipLinkScrollPosition || (exports.SkipLinkScrollPosition = {}));

    var SkipLinkService = /** @class */ (function () {
        function SkipLinkService(config, keyboardFocusService) {
            this.config = config;
            this.keyboardFocusService = keyboardFocusService;
            this.skipLinks$ = new rxjs.BehaviorSubject([]);
        }
        SkipLinkService.prototype.getSkipLinks = function () {
            return this.skipLinks$;
        };
        SkipLinkService.prototype.add = function (key, target) {
            var found = this.config.skipLinks.find(function (skipLink) { return skipLink.key === key; });
            if (found) {
                var existing = this.skipLinks$.value;
                existing.splice(this.getSkipLinkIndexInArray(key), 0, {
                    target: target,
                    i18nKey: found.i18nKey,
                    position: found.position,
                    key: key,
                });
                this.skipLinks$.next(existing);
            }
        };
        SkipLinkService.prototype.remove = function (key) {
            var found = this.config.skipLinks.find(function (skipLink) { return skipLink.key === key; });
            if (found) {
                var existing = this.skipLinks$.value;
                existing = existing.filter(function (skipLink) { return skipLink.key !== key; });
                this.skipLinks$.next(existing);
            }
        };
        SkipLinkService.prototype.scrollToTarget = function (skipLink) {
            var target = skipLink.target instanceof HTMLElement
                ? skipLink.target
                : skipLink.target.parentElement;
            // focus first focusable element in the
            var firstFocusable = this.keyboardFocusService.findFirstFocusable(target) || target;
            // we force a tabindex if not available, to ensure we can focus into the element
            var hasTabindex = firstFocusable.hasAttribute('tabindex');
            if (!hasTabindex) {
                firstFocusable.setAttribute('tabindex', '-1');
            }
            firstFocusable.focus();
            // drop the tmp tabindex
            if (!hasTabindex) {
                firstFocusable.removeAttribute('tabindex');
            }
        };
        SkipLinkService.prototype.getSkipLinkIndexInArray = function (key) {
            var index = this.config.skipLinks.findIndex(function (skipLink) { return skipLink.key === key; });
            var _loop_1 = function () {
                index--;
                var previous = this_1.config.skipLinks[index];
                if (previous) {
                    var existing = this_1.skipLinks$.value;
                    var found = existing.findIndex(function (skipLink) { return skipLink.key === previous.key; });
                    if (found > -1) {
                        return { value: found + 1 };
                    }
                }
            };
            var this_1 = this;
            while (index > 0) {
                var state_1 = _loop_1();
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            return 0;
        };
        return SkipLinkService;
    }());
    SkipLinkService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SkipLinkService_Factory() { return new SkipLinkService(i0.ɵɵinject(SkipLinkConfig), i0.ɵɵinject(KeyboardFocusService)); }, token: SkipLinkService, providedIn: "root" });
    SkipLinkService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    SkipLinkService.ctorParameters = function () { return [
        { type: SkipLinkConfig },
        { type: KeyboardFocusService }
    ]; };

    var SkipLinkComponent = /** @class */ (function () {
        function SkipLinkComponent(skipLinkService) {
            this.skipLinkService = skipLinkService;
            this.skipLinks$ = this.skipLinkService.getSkipLinks();
        }
        SkipLinkComponent.prototype.scrollToTarget = function (skipLink) {
            this.skipLinkService.scrollToTarget(skipLink);
        };
        return SkipLinkComponent;
    }());
    SkipLinkComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-skip-link',
                    template: "<div [cxFocus]=\"{ tab: true }\" *ngIf=\"skipLinks$ | async as links\">\n  <button *ngFor=\"let link of links\" (click)=\"scrollToTarget(link)\">\n    {{ 'skipLink.skipTo' | cxTranslate }}\n    {{ link.i18nKey | cxTranslate }}\n  </button>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    SkipLinkComponent.ctorParameters = function () { return [
        { type: SkipLinkService }
    ]; };

    var defaultSkipLinkConfig = {
        skipLinks: [
            {
                key: 'cx-header',
                i18nKey: 'skipLink.labels.header',
            },
            {
                key: 'cx-main',
                i18nKey: 'skipLink.labels.main',
            },
            { key: 'cx-footer', i18nKey: 'skipLink.labels.footer' },
        ],
    };

    var SkipLinkDirective = /** @class */ (function () {
        function SkipLinkDirective(elementRef, skipLinkService) {
            this.elementRef = elementRef;
            this.skipLinkService = skipLinkService;
        }
        SkipLinkDirective.prototype.ngOnInit = function () {
            this.skipLinkService.add(this.cxSkipLink, this.elementRef.nativeElement);
        };
        SkipLinkDirective.prototype.ngOnDestroy = function () {
            this.skipLinkService.remove(this.cxSkipLink);
        };
        return SkipLinkDirective;
    }());
    SkipLinkDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cxSkipLink]',
                },] }
    ];
    SkipLinkDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: SkipLinkService }
    ]; };
    SkipLinkDirective.propDecorators = {
        cxSkipLink: [{ type: i0.Input }]
    };

    var SkipLinkModule = /** @class */ (function () {
        function SkipLinkModule() {
        }
        return SkipLinkModule;
    }());
    SkipLinkModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        i1.ConfigModule.withConfig(defaultSkipLinkConfig),
                        KeyboardFocusModule,
                    ],
                    declarations: [SkipLinkComponent, SkipLinkDirective],
                    exports: [SkipLinkDirective],
                    entryComponents: [SkipLinkComponent],
                    providers: [
                        i1.provideDefaultConfig(defaultSkipLinkConfig),
                        {
                            provide: i0.APP_INITIALIZER,
                            useFactory: skipLinkFactory,
                            deps: [i0.ComponentFactoryResolver, OutletService],
                            multi: true,
                        },
                    ],
                },] }
    ];
    /**
     * Adds the skip link component before the cx-storefront.
     */
    function skipLinkFactory(componentFactoryResolver, outletService) {
        var isReady = function () {
            var factory = componentFactoryResolver.resolveComponentFactory(SkipLinkComponent);
            outletService.add('cx-storefront', factory, exports.OutletPosition.BEFORE);
        };
        return isReady;
    }

    var defaultLayoutConfig = {
        breakpoints: {
            xs: 576,
            sm: 768,
            md: 992,
            lg: 1200,
            xl: {
                min: 1200,
            },
        },
    };

    /**
     * The direction config provides an easy way to configure "ltr" versus "rtl" direction
     * for the storefront. The direction can be configured to detect the direction by language.
     *
     * The following configuration detects rtl languages by isoCode for Arabic and Hebrew:
     *
     * ```typescript
     * direction: {
     *   detect: true,
     *   default: DirectionMode.LTR,
     *   rtlLanguages: ['ar', 'he']
     * }
     * ```
     */
    var DirectionConfig = /** @class */ (function () {
        function DirectionConfig() {
        }
        return DirectionConfig;
    }());
    DirectionConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function DirectionConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: DirectionConfig, providedIn: "root" });
    DirectionConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];

    var defaultDirectionConfig = {
        direction: {
            detect: true,
            default: exports.DirectionMode.LTR,
            // we're not polluting the system with all defaults for ltr, but add 2 common used
            // languages (hebrew and arabic) to easily demo directionality
            // see https://meta.wikimedia.org/wiki/Template:List_of_language_names_ordered_by_code
            rtlLanguages: ['he', 'ar'],
        },
    };

    /**
     * The `DirectionService` can be used to add the direction to the overall storefront or individual elements.
     * By default, the direction is added to the `html` element (i.e. `<html dir="ltr">`). The API of this service
     * does however provide methods to add direction to individual elements if needed.
     *
     * The direction is configurable and allows for language driven direction configuration.
     *
     * To react to the active language, the service subscribes to the active language in the initialize method. This
     * is called from an APP_INITIALIZER method and should only happen once.
     */
    var DirectionService = /** @class */ (function () {
        function DirectionService(configInit, languageService, winRef) {
            this.configInit = configInit;
            this.languageService = languageService;
            this.winRef = winRef;
            this.startsDetecting = false;
            this.subscription = new rxjs.Subscription();
        }
        /**
         * Initializes the layout direction for the storefront.
         */
        DirectionService.prototype.initialize = function () {
            var _this = this;
            return this.configInit
                .getStableConfig('direction')
                .then(function (config) {
                var _a, _b;
                _this.config = config === null || config === void 0 ? void 0 : config.direction;
                if ((_a = _this.config) === null || _a === void 0 ? void 0 : _a.detect) {
                    _this.detect();
                }
                else {
                    _this.setDirection(_this.winRef.document.documentElement, (_b = _this.config) === null || _b === void 0 ? void 0 : _b.default);
                }
            });
        };
        /**
         * Observes the _active_ language and set the required direction for the given language.
         * The method is guarded to ensure that the active language is observed only once.
         */
        DirectionService.prototype.detect = function () {
            var _this = this;
            if (this.startsDetecting) {
                return;
            }
            this.subscription.add(this.languageService
                .getActive()
                .subscribe(function (isoCode) { return _this.setDirection(_this.winRef.document.documentElement, _this.getDirection(isoCode)); }));
            this.startsDetecting = true;
        };
        /**
         * Sets the direction attribute for the given element. If the direction is undefined, the `dir`
         * attribute is removed.
         */
        DirectionService.prototype.setDirection = function (el, direction) {
            if (direction) {
                el.setAttribute('dir', direction);
            }
            else {
                el.removeAttribute('dir');
            }
        };
        /**
         * Gets the `DirectionMode` for the given language isoCode. The language isoCode is compared
         * to the configured list of languages(`direction.rtlLanguages` vs `direction.ltrLanguages`).
         *
         * If no language is given, or no language mapping could be found, we fallback to the default
         * `direction.mode`.
         */
        DirectionService.prototype.getDirection = function (language) {
            var _a, _b, _c, _d, _e;
            if (language && ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.rtlLanguages) === null || _b === void 0 ? void 0 : _b.includes(language))) {
                return exports.DirectionMode.RTL;
            }
            if (language && ((_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.ltrLanguages) === null || _d === void 0 ? void 0 : _d.includes(language))) {
                return exports.DirectionMode.LTR;
            }
            return (_e = this.config) === null || _e === void 0 ? void 0 : _e.default;
        };
        DirectionService.prototype.ngOnDestroy = function () {
            // Cleans up the subscription, to avoid memory leaks in SSR.
            this.subscription.unsubscribe();
        };
        return DirectionService;
    }());
    DirectionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DirectionService_Factory() { return new DirectionService(i0.ɵɵinject(i1.ConfigInitializerService), i0.ɵɵinject(i1.LanguageService), i0.ɵɵinject(i1.WindowRef)); }, token: DirectionService, providedIn: "root" });
    DirectionService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    DirectionService.ctorParameters = function () { return [
        { type: i1.ConfigInitializerService },
        { type: i1.LanguageService },
        { type: i1.WindowRef }
    ]; };

    function initHtmlDirAttribute(directionService, featureConfigService) {
        var result = function () {
            if (featureConfigService.isLevel('2.1')) {
                return directionService.initialize();
            }
        };
        return result;
    }
    /**
     * Provides a configuration and APP_INITIALIZER to add the correct (language drive) html direction.
     */
    var DirectionModule = /** @class */ (function () {
        function DirectionModule() {
        }
        return DirectionModule;
    }());
    DirectionModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [
                        {
                            provide: i0.APP_INITIALIZER,
                            multi: true,
                            useFactory: initHtmlDirAttribute,
                            deps: [DirectionService, i1.FeatureConfigService],
                        },
                        i1.provideDefaultConfig(defaultDirectionConfig),
                    ],
                },] }
    ];

    var HamburgerMenuService = /** @class */ (function () {
        function HamburgerMenuService(router) {
            var _this = this;
            this.isExpanded = new rxjs.BehaviorSubject(false);
            router.events
                .pipe(operators.filter(function (event) { return event instanceof i4.NavigationStart; }))
                .subscribe(function () {
                _this.toggle(true);
            });
        }
        /**
         * toggles the expand state of the hamburger menu
         */
        HamburgerMenuService.prototype.toggle = function (forceCollapse) {
            if (forceCollapse) {
                this.isExpanded.next(false);
            }
            else {
                this.isExpanded.next(!this.isExpanded.value);
            }
        };
        return HamburgerMenuService;
    }());
    HamburgerMenuService.ɵprov = i0.ɵɵdefineInjectable({ factory: function HamburgerMenuService_Factory() { return new HamburgerMenuService(i0.ɵɵinject(i4.Router)); }, token: HamburgerMenuService, providedIn: "root" });
    HamburgerMenuService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    HamburgerMenuService.ctorParameters = function () { return [
        { type: i4.Router }
    ]; };

    var HamburgerMenuComponent = /** @class */ (function () {
        function HamburgerMenuComponent(hamburgerMenuService) {
            this.hamburgerMenuService = hamburgerMenuService;
        }
        HamburgerMenuComponent.prototype.toggle = function () {
            this.hamburgerMenuService.toggle();
        };
        Object.defineProperty(HamburgerMenuComponent.prototype, "isExpanded", {
            get: function () {
                return this.hamburgerMenuService.isExpanded;
            },
            enumerable: false,
            configurable: true
        });
        return HamburgerMenuComponent;
    }());
    HamburgerMenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-hamburger-menu',
                    template: "<button\n  class=\"cx-hamburger\"\n  type=\"button\"\n  (click)=\"toggle()\"\n  [class.is-active]=\"isExpanded | async\"\n  [attr.aria-expanded]=\"isExpanded | async\"\n  aria-label=\"Menu\"\n  aria-controls=\"header-account-container, header-categories-container, header-locale-container\"\n>\n  <span class=\"hamburger-box\">\n    <span class=\"hamburger-inner\"></span>\n  </span>\n</button>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    HamburgerMenuComponent.ctorParameters = function () { return [
        { type: HamburgerMenuService }
    ]; };

    var HamburgerMenuModule = /** @class */ (function () {
        function HamburgerMenuModule() {
        }
        return HamburgerMenuModule;
    }());
    HamburgerMenuModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                HamburgerMenuComponent: {
                                    component: HamburgerMenuComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [HamburgerMenuComponent],
                    exports: [HamburgerMenuComponent],
                    entryComponents: [HamburgerMenuComponent],
                },] }
    ];

    var LayoutModule = /** @class */ (function () {
        function LayoutModule() {
        }
        return LayoutModule;
    }());
    LayoutModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [OutletRefModule, LaunchDialogModule.forRoot(), DirectionModule],
                    providers: [i1.provideConfig(defaultLayoutConfig)],
                    exports: [OutletRefModule],
                },] }
    ];

    /**
     * The `PageSlotComponent` is used to render the CMS page slot and it's components.
     *
     * The Page slot host element will be supplemented with css classes so that the layout
     * can be fully controlled by customers:
     * - The page slot _position_ is added as a css class by default.
     * - The `cx-pending` is added for as long as the slot hasn't start loading.
     * - The `page-fold` style class is added for the page slot which is configured as the page fold.
     */
    var PageSlotComponent = /** @class */ (function () {
        function PageSlotComponent(cmsService, dynamicAttributeService, renderer, elementRef, cmsComponentsService, cd) {
            var _this = this;
            this.cmsService = cmsService;
            this.dynamicAttributeService = dynamicAttributeService;
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.cmsComponentsService = cmsComponentsService;
            this.cd = cd;
            /**
             * Indicates that the page slot is the last page slot above the fold.
             */
            this.isPageFold = false;
            /**
             * Indicates that the components of the page slot haven't been loaded as long
             * as the isPending state is true.
             */
            this.isPending = true;
            /**
             * Indicates that the page slot doesn't contain any components. This is no
             * longer used in spartacus, but kept for backwards compatibility.
             */
            this.hasComponents = false;
            this.position$ = new rxjs.BehaviorSubject(undefined);
            this.slot$ = this.position$.pipe(operators.switchMap(function (position) { return _this.cmsService.getContentSlot(position); }), operators.distinctUntilChanged(this.isDistinct));
            /** Observes the components for the given page slot. */
            this.components$ = this.slot$.pipe(operators.map(function (slot) { var _a; return (_a = slot === null || slot === void 0 ? void 0 : slot.components) !== null && _a !== void 0 ? _a : []; }));
            this.subscription = new rxjs.Subscription();
            /** Keeps track of the pending components that must be loaded for the page slot */
            this.pendingComponentCount = 0;
        }
        Object.defineProperty(PageSlotComponent.prototype, "position", {
            get: function () {
                return this.position$.value;
            },
            /**
             * The position represents the unique key for a page slot on a single page, but can
             * be reused cross pages.
             *
             * The position is used to find the CMS components for the page slot. It is also
             * added as an additional CSS class so that layout can be applied.
             */
            set: function (value) {
                this.position$.next(value);
            },
            enumerable: false,
            configurable: true
        });
        PageSlotComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.slot$.pipe(operators.tap(function (slot) { return _this.decorate(slot); })).subscribe(function (value) {
                _this.components = (value === null || value === void 0 ? void 0 : value.components) || [];
                _this.cd.markForCheck();
            }));
        };
        PageSlotComponent.prototype.decorate = function (slot) {
            var _a, _b;
            var cls = this.class || '';
            if (this.lastPosition && cls.indexOf(this.lastPosition) > -1) {
                cls = cls.replace(this.lastPosition, '');
            }
            if (this.position$.value) {
                cls += " " + this.position$.value;
                this.lastPosition = this.position$.value;
            }
            // host bindings
            this.pending = ((_a = slot === null || slot === void 0 ? void 0 : slot.components) === null || _a === void 0 ? void 0 : _a.length) || 0;
            this.hasComponents = ((_b = slot === null || slot === void 0 ? void 0 : slot.components) === null || _b === void 0 ? void 0 : _b.length) > 0;
            if (cls && cls !== this.class) {
                this.class = cls;
            }
            this.addSmartEditSlotClass(slot);
        };
        Object.defineProperty(PageSlotComponent.prototype, "pending", {
            get: function () {
                return this.pendingComponentCount;
            },
            /**
             * Sets the pending count for the page slot components. Once all pending components are
             * loaded, the `isPending` flag is updated, so that the associated class can be updated
             */
            set: function (count) {
                this.pendingComponentCount = count;
                this.isPending = this.pendingComponentCount > 0;
            },
            enumerable: false,
            configurable: true
        });
        /*
         * Is triggered when a component is added to the view. This is used to
         * update the pending count
         */
        PageSlotComponent.prototype.isLoaded = function (loadState) {
            if (loadState) {
                this.pending--;
                this.cd.markForCheck();
            }
        };
        /**
         * The `DeferLoadingStrategy` indicates whether the component should be
         * rendered instantly or whether it should be deferred.
         */
        PageSlotComponent.prototype.getComponentDeferOptions = function (componentType) {
            var deferLoading = this.cmsComponentsService.getDeferLoadingStrategy(componentType);
            return { deferLoading: deferLoading };
        };
        PageSlotComponent.prototype.isDistinct = function (old, current) {
            var _a;
            return (current.components &&
                ((_a = old.components) === null || _a === void 0 ? void 0 : _a.length) === current.components.length &&
                !old.components.find(function (el, index) { return el.uid !== current.components[index].uid; }));
        };
        PageSlotComponent.prototype.addSmartEditSlotClass = function (slot) {
            if (slot) {
                this.dynamicAttributeService.addDynamicAttributes(this.elementRef.nativeElement, this.renderer, { slotData: slot });
            }
        };
        PageSlotComponent.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        };
        return PageSlotComponent;
    }());
    PageSlotComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-page-slot,[cx-page-slot]',
                    template: "<ng-template\n  [cxOutlet]=\"position\"\n  [cxOutletContext]=\"{ components$: components$ }\"\n>\n  <ng-template\n    *ngFor=\"let component of components\"\n    [cxOutlet]=\"component.flexType\"\n    [cxOutletContext]=\"{ component: component }\"\n    [cxOutletDefer]=\"getComponentDeferOptions(component.flexType)\"\n    (loaded)=\"isLoaded($event)\"\n  >\n    <ng-container [cxComponentWrapper]=\"component\"></ng-container>\n  </ng-template>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PageSlotComponent.ctorParameters = function () { return [
        { type: i1.CmsService },
        { type: i1.DynamicAttributeService },
        { type: i0.Renderer2 },
        { type: i0.ElementRef },
        { type: CmsComponentsService },
        { type: i0.ChangeDetectorRef }
    ]; };
    PageSlotComponent.propDecorators = {
        position: [{ type: i0.Input }],
        class: [{ type: i0.Input }, { type: i0.HostBinding }],
        isPageFold: [{ type: i0.HostBinding, args: ['class.page-fold',] }, { type: i0.Input }],
        isPending: [{ type: i0.HostBinding, args: ['class.cx-pending',] }],
        hasComponents: [{ type: i0.HostBinding, args: ['class.has-components',] }, { type: i0.Input }]
    };

    var PageSlotModule = /** @class */ (function () {
        function PageSlotModule() {
        }
        return PageSlotModule;
    }());
    PageSlotModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, OutletModule, PageComponentModule],
                    providers: [],
                    declarations: [PageSlotComponent],
                    exports: [PageSlotComponent],
                },] }
    ];

    var PageLayoutService = /** @class */ (function () {
        function PageLayoutService(cms, config, breakpointService, handlers) {
            this.cms = cms;
            this.config = config;
            this.breakpointService = breakpointService;
            this.handlers = handlers;
            // Prints warn messages for missing layout configs.
            // The warnings are only printed once per config
            // to not pollute the console log.
            this.warnLogMessages = {};
            this.logSlots = {};
        }
        PageLayoutService.prototype.getSlots = function (section) {
            var _this = this;
            return rxjs.combineLatest([this.page$, this.breakpointService.breakpoint$]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), page = _b[0], breakpoint = _b[1];
                var pageTemplate = page.template;
                var slots = _this.resolveSlots(page, section, breakpoint);
                return { slots: slots, pageTemplate: pageTemplate, breakpoint: breakpoint };
            }), operators.switchMap(function (_a) {
                var e_1, _b;
                var slots = _a.slots, pageTemplate = _a.pageTemplate, breakpoint = _a.breakpoint;
                var result = rxjs.of(slots);
                try {
                    for (var _c = __values(_this.handlers || []), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var handler = _d.value;
                        result = handler.handle(result, pageTemplate, section, breakpoint);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return result;
            }), operators.distinctUntilChanged(function (a, b) {
                if (a.length !== b.length) {
                    return false;
                }
                for (var i = 0; i < a.length; i++) {
                    if (a[i] !== b[i]) {
                        return false;
                    }
                }
                return true;
            }));
        };
        /**
         * Returns an observable with the last page slot above-the-fold
         * for the given pageTemplate / breakpoint.
         *
         * The page fold is configurable in the `LayoutConfig` for each page layout.
         */
        PageLayoutService.prototype.getPageFoldSlot = function (pageTemplate) {
            var _this = this;
            return this.breakpointService.breakpoint$.pipe(operators.map(function (breakpoint) {
                if (!_this.config.layoutSlots) {
                    // no layout config available
                    return null;
                }
                var pageTemplateConfig = _this.config.layoutSlots[pageTemplate];
                var config = _this.getResponsiveSlotConfig(pageTemplateConfig, 'pageFold', breakpoint);
                return config ? config.pageFold : null;
            }));
        };
        PageLayoutService.prototype.resolveSlots = function (page, section, breakpoint) {
            var config = this.getSlotConfig(page.template, 'slots', section, breakpoint);
            if (config && config.slots) {
                var pageSlots_1 = Object.keys(page.slots);
                return config.slots.filter(function (slot) { return pageSlots_1.includes(slot); });
            }
            else if (!section) {
                this.logMissingLayoutConfig(page);
                return Object.keys(page.slots);
            }
            else {
                this.logMissingLayoutConfig(page, section);
                return [];
            }
        };
        Object.defineProperty(PageLayoutService.prototype, "page$", {
            get: function () {
                return this.cms.getCurrentPage().pipe(operators.filter(function (page) { return !!page; }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageLayoutService.prototype, "templateName$", {
            get: function () {
                return this.page$.pipe(operators.filter(function (page) { return !!page.template; }), operators.map(function (page) { return page.template; }));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * load slots from the layout configuration. The breakpoint is used
         * to load a specific configuration for the given breakpoint. If there's
         * no configuration available for the given breakpoint the default slot
         * configuration is returned.
         */
        PageLayoutService.prototype.getSlotConfig = function (templateUid, configAttribute, section, breakpoint) {
            if (!this.config.layoutSlots) {
                return null;
            }
            var pageTemplateConfig = this.config.layoutSlots[templateUid];
            if (section) {
                return this.getSlotConfigForSection(templateUid, configAttribute, section, breakpoint);
            }
            if (pageTemplateConfig) {
                return this.getResponsiveSlotConfig(pageTemplateConfig, configAttribute, breakpoint);
            }
        };
        PageLayoutService.prototype.getSlotConfigForSection = function (templateUid, configAttribute, section, breakpoint) {
            var pageTemplateConfig = this.config.layoutSlots[templateUid];
            if (!pageTemplateConfig) {
                return null;
            }
            // if there's no section config on the page layout
            // we fall back to the global section config
            var sectionConfig = pageTemplateConfig[section]
                ? pageTemplateConfig[section]
                : this.config.layoutSlots[section];
            if (!sectionConfig) {
                return null;
            }
            var responsiveConfig = this.getResponsiveSlotConfig(sectionConfig, configAttribute, breakpoint);
            if (responsiveConfig.hasOwnProperty(configAttribute)) {
                return responsiveConfig;
            }
            else if (pageTemplateConfig[section].hasOwnProperty(configAttribute)) {
                return pageTemplateConfig[section];
            }
            else if (this.config.layoutSlots[section]) {
                return this.config.layoutSlots[section];
            }
        };
        /**
         * Returns a list of slots for a breakpoint specific configuration
         * If there's no specific configuration for the breakpoint,
         * the closest available configuration will be returned.
         */
        PageLayoutService.prototype.getResponsiveSlotConfig = function (layoutSlotConfig, configAttribute, breakpoint) {
            var e_2, _a;
            var slotConfig = layoutSlotConfig;
            // fallback to default slot config
            if (!layoutSlotConfig || !breakpoint) {
                return slotConfig;
            }
            // we have a config for the specific breakpoint
            if (layoutSlotConfig[breakpoint] &&
                layoutSlotConfig[breakpoint].hasOwnProperty(configAttribute)) {
                return layoutSlotConfig[breakpoint];
            }
            // find closest config
            var all = this.breakpointService.breakpoints;
            try {
                for (var _b = __values(all.slice(0, all.indexOf(breakpoint))), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var br = _c.value;
                    if (layoutSlotConfig[br] &&
                        layoutSlotConfig[br].hasOwnProperty(configAttribute)) {
                        slotConfig = layoutSlotConfig[br];
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return slotConfig;
        };
        /**
         * In order to help developers, we print some detailed log information in
         * case there's no layout configuration available for the given page template
         * or section. Additionally, the slot positions are printed in the console
         * in a format that can be copied / paste to the configuration.
         */
        PageLayoutService.prototype.logMissingLayoutConfig = function (page, section) {
            if (!i0.isDevMode()) {
                return;
            }
            if (!this.logSlots[page.template]) {
                // the info log is not printed in production
                // tslint:disable-next-line: no-console
                console.info("Available CMS page slots: '" + Object.keys(page.slots).join("','") + "'");
                this.logSlots[page.template] = true;
            }
            var cacheKey = section || page.template;
            if (!this.warnLogMessages[cacheKey]) {
                console.warn("No layout config found for " + cacheKey + ", you can configure a 'LayoutConfig' to control the rendering of page slots.");
                this.warnLogMessages[cacheKey] = true;
            }
        };
        return PageLayoutService;
    }());
    PageLayoutService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PageLayoutService_Factory() { return new PageLayoutService(i0.ɵɵinject(i1.CmsService), i0.ɵɵinject(LayoutConfig), i0.ɵɵinject(BreakpointService), i0.ɵɵinject(PAGE_LAYOUT_HANDLER, 8)); }, token: PageLayoutService, providedIn: "root" });
    PageLayoutService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    PageLayoutService.ctorParameters = function () { return [
        { type: i1.CmsService },
        { type: LayoutConfig },
        { type: BreakpointService },
        { type: Array, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [PAGE_LAYOUT_HANDLER,] }] }
    ]; };

    var PageLayoutComponent = /** @class */ (function () {
        function PageLayoutComponent(el, renderer, pageLayoutService) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.pageLayoutService = pageLayoutService;
            this.section$ = new rxjs.BehaviorSubject(undefined);
            this.templateName$ = this.pageLayoutService
                .templateName$;
            this.layoutName$ = this.section$.pipe(operators.switchMap(function (section) { return (section ? rxjs.of(section) : _this.templateName$); }), operators.tap(function (name) {
                _this.styleClass = name;
            }));
            this.slots$ = this.section$.pipe(operators.switchMap(function (section) { return _this.pageLayoutService.getSlots(section); }));
            this.pageFoldSlot$ = this.templateName$.pipe(operators.switchMap(function (templateName) { return _this.pageLayoutService.getPageFoldSlot(templateName); }), operators.distinctUntilChanged());
        }
        Object.defineProperty(PageLayoutComponent.prototype, "section", {
            set: function (value) {
                this.section$.next(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageLayoutComponent.prototype, "styleClass", {
            set: function (cls) {
                if (this.currentClass) {
                    this.renderer.removeClass(this.el.nativeElement, this.currentClass);
                }
                this.renderer.addClass(this.el.nativeElement, cls);
                this.currentClass = cls;
            },
            enumerable: false,
            configurable: true
        });
        return PageLayoutComponent;
    }());
    PageLayoutComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-page-layout',
                    template: "<ng-template\n  [cxOutlet]=\"layoutName$ | async\"\n  [cxOutletContext]=\"{\n    templateName$: templateName$,\n    slots$: slots$,\n    section$: section$\n  }\"\n>\n  <ng-content></ng-content>\n\n  <cx-page-slot\n    *ngFor=\"let slot of slots$ | async\"\n    [position]=\"slot\"\n    [isPageFold]=\"slot === (pageFoldSlot$ | async)\"\n  ></cx-page-slot>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    PageLayoutComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: PageLayoutService }
    ]; };
    PageLayoutComponent.propDecorators = {
        section: [{ type: i0.Input }]
    };

    /**
     * Service that adds the page template as a className to the application root element. If the root
     * element is cx-storefront, the resulting DOM would look like:
     *
     * ```html
     * <cx-storefront class="LandingPageTemplate">
     *  [...]
     * <cx-storefront>
     * ```
     */
    var PageTemplateStyleService = /** @class */ (function () {
        function PageTemplateStyleService(pageLayoutService) {
            this.pageLayoutService = pageLayoutService;
            /**
             * Keeps the subscriptions for this service so that we can unsubscribe on destroy.
             */
            this.subscription = new rxjs.Subscription();
        }
        PageTemplateStyleService.prototype.initialize = function (ref) {
            var _this = this;
            var el = ref.location.nativeElement;
            this.subscription.add(this.pageLayoutService.templateName$
                .pipe(operators.distinctUntilChanged())
                .subscribe(function (template) { return _this.addStyleClass(el, template); }));
        };
        /**
         * Adds the page template as a style class to the given element. If any page template
         * was added before, we clean it up.
         */
        PageTemplateStyleService.prototype.addStyleClass = function (el, template) {
            var _a;
            // clean up previous template class binding
            if (this.currentTemplate) {
                (_a = el.classList) === null || _a === void 0 ? void 0 : _a.remove(this.currentTemplate);
            }
            if (template) {
                this.currentTemplate = template;
                el.classList.add(this.currentTemplate);
            }
        };
        PageTemplateStyleService.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return PageTemplateStyleService;
    }());
    PageTemplateStyleService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PageTemplateStyleService_Factory() { return new PageTemplateStyleService(i0.ɵɵinject(PageLayoutService)); }, token: PageTemplateStyleService, providedIn: "root" });
    PageTemplateStyleService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    PageTemplateStyleService.ctorParameters = function () { return [
        { type: PageLayoutService }
    ]; };

    function initPageTemplateStyle(service, featureConfigService) {
        var result = function (componentRef) {
            if (featureConfigService.isLevel('2.1')) {
                service.initialize(componentRef);
            }
        };
        return result;
    }
    var PageLayoutModule = /** @class */ (function () {
        function PageLayoutModule() {
        }
        return PageLayoutModule;
    }());
    PageLayoutModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, OutletModule, PageSlotModule],
                    declarations: [PageLayoutComponent],
                    exports: [PageLayoutComponent],
                    providers: [
                        {
                            provide: i0.APP_BOOTSTRAP_LISTENER,
                            multi: true,
                            useFactory: initPageTemplateStyle,
                            deps: [PageTemplateStyleService, i1.FeatureConfigService],
                        },
                    ],
                },] }
    ];

    var PWAModuleConfig = /** @class */ (function () {
        function PWAModuleConfig() {
        }
        return PWAModuleConfig;
    }());
    PWAModuleConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function PWAModuleConfig_Factory() { return i0.ɵɵinject(i1.Config); }, token: PWAModuleConfig, providedIn: "root" });
    PWAModuleConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: i1.Config,
                },] }
    ];
    var defaultPWAModuleConfig = {
        pwa: {
            enabled: false,
            addToHomeScreen: false,
        },
    };

    var AddToHomeScreenService = /** @class */ (function () {
        function AddToHomeScreenService(config, globalMessageService, winRef) {
            this.config = config;
            this.globalMessageService = globalMessageService;
            this.winRef = winRef;
            this.canPrompt = new rxjs.BehaviorSubject(false);
            this.canPrompt$ = this.canPrompt.asObservable();
            if (this.config.pwa.addToHomeScreen) {
                this.init();
            }
        }
        AddToHomeScreenService.prototype.init = function () {
            var _this = this;
            if (this.winRef.nativeWindow) {
                this.winRef.nativeWindow.addEventListener('beforeinstallprompt', function (event) {
                    event.preventDefault();
                    _this.deferredEvent = event;
                    _this.enableAddToHomeScreen();
                });
                this.winRef.nativeWindow.addEventListener('appinstalled', function () {
                    _this.globalMessageService.add({ key: 'pwa.addedToHomeScreen' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                    _this.disableAddToHomeScreen();
                    _this.deferredEvent = null;
                });
            }
        };
        AddToHomeScreenService.prototype.enableAddToHomeScreen = function () {
            this.canPrompt.next(true);
        };
        AddToHomeScreenService.prototype.disableAddToHomeScreen = function () {
            this.canPrompt.next(false);
        };
        AddToHomeScreenService.prototype.firePrompt = function () {
            if (this.deferredEvent) {
                this.deferredEvent.prompt();
            }
        };
        return AddToHomeScreenService;
    }());
    AddToHomeScreenService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AddToHomeScreenService_Factory() { return new AddToHomeScreenService(i0.ɵɵinject(PWAModuleConfig), i0.ɵɵinject(i1.GlobalMessageService), i0.ɵɵinject(i1.WindowRef)); }, token: AddToHomeScreenService, providedIn: "root" });
    AddToHomeScreenService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AddToHomeScreenService.ctorParameters = function () { return [
        { type: PWAModuleConfig },
        { type: i1.GlobalMessageService },
        { type: i1.WindowRef }
    ]; };

    // tslint:disable-next-line:directive-class-suffix
    var AddToHomeScreenComponent = /** @class */ (function () {
        function AddToHomeScreenComponent(addToHomeScreenService) {
            this.addToHomeScreenService = addToHomeScreenService;
        }
        AddToHomeScreenComponent.prototype.ngOnInit = function () {
            this.canPrompt$ = this.addToHomeScreenService.canPrompt$;
        };
        AddToHomeScreenComponent.prototype.prompt = function () {
            this.addToHomeScreenService.firePrompt();
        };
        return AddToHomeScreenComponent;
    }());
    AddToHomeScreenComponent.decorators = [
        { type: i0.Directive }
    ];
    AddToHomeScreenComponent.ctorParameters = function () { return [
        { type: AddToHomeScreenService }
    ]; };

    var AddToHomeScreenBannerComponent = /** @class */ (function (_super) {
        __extends(AddToHomeScreenBannerComponent, _super);
        function AddToHomeScreenBannerComponent(addToHomeScreenService) {
            var _this = _super.call(this, addToHomeScreenService) || this;
            _this.addToHomeScreenService = addToHomeScreenService;
            return _this;
        }
        return AddToHomeScreenBannerComponent;
    }(AddToHomeScreenComponent));
    AddToHomeScreenBannerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-add-to-home-screen-banner',
                    template: "<div *ngIf=\"canPrompt$ | async\">\n  <div class=\"cx-add-to-home-screen-banner\">\n    <div class=\"cx-add-to-home-screen-banner-inner\">\n      <p>\n        {{ 'pwa.addToHomeScreenDescription' | cxTranslate }}\n      </p>\n      <ul>\n        <li>{{ 'pwa.noInstallationNeeded' | cxTranslate }}</li>\n        <li>{{ 'pwa.fastAccessToApplication' | cxTranslate }}</li>\n      </ul>\n      <button (click)=\"prompt()\" class=\"btn btn-primary\">\n        {{ 'pwa.addToHomeScreen' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    AddToHomeScreenBannerComponent.ctorParameters = function () { return [
        { type: AddToHomeScreenService }
    ]; };

    var AddToHomeScreenBtnComponent = /** @class */ (function (_super) {
        __extends(AddToHomeScreenBtnComponent, _super);
        function AddToHomeScreenBtnComponent(addToHomeScreenService) {
            var _this = _super.call(this, addToHomeScreenService) || this;
            _this.addToHomeScreenService = addToHomeScreenService;
            return _this;
        }
        return AddToHomeScreenBtnComponent;
    }(AddToHomeScreenComponent));
    AddToHomeScreenBtnComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-add-to-home-screen-btn',
                    template: "<span (click)=\"prompt()\">\n  <ng-content *ngIf=\"canPrompt$ | async\"></ng-content>\n</span>\n"
                },] }
    ];
    AddToHomeScreenBtnComponent.ctorParameters = function () { return [
        { type: AddToHomeScreenService }
    ]; };

    function pwaConfigurationFactory(pwaConfig) {
        return { enabled: (!i0.isDevMode() && pwaConfig.pwa.enabled) || false };
    }
    function pwaFactory(addToHomeScreenService) {
        var result = function () { return addToHomeScreenService; };
        return result;
    }
    var PwaModule = /** @class */ (function () {
        function PwaModule() {
        }
        return PwaModule;
    }());
    PwaModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        serviceWorker.ServiceWorkerModule.register('/ngsw-worker.js'),
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig(defaultPWAModuleConfig),
                        {
                            provide: serviceWorker.SwRegistrationOptions,
                            useFactory: pwaConfigurationFactory,
                            deps: [i1.Config],
                        },
                        {
                            provide: i0.APP_INITIALIZER,
                            useFactory: pwaFactory,
                            deps: [AddToHomeScreenService],
                            multi: true,
                        },
                    ],
                    declarations: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                    exports: [AddToHomeScreenBtnComponent, AddToHomeScreenBannerComponent],
                },] }
    ];

    var htmlLangProvider = {
        provide: i0.APP_INITIALIZER,
        multi: true,
        useFactory: setHtmlLangAttribute,
        deps: [i1.WindowRef, i1.LanguageService],
    };
    /**
     * Sets active language in <html lang="">
     */
    function setHtmlLangAttribute(winRef, languageService) {
        var result = function () {
            languageService.getActive().subscribe(function (lang) {
                winRef.document.documentElement.lang = lang.replace(/_/g, '-');
            });
        };
        return result;
    }

    var SeoMetaService = /** @class */ (function () {
        function SeoMetaService(ngTitle, ngMeta, pageMetaService) {
            this.ngTitle = ngTitle;
            this.ngMeta = ngMeta;
            this.pageMetaService = pageMetaService;
        }
        SeoMetaService.prototype.init = function () {
            var _this = this;
            this.subscription = this.pageMetaService
                .getMeta()
                .pipe(operators.filter(Boolean))
                .subscribe(function (meta) { return (_this.meta = meta); });
        };
        Object.defineProperty(SeoMetaService.prototype, "meta", {
            set: function (meta) {
                this.title = meta.title;
                this.description = meta.description;
                this.image = meta.image;
                this.robots = meta.robots || [i1.PageRobotsMeta.INDEX, i1.PageRobotsMeta.FOLLOW];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "title", {
            set: function (title) {
                this.ngTitle.setTitle(title || '');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "description", {
            set: function (value) {
                this.addTag({ name: 'description', content: value });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "image", {
            set: function (imageUrl) {
                if (imageUrl) {
                    this.addTag({ name: 'og:image', content: imageUrl });
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SeoMetaService.prototype, "robots", {
            set: function (value) {
                if (value) {
                    this.addTag({ name: 'robots', content: value.join(', ') });
                }
            },
            enumerable: false,
            configurable: true
        });
        SeoMetaService.prototype.addTag = function (meta) {
            if (meta.content) {
                this.ngMeta.updateTag(meta);
            }
        };
        SeoMetaService.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return SeoMetaService;
    }());
    SeoMetaService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SeoMetaService_Factory() { return new SeoMetaService(i0.ɵɵinject(i1$2.Title), i0.ɵɵinject(i1$2.Meta), i0.ɵɵinject(i1.PageMetaService)); }, token: SeoMetaService, providedIn: "root" });
    SeoMetaService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    SeoMetaService.ctorParameters = function () { return [
        { type: i1$2.Title },
        { type: i1$2.Meta },
        { type: i1.PageMetaService }
    ]; };

    var JsonLdScriptFactory = /** @class */ (function () {
        function JsonLdScriptFactory(platformId, winRef, rendererFactory, sanitizer) {
            this.platformId = platformId;
            this.winRef = winRef;
            this.rendererFactory = rendererFactory;
            this.sanitizer = sanitizer;
        }
        JsonLdScriptFactory.prototype.build = function (schema) {
            if (schema && this.isJsonLdRequired()) {
                this.createJsonLdScriptElement().innerHTML = this.sanitize(schema);
            }
        };
        /**
         * Only return schema data in case of SSR or development mode,
         * to not waste memory unnecessary.
         */
        JsonLdScriptFactory.prototype.isJsonLdRequired = function () {
            return !i1$1.isPlatformBrowser(this.platformId) || i0.isDevMode();
        };
        JsonLdScriptFactory.prototype.createJsonLdScriptElement = function () {
            var id = 'json-ld';
            var scriptElement = (this.winRef.document.getElementById(id));
            if (!scriptElement) {
                var renderer = this.rendererFactory.createRenderer(null, null);
                var script = renderer.createElement('script');
                script.id = id;
                script.type = 'application/ld+json';
                renderer.appendChild(this.winRef.document.body, script);
                scriptElement = script;
            }
            return scriptElement;
        };
        /**
         * Sanitizes the given json-ld schema by leveraging the angular HTML sanitizer.
         *
         * The given schema is not trusted, as malicious code could be injected (XSS)
         * into the json-ld script.
         */
        JsonLdScriptFactory.prototype.sanitize = function (schema) {
            var _this = this;
            return JSON.stringify(schema, function (_key, value) { return typeof value === 'string'
                ? _this.sanitizer.sanitize(i0.SecurityContext.HTML, value)
                : value; });
        };
        return JsonLdScriptFactory;
    }());
    JsonLdScriptFactory.ɵprov = i0.ɵɵdefineInjectable({ factory: function JsonLdScriptFactory_Factory() { return new JsonLdScriptFactory(i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i1.WindowRef), i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(i1$2.DomSanitizer)); }, token: JsonLdScriptFactory, providedIn: "root" });
    JsonLdScriptFactory.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    JsonLdScriptFactory.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: i1.WindowRef },
        { type: i0.RendererFactory2 },
        { type: i1$2.DomSanitizer }
    ]; };

    /**
     * Low level directive that adds a json-ld script tag to the component.
     * This code bypasses the strict XSS security, as otherwise we're not able
     * to append a script tag with JS inside.
     */
    var JsonLdDirective = /** @class */ (function () {
        function JsonLdDirective(jsonLdScriptFactory, sanitizer) {
            this.jsonLdScriptFactory = jsonLdScriptFactory;
            this.sanitizer = sanitizer;
        }
        Object.defineProperty(JsonLdDirective.prototype, "cxJsonLd", {
            set: function (schema) {
                this.writeJsonLd(schema);
            },
            enumerable: false,
            configurable: true
        });
        JsonLdDirective.prototype.writeJsonLd = function (schema) {
            if (schema && this.jsonLdScriptFactory.isJsonLdRequired()) {
                var sanitizedSchema = this.jsonLdScriptFactory.sanitize(schema);
                var html = "<script type=\"application/ld+json\">" + sanitizedSchema + "</script>";
                this.jsonLD = this.sanitizer.bypassSecurityTrustHtml(html);
            }
        };
        return JsonLdDirective;
    }());
    JsonLdDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cxJsonLd]',
                },] }
    ];
    JsonLdDirective.ctorParameters = function () { return [
        { type: JsonLdScriptFactory },
        { type: i1$2.DomSanitizer }
    ]; };
    JsonLdDirective.propDecorators = {
        cxJsonLd: [{ type: i0.Input }],
        jsonLD: [{ type: i0.HostBinding, args: ['innerHTML',] }]
    };

    /**
     * Injection token to extend schema builders for adding structural data (json-ld).
     *
     * Some builders (i.e. `JSONLD_PRODUCT_BUILDER`) might have additional
     * lowever level builder to further extend the schema.
     */
    var SCHEMA_BUILDER = new i0.InjectionToken('SchemaBuilderToken');
    /**
     * Injection token to add specific json-ld builders for product related schema's.
     * See see https://schema.org/product for more information.
     */
    var JSONLD_PRODUCT_BUILDER = new i0.InjectionToken('JsonLdProductBuilderToken');

    var StructuredDataFactory = /** @class */ (function () {
        function StructuredDataFactory(scriptBuilder, builders) {
            this.scriptBuilder = scriptBuilder;
            this.builders = builders;
        }
        StructuredDataFactory.prototype.build = function () {
            var _this = this;
            this.subscription = this.collectSchemas().subscribe(function (schema) {
                _this.scriptBuilder.build(schema);
            });
        };
        StructuredDataFactory.prototype.collectSchemas = function () {
            if (!this.scriptBuilder.isJsonLdRequired() || !this.builders) {
                return rxjs.of();
            }
            return rxjs.combineLatest(this.builders.map(function (builder) { return builder.build(); })).pipe();
        };
        StructuredDataFactory.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return StructuredDataFactory;
    }());
    StructuredDataFactory.ɵprov = i0.ɵɵdefineInjectable({ factory: function StructuredDataFactory_Factory() { return new StructuredDataFactory(i0.ɵɵinject(JsonLdScriptFactory), i0.ɵɵinject(SCHEMA_BUILDER, 8)); }, token: StructuredDataFactory, providedIn: "root" });
    StructuredDataFactory.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    StructuredDataFactory.ctorParameters = function () { return [
        { type: JsonLdScriptFactory },
        { type: Array, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [SCHEMA_BUILDER,] }] }
    ]; };

    /**
     * Factory to build the structure data
     * without any interaction with the UI.
     */
    function getStructuredDataFactory(injector) {
        var result = function () {
            var factory = injector.get(StructuredDataFactory);
            factory.build();
        };
        return result;
    }
    var StructuredDataModule = /** @class */ (function () {
        function StructuredDataModule() {
        }
        return StructuredDataModule;
    }());
    StructuredDataModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    declarations: [JsonLdDirective],
                    exports: [JsonLdDirective],
                    providers: [
                        {
                            provide: i0.APP_INITIALIZER,
                            useFactory: getStructuredDataFactory,
                            deps: [i0.Injector],
                            multi: true,
                        },
                    ],
                },] }
    ];

    function initSeoService(injector) {
        var result = function () {
            var service = injector.get(SeoMetaService);
            service.init();
        };
        return result;
    }
    var SeoModule = /** @class */ (function () {
        function SeoModule() {
        }
        return SeoModule;
    }());
    SeoModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [StructuredDataModule],
                    providers: [
                        {
                            provide: i0.APP_INITIALIZER,
                            useFactory: initSeoService,
                            deps: [i0.Injector],
                            multi: true,
                        },
                        htmlLangProvider,
                    ],
                },] }
    ];

    var StorefrontComponent = /** @class */ (function () {
        function StorefrontComponent(hamburgerMenuService, routingService, elementRef, keyboardFocusService) {
            this.hamburgerMenuService = hamburgerMenuService;
            this.routingService = routingService;
            this.elementRef = elementRef;
            this.keyboardFocusService = keyboardFocusService;
            this.isExpanded$ = this.hamburgerMenuService.isExpanded;
            // required by esc focus
            this.tabindex = '0';
            this.keyboardFocusConfig = {
                focusOnEscape: true,
                focusOnDoubleEscape: true,
            };
        }
        StorefrontComponent.prototype.handleEscape = function (event) {
            this.keyboardFocusService.handleEscape(this.elementRef.nativeElement, this.keyboardFocusConfig, event);
        };
        StorefrontComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.navigateSubscription = this.routingService
                .isNavigating()
                .subscribe(function (val) {
                _this.startNavigating = val === true;
                _this.stopNavigating = val === false;
            });
        };
        StorefrontComponent.prototype.collapseMenuIfClickOutside = function (event) {
            if (event.target.className.includes('is-expanded')) {
                this.collapseMenu();
            }
        };
        StorefrontComponent.prototype.collapseMenu = function () {
            this.hamburgerMenuService.toggle(true);
        };
        StorefrontComponent.prototype.ngOnDestroy = function () {
            if (this.navigateSubscription) {
                this.navigateSubscription.unsubscribe();
            }
        };
        return StorefrontComponent;
    }());
    StorefrontComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-storefront',
                    template: "<ng-template cxOutlet=\"cx-storefront\">\n  <ng-template cxOutlet=\"cx-header\">\n    <header\n      cxSkipLink=\"cx-header\"\n      [cxFocus]=\"{ disableMouseFocus: true }\"\n      [class.is-expanded]=\"isExpanded$ | async\"\n      (keydown.escape)=\"collapseMenu()\"\n      (click)=\"collapseMenuIfClickOutside($event)\"\n    >\n      <cx-page-layout section=\"header\"></cx-page-layout>\n      <cx-page-layout section=\"navigation\"></cx-page-layout>\n    </header>\n    <cx-page-slot position=\"BottomHeaderSlot\"></cx-page-slot>\n    <cx-global-message></cx-global-message>\n  </ng-template>\n\n  <main cxSkipLink=\"cx-main\" [cxFocus]=\"{ disableMouseFocus: true }\">\n    <router-outlet></router-outlet>\n  </main>\n\n  <ng-template cxOutlet=\"cx-footer\">\n    <footer cxSkipLink=\"cx-footer\" [cxFocus]=\"{ disableMouseFocus: true }\">\n      <cx-page-layout section=\"footer\"></cx-page-layout>\n    </footer>\n  </ng-template>\n</ng-template>\n"
                },] }
    ];
    StorefrontComponent.ctorParameters = function () { return [
        { type: HamburgerMenuService },
        { type: i1.RoutingService },
        { type: i0.ElementRef },
        { type: KeyboardFocusService }
    ]; };
    StorefrontComponent.propDecorators = {
        startNavigating: [{ type: i0.HostBinding, args: ['class.start-navigating',] }],
        stopNavigating: [{ type: i0.HostBinding, args: ['class.stop-navigating',] }],
        tabindex: [{ type: i0.HostBinding, args: ['tabindex',] }],
        child: [{ type: i0.ViewChild, args: [SkipLinkComponent,] }],
        handleEscape: [{ type: i0.HostListener, args: ['keydown.escape', ['$event'],] }]
    };

    var MainModule = /** @class */ (function () {
        function MainModule() {
        }
        return MainModule;
    }());
    MainModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        GlobalMessageComponentModule,
                        OutletModule,
                        OutletRefModule,
                        PwaModule,
                        PageLayoutModule,
                        SeoModule,
                        PageSlotModule,
                        AnonymousConsentsDialogModule,
                        i1.FeaturesConfigModule,
                        SkipLinkModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [StorefrontComponent],
                    exports: [StorefrontComponent],
                },] }
    ];

    var CmsGuardsService = /** @class */ (function () {
        function CmsGuardsService(cmsComponentsService, injector) {
            this.cmsComponentsService = cmsComponentsService;
            this.injector = injector;
        }
        CmsGuardsService.prototype.cmsPageCanActivate = function (componentTypes, route, state) {
            var _this = this;
            var guards = this.cmsComponentsService.getGuards(componentTypes);
            if (guards.length) {
                var canActivateObservables = guards.map(function (guardClass) {
                    var guard = _this.injector.get(guardClass, null);
                    if (isCanActivate(guard)) {
                        return wrapIntoObservable(guard.canActivate(route, state)).pipe(operators.first());
                    }
                    else {
                        throw new Error('Invalid CanActivate guard in cmsMapping');
                    }
                });
                return rxjs.concat.apply(void 0, __spread(canActivateObservables)).pipe(operators.skipWhile(function (canActivate) { return canActivate === true; }), operators.endWith(true), operators.first());
            }
            else {
                return rxjs.of(true);
            }
        };
        return CmsGuardsService;
    }());
    CmsGuardsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsGuardsService_Factory() { return new CmsGuardsService(i0.ɵɵinject(CmsComponentsService), i0.ɵɵinject(i0.INJECTOR)); }, token: CmsGuardsService, providedIn: "root" });
    CmsGuardsService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CmsGuardsService.ctorParameters = function () { return [
        { type: CmsComponentsService },
        { type: i0.Injector }
    ]; };
    function wrapIntoObservable(value) {
        if (rxjs.isObservable(value)) {
            return value;
        }
        if (isPromise(value)) {
            return rxjs.from(Promise.resolve(value));
        }
        return rxjs.of(value);
    }
    function isPromise(obj) {
        return !!obj && typeof obj.then === 'function';
    }
    function isCanActivate(guard) {
        return guard && isFunction(guard.canActivate);
    }
    function isFunction(v) {
        return typeof v === 'function';
    }

    var CmsI18nService = /** @class */ (function () {
        function CmsI18nService(cmsComponentsService, translation, translationChunk) {
            this.cmsComponentsService = cmsComponentsService;
            this.translation = translation;
            this.translationChunk = translationChunk;
        }
        CmsI18nService.prototype.loadForComponents = function (componentTypes) {
            var e_1, _a;
            var i18nKeys = this.cmsComponentsService.getI18nKeys(componentTypes);
            var i18nChunks = new Set();
            try {
                for (var i18nKeys_1 = __values(i18nKeys), i18nKeys_1_1 = i18nKeys_1.next(); !i18nKeys_1_1.done; i18nKeys_1_1 = i18nKeys_1.next()) {
                    var key = i18nKeys_1_1.value;
                    i18nChunks.add(this.translationChunk.getChunkNameForKey(key));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (i18nKeys_1_1 && !i18nKeys_1_1.done && (_a = i18nKeys_1.return)) _a.call(i18nKeys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.translation.loadChunks(Array.from(i18nChunks));
        };
        return CmsI18nService;
    }());
    CmsI18nService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsI18nService_Factory() { return new CmsI18nService(i0.ɵɵinject(CmsComponentsService), i0.ɵɵinject(i1.TranslationService), i0.ɵɵinject(i1.TranslationChunkService)); }, token: CmsI18nService, providedIn: "root" });
    CmsI18nService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CmsI18nService.ctorParameters = function () { return [
        { type: CmsComponentsService },
        { type: i1.TranslationService },
        { type: i1.TranslationChunkService }
    ]; };

    // This service should be exposed in public API only after the refactor planned in https://github.com/SAP/spartacus/issues/7070
    var CmsRoutesImplService = /** @class */ (function () {
        function CmsRoutesImplService(router, cmsComponentsService) {
            this.router = router;
            this.cmsComponentsService = cmsComponentsService;
        }
        CmsRoutesImplService.prototype.cmsRouteExists = function (url) {
            var isCmsDrivenRoute = url.startsWith('/');
            if (!isCmsDrivenRoute) {
                return false;
            }
            var routePath = url.substr(1);
            return (isCmsDrivenRoute &&
                !!this.router.config.find(function (route) { return route.data && route.data.cxCmsRouteContext && route.path === routePath; }));
        };
        /**
         * Contains Cms driven routing logic intended for use use in guards, especially in canActivate method.
         *
         * Will return true, when logic wont have to modify routing (so canActivate could be easily resolved to true)
         * or will return false, when routing configuration was updated and redirection to newly generated route was initiated.
         *
         * @param pageContext
         * @param currentUrl
         */
        CmsRoutesImplService.prototype.handleCmsRoutesInGuard = function (pageContext, componentTypes, currentUrl, currentPageLabel) {
            var _a;
            if (this.cmsRouteExists(currentPageLabel)) {
                return true;
            }
            var childRoutesConfig = this.cmsComponentsService.getChildRoutes(componentTypes);
            if ((_a = childRoutesConfig === null || childRoutesConfig === void 0 ? void 0 : childRoutesConfig.children) === null || _a === void 0 ? void 0 : _a.length) {
                if (this.updateRouting(pageContext, currentPageLabel, childRoutesConfig)) {
                    this.router.navigateByUrl(currentUrl);
                    return false;
                }
            }
            return true;
        };
        CmsRoutesImplService.prototype.updateRouting = function (pageContext, pageLabel, childRoutesConfig) {
            var _a, _b;
            if (pageContext.type === i1.PageType.CONTENT_PAGE &&
                pageLabel.startsWith('/') &&
                pageLabel.length > 1) {
                var newRoute = {
                    path: pageLabel.substr(1),
                    component: PageLayoutComponent,
                    children: childRoutesConfig.children,
                    data: i1.deepMerge({}, (_b = (_a = childRoutesConfig === null || childRoutesConfig === void 0 ? void 0 : childRoutesConfig.parent) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {}, {
                        cxCmsRouteContext: {
                            type: pageContext.type,
                            id: pageLabel,
                        },
                    }),
                };
                this.router.resetConfig(__spread([newRoute], this.router.config));
                return true;
            }
            return false;
        };
        return CmsRoutesImplService;
    }());
    CmsRoutesImplService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsRoutesImplService_Factory() { return new CmsRoutesImplService(i0.ɵɵinject(i4.Router), i0.ɵɵinject(CmsComponentsService)); }, token: CmsRoutesImplService, providedIn: "root" });
    CmsRoutesImplService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    CmsRoutesImplService.ctorParameters = function () { return [
        { type: i4.Router },
        { type: CmsComponentsService }
    ]; };

    // Public injection token for the private implementation of the service `CmsRoutesImplService`.
    // After #7070, this class should be replaced with a real implementation.
    var CmsRoutesService = /** @class */ (function () {
        function CmsRoutesService() {
        }
        return CmsRoutesService;
    }());
    CmsRoutesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsRoutesService_Factory() { return i0.ɵɵinject(CmsRoutesImplService); }, token: CmsRoutesService, providedIn: "root" });
    CmsRoutesService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                    useExisting: CmsRoutesImplService,
                },] }
    ];

    /**
     * Helper service for `CmsPageGuard`
     */
    var CmsPageGuardService = /** @class */ (function () {
        function CmsPageGuardService(semanticPathService, cmsService, cmsRoutes, cmsI18n, cmsGuards, cmsComponentsService) {
            this.semanticPathService = semanticPathService;
            this.cmsService = cmsService;
            this.cmsRoutes = cmsRoutes;
            this.cmsI18n = cmsI18n;
            this.cmsGuards = cmsGuards;
            this.cmsComponentsService = cmsComponentsService;
        }
        /**
         * Takes CMS components types in the current CMS page, triggers (configurable) side effects and returns a boolean - whether the route can be activated.
         *
         * Based on `cmsComponents` config for the components in the page:
         * - Evaluates components' guards; if one of them emits false or UrlTree - the route cannot be activated or redirects to the given UrlTree, respectively.
         * - If all components' guards emitted true, then the route can be activated
         * - Then we trigger loading of configured i18n chunks in parallel
         * - And we register the configured children routes of cms components
         *
         * @param pageContext current cms page context
         * @param pageData cms page data
         * @param route activated route snapshot
         * @param state router state snapshot
         *
         * @returns boolean observable - whether the route can be activated
         */
        CmsPageGuardService.prototype.canActivatePage = function (pageContext, pageData, route, state) {
            var _this = this;
            return this.cmsService.getPageComponentTypes(pageContext).pipe(operators.take(1), operators.switchMap(function (componentTypes) { return _this.cmsComponentsService.determineMappings(componentTypes); }), operators.switchMap(function (componentTypes) { return _this.cmsGuards
                .cmsPageCanActivate(componentTypes, route, state)
                .pipe(operators.withLatestFrom(rxjs.of(componentTypes))); }), operators.tap(function (_b) {
                var _c = __read(_b, 2), canActivate = _c[0], componentTypes = _c[1];
                if (canActivate === true) {
                    _this.cmsI18n.loadForComponents(componentTypes);
                }
            }), operators.map(function (_b) {
                var _c = __read(_b, 2), canActivate = _c[0], componentTypes = _c[1];
                var _a;
                var pageLabel = pageData.label || pageContext.id; // for content pages the page label returned from backend can be different than ID initially assumed from route
                if (canActivate === true && !((_a = route === null || route === void 0 ? void 0 : route.data) === null || _a === void 0 ? void 0 : _a.cxCmsRouteContext)) {
                    return _this.cmsRoutes.handleCmsRoutesInGuard(pageContext, componentTypes, state.url, pageLabel);
                }
                return canActivate;
            }));
        };
        /**
         * Activates the "NOT FOUND" cms page.
         *
         * It loads cms page data for the "NOT FOUND" page and puts it in the state of the the requested page label.
         * Then it processes its CMS components with the method `canActivatePage()` of this service. For more, see its docs.
         */
        CmsPageGuardService.prototype.canActivateNotFoundPage = function (pageContext, route, state) {
            var _this = this;
            var notFoundCmsPageContext = {
                type: i1.PageType.CONTENT_PAGE,
                id: this.semanticPathService.get('notFound'),
            };
            return this.cmsService.getPage(notFoundCmsPageContext).pipe(operators.switchMap(function (notFoundPage) {
                if (notFoundPage) {
                    return _this.cmsService.getPageIndex(notFoundCmsPageContext).pipe(operators.tap(function (notFoundIndex) {
                        _this.cmsService.setPageFailIndex(pageContext, notFoundIndex);
                    }), operators.switchMap(function (notFoundIndex) { return _this.cmsService.getPageIndex(pageContext).pipe(
                    // we have to wait for page index update
                    operators.filter(function (index) { return index === notFoundIndex; })); }), operators.switchMap(function () { return _this.canActivatePage(pageContext, notFoundPage, route, state); }));
                }
                return rxjs.of(false);
            }));
        };
        return CmsPageGuardService;
    }());
    CmsPageGuardService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsPageGuardService_Factory() { return new CmsPageGuardService(i0.ɵɵinject(i1.SemanticPathService), i0.ɵɵinject(i1.CmsService), i0.ɵɵinject(CmsRoutesService), i0.ɵɵinject(CmsI18nService), i0.ɵɵinject(CmsGuardsService), i0.ɵɵinject(CmsComponentsService)); }, token: CmsPageGuardService, providedIn: "root" });
    CmsPageGuardService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CmsPageGuardService.ctorParameters = function () { return [
        { type: i1.SemanticPathService },
        { type: i1.CmsService },
        { type: CmsRoutesService },
        { type: CmsI18nService },
        { type: CmsGuardsService },
        { type: CmsComponentsService }
    ]; };

    var CmsPageGuard = /** @class */ (function () {
        function CmsPageGuard(routingService, cmsService, protectedRoutesGuard, service, routingConfig) {
            this.routingService = routingService;
            this.cmsService = cmsService;
            this.protectedRoutesGuard = protectedRoutesGuard;
            this.service = service;
            this.routingConfig = routingConfig;
        }
        /**
         * Tries to load the CMS page data for the anticipated route and returns:
         * - `true` - if it can be activated
         * - `false` - if it cannot be activated
         * - `UrlTree` - if user should be redirected to a given `UrlTree`
         *
         * If the route can be activated, it fires additional calculations on the CMS components present on this CMS page,
         * based on their configuration (`cmsComponents` config).
         *
         * For more, see docs of the `CmsPageGuardService.canActivatePage`.
         */
        CmsPageGuard.prototype.canActivate = function (route, state) {
            var _this = this;
            return this.protectedRoutesGuard.canActivate(route).pipe(operators.switchMap(function (canActivate) { return canActivate
                ? _this.routingService.getNextPageContext().pipe(operators.switchMap(function (pageContext) { return _this.cmsService.getPage(pageContext, _this.shouldReload()).pipe(operators.first(), operators.switchMap(function (pageData) { return pageData
                    ? _this.service.canActivatePage(pageContext, pageData, route, state)
                    : _this.service.canActivateNotFoundPage(pageContext, route, state); })); }))
                : rxjs.of(false); }));
        };
        /**
         * Returns whether we should reload the CMS page data, even when it was loaded before.
         */
        CmsPageGuard.prototype.shouldReload = function () {
            return this.routingConfig.getLoadStrategy() !== "once" /* ONCE */;
        };
        return CmsPageGuard;
    }());
    CmsPageGuard.guardName = 'CmsPageGuard';
    CmsPageGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsPageGuard_Factory() { return new CmsPageGuard(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.CmsService), i0.ɵɵinject(i1.ProtectedRoutesGuard), i0.ɵɵinject(CmsPageGuardService), i0.ɵɵinject(i1.RoutingConfigService)); }, token: CmsPageGuard, providedIn: "root" });
    CmsPageGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CmsPageGuard.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.CmsService },
        { type: i1.ProtectedRoutesGuard },
        { type: CmsPageGuardService },
        { type: i1.RoutingConfigService }
    ]; };

    var cmsRoute = {
        path: '**',
        canActivate: [CmsPageGuard],
        component: PageLayoutComponent,
    };
    function addCmsRoute(injector) {
        var result = function () {
            var router = injector.get(i4.Router);
            router.config.push(cmsRoute);
        };
        return result;
    }

    var ɵ0 = addCmsRoute;
    var CmsRouteModule = /** @class */ (function () {
        function CmsRouteModule() {
        }
        return CmsRouteModule;
    }());
    CmsRouteModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [
                        {
                            provide: i0.APP_INITIALIZER,
                            multi: true,
                            deps: [i0.Injector],
                            useFactory: ɵ0,
                        },
                    ],
                },] }
    ];

    var defaultStorefrontRoutesConfig = {
        home: { paths: [''] },
        notFound: { paths: ['not-found'] },
        cart: { paths: ['cart'] },
        // semantic links for login related pages
        login: { paths: ['login'], protected: false },
        register: { paths: ['login/register'], protected: false },
        forgotPassword: { paths: ['login/forgot-password'], protected: false },
        resetPassword: { paths: ['login/pw/change'], protected: false },
        logout: { paths: ['logout'] },
        checkoutLogin: { paths: ['checkout-login'] },
        checkout: { paths: ['checkout'] },
        checkoutPaymentType: { paths: ['checkout/payment-type'] },
        checkoutShippingAddress: { paths: ['checkout/shipping-address'] },
        checkoutDeliveryMode: { paths: ['checkout/delivery-mode'] },
        checkoutPaymentDetails: { paths: ['checkout/payment-details'] },
        checkoutReviewOrder: { paths: ['checkout/review-order'] },
        orderConfirmation: { paths: ['order-confirmation'] },
        replenishmentConfirmation: { paths: ['replenishment/confirmation'] },
        // plp routes
        search: { paths: ['search/:query'] },
        category: {
            paths: ['category/:categoryCode'],
            paramsMapping: { categoryCode: 'code' },
        },
        brand: { paths: ['Brands/:brandName/c/:brandCode'] },
        // pdp routes
        product: {
            paths: ['product/:productCode/:name'],
            paramsMapping: { productCode: 'code' },
        },
        termsAndConditions: { paths: ['terms-and-conditions'] },
        orders: {
            paths: ['my-account/orders'],
        },
        orderDetails: {
            paths: ['my-account/order/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        orderGuest: {
            paths: ['guest/order/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        orderReturn: {
            paths: ['my-account/order/return/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        orderReturnConfirmation: {
            paths: ['my-account/order/return/confirmation/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        orderCancel: {
            paths: ['my-account/order/cancel/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        orderCancelConfirmation: {
            paths: ['my-account/order/cancel/confirmation/:orderCode'],
            paramsMapping: { orderCode: 'code' },
        },
        returnRequestDetails: {
            paths: ['my-account/return-request/:returnCode'],
            paramsMapping: { returnCode: 'rma' },
        },
        coupons: { paths: ['my-account/coupons'] },
        couponClaim: {
            paths: ['my-account/coupon/claim/:couponCode'],
            paramsMapping: { couponCode: 'code' },
        },
        replenishmentOrders: {
            paths: ['my-account/my-replenishments'],
        },
        replenishmentDetails: {
            paths: ['my-account/my-replenishment/:replenishmentOrderCode'],
            paramsMapping: { replenishmentOrderCode: 'replenishmentOrderCode' },
        },
    };
    var defaultRoutingConfig = {
        routing: {
            routes: defaultStorefrontRoutesConfig,
        },
    };

    var RoutingModule = /** @class */ (function () {
        function RoutingModule() {
        }
        RoutingModule.forRoot = function () {
            return {
                ngModule: RoutingModule,
                providers: [i1.provideDefaultConfig(defaultRoutingConfig)],
            };
        };
        return RoutingModule;
    }());
    RoutingModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1.RoutingModule.forRoot(), CmsRouteModule],
                },] }
    ];

    /**
     * Matches the pattern '[ ** / ] marker / :paramName'
     *
     * @param marker phrase that indicates the start of the match
     * @param paramName name of the parameter present after the marker
     * @param precedingParamName name of the parameter for every preceding url segment
     *        i.e. `param` will result in `param0`, `param1`, ...
     */
    function getSuffixUrlMatcher(_a) {
        var marker = _a.marker, paramName = _a.paramName, precedingParamName = _a.precedingParamName;
        precedingParamName = precedingParamName || 'param';
        var matcher = function suffixUrlMatcher(segments) {
            var _a;
            var markerIndex = findLastIndex(segments, function (_a) {
                var path = _a.path;
                return path === marker;
            });
            var isMarkerLastSegment = markerIndex === segments.length - 1;
            if (markerIndex === -1 || isMarkerLastSegment) {
                return null;
            }
            var paramIndex = markerIndex + 1;
            var posParams = (_a = {},
                _a[paramName] = segments[paramIndex],
                _a);
            for (var i = 0; i < markerIndex; i++) {
                posParams["" + precedingParamName + i] = segments[i];
            }
            return { consumed: segments.slice(0, paramIndex + 1), posParams: posParams };
        };
        if (i0.isDevMode()) {
            matcher['_suffixRouteConfig'] = { marker: marker, paramName: paramName, precedingParamName: precedingParamName }; // property added for easier debugging of routes
        }
        return matcher;
    }
    function findLastIndex(elements, predicate) {
        for (var index = elements.length - 1; index >= 0; index--) {
            if (predicate(elements[index])) {
                return index;
            }
        }
        return -1;
    }

    var BreadcrumbSchemaBuilder = /** @class */ (function () {
        function BreadcrumbSchemaBuilder(pageMetaService) {
            this.pageMetaService = pageMetaService;
        }
        BreadcrumbSchemaBuilder.prototype.build = function () {
            var _this = this;
            return this.pageMetaService
                .getMeta()
                .pipe(operators.map(function (pageMeta) { return _this.collect(pageMeta); }));
        };
        BreadcrumbSchemaBuilder.prototype.collect = function (pageMeta) {
            if (!(pageMeta === null || pageMeta === void 0 ? void 0 : pageMeta.breadcrumbs)) {
                return;
            }
            var crumbs = pageMeta.breadcrumbs.map(function (crumb, index) {
                return {
                    '@type': 'ListItem',
                    position: index + 1,
                    item: {
                        '@id': crumb.link,
                        name: crumb.label,
                    },
                };
            });
            if (pageMeta.title) {
                crumbs.push({
                    '@type': 'ListItem',
                    position: crumbs.length + 1,
                    item: {
                        '@id': pageMeta.title,
                        name: pageMeta.title,
                    },
                });
            }
            return {
                '@context': 'http://schema.org',
                '@type': 'BreadcrumbList',
                itemListElement: crumbs,
            };
        };
        return BreadcrumbSchemaBuilder;
    }());
    BreadcrumbSchemaBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function BreadcrumbSchemaBuilder_Factory() { return new BreadcrumbSchemaBuilder(i0.ɵɵinject(i1.PageMetaService)); }, token: BreadcrumbSchemaBuilder, providedIn: "root" });
    BreadcrumbSchemaBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    BreadcrumbSchemaBuilder.ctorParameters = function () { return [
        { type: i1.PageMetaService }
    ]; };

    /**
     * Builds the basic structured data for the product, see https://schema.org/product.
     * This builder includes data for sku number, name, description, brand and main image.
     */
    var JsonLdBaseProductBuilder = /** @class */ (function () {
        function JsonLdBaseProductBuilder() {
        }
        JsonLdBaseProductBuilder.prototype.build = function (product) {
            return rxjs.of(Object.assign(Object.assign(Object.assign({}, this.getProductBase(product)), this.getProductBrand(product)), this.getProductImage(product)));
        };
        JsonLdBaseProductBuilder.prototype.getProductBase = function (product) {
            var result = { sku: product.code };
            if (product.name) {
                result.name = product.name;
            }
            if (product.summary) {
                result.description = product.summary;
            }
            return result;
        };
        JsonLdBaseProductBuilder.prototype.getProductImage = function (product) {
            return product.images &&
                product.images.PRIMARY &&
                product.images.PRIMARY['zoom'] &&
                product.images.PRIMARY['zoom'].url
                ? {
                    image: product.images.PRIMARY['zoom'].url,
                }
                : {};
        };
        JsonLdBaseProductBuilder.prototype.getProductBrand = function (product) {
            return product['manufacturer']
                ? {
                    brand: product['manufacturer'],
                }
                : null;
        };
        return JsonLdBaseProductBuilder;
    }());
    JsonLdBaseProductBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function JsonLdBaseProductBuilder_Factory() { return new JsonLdBaseProductBuilder(); }, token: JsonLdBaseProductBuilder, providedIn: "root" });
    JsonLdBaseProductBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Builds the structured data for the product offer, see https://schema.org/offers.
     * The data includes the price, currency and availability level.
     */
    var JsonLdProductOfferBuilder = /** @class */ (function () {
        function JsonLdProductOfferBuilder() {
        }
        JsonLdProductOfferBuilder.prototype.build = function (product) {
            var schema = { '@type': 'Offer' };
            if (product.price) {
                if (product.price.value) {
                    schema.price = product.price.value;
                }
                if (product.price.currencyIso) {
                    schema.priceCurrency = product.price.currencyIso;
                }
            }
            if (product.stock && product.stock.stockLevelStatus) {
                schema.availability =
                    product.stock.stockLevelStatus === 'inStock' ? 'InStock' : 'OutOfStock';
            }
            return rxjs.of({
                offers: schema,
            });
        };
        return JsonLdProductOfferBuilder;
    }());
    JsonLdProductOfferBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function JsonLdProductOfferBuilder_Factory() { return new JsonLdProductOfferBuilder(); }, token: JsonLdProductOfferBuilder, providedIn: "root" });
    JsonLdProductOfferBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Builds the structured data for the product reviews, see https://schema.org/Review.
     * The data includes the aggregated product rating and the individual reviews.
     */
    var JsonLdProductReviewBuilder = /** @class */ (function () {
        function JsonLdProductReviewBuilder(reviewService) {
            this.reviewService = reviewService;
        }
        JsonLdProductReviewBuilder.prototype.build = function (product) {
            var _this = this;
            return this.reviewService.getByProductCode(product.code).pipe(operators.filter(Boolean), operators.map(function (reviews) {
                return {
                    aggregateRating: _this.buildAggregatedReviews(product, reviews),
                    review: reviews.map(function (review) { return _this.buildReviews(review); }),
                };
            }));
        };
        JsonLdProductReviewBuilder.prototype.buildAggregatedReviews = function (product, reviews) {
            var aggregated = {
                '@type': 'AggregateRating',
            };
            if (product.averageRating) {
                aggregated.ratingValue = product.averageRating;
            }
            if (reviews) {
                aggregated.ratingCount = reviews.filter(function (rev) { return !!rev.rating; }).length;
                aggregated.reviewCount = reviews.filter(function (rev) { return !!rev.comment; }).length;
            }
            return aggregated;
        };
        JsonLdProductReviewBuilder.prototype.buildReviews = function (review) {
            var reviewSchema = {
                '@type': 'review',
            };
            if (review.principal && review.principal.name) {
                reviewSchema.author = review.principal.name;
            }
            if (review.date) {
                var date = new Date(review.date);
                reviewSchema.datePublished = date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate();
            }
            if (review.headline) {
                reviewSchema.name = review.headline;
            }
            if (review.comment) {
                reviewSchema.description = review.comment;
            }
            if (review.rating) {
                reviewSchema.reviewRating = {
                    '@type': 'Rating',
                    ratingValue: review.rating.toString(),
                };
            }
            return reviewSchema;
        };
        return JsonLdProductReviewBuilder;
    }());
    JsonLdProductReviewBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function JsonLdProductReviewBuilder_Factory() { return new JsonLdProductReviewBuilder(i0.ɵɵinject(i1.ProductReviewService)); }, token: JsonLdProductReviewBuilder, providedIn: "root" });
    JsonLdProductReviewBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    JsonLdProductReviewBuilder.ctorParameters = function () { return [
        { type: i1.ProductReviewService }
    ]; };

    /**
     * Adds the minimal structured data for the product, see https://schema.org/product.
     * The actual data collection is delegated to `JsonLdBuilder`s, which can be injected
     * using the `JSONLD_PRODUCT_BUILDER` token.
     */
    var ProductSchemaBuilder = /** @class */ (function () {
        function ProductSchemaBuilder(currentProduct, builders) {
            this.currentProduct = currentProduct;
            this.builders = builders;
        }
        ProductSchemaBuilder.prototype.build = function () {
            var _this = this;
            return this.currentProduct.getProduct().pipe(operators.switchMap(function (product) {
                if (product) {
                    return rxjs.combineLatest(_this.collect(product)).pipe(operators.map(function (res) { return Object.assign.apply(Object, __spread([{}], res)); }));
                }
                return rxjs.of({});
            }));
        };
        ProductSchemaBuilder.prototype.collect = function (product) {
            if (!product || !product.code) {
                return [];
            }
            var builders = this.builders
                ? this.builders.map(function (builder) { return builder.build(product); })
                : [];
            return __spread([
                rxjs.of({
                    '@context': 'http://schema.org',
                    '@type': 'Product',
                })
            ], builders);
        };
        return ProductSchemaBuilder;
    }());
    ProductSchemaBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProductSchemaBuilder_Factory() { return new ProductSchemaBuilder(i0.ɵɵinject(CurrentProductService), i0.ɵɵinject(JSONLD_PRODUCT_BUILDER, 8)); }, token: ProductSchemaBuilder, providedIn: "root" });
    ProductSchemaBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ProductSchemaBuilder.ctorParameters = function () { return [
        { type: CurrentProductService },
        { type: Array, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [JSONLD_PRODUCT_BUILDER,] }] }
    ]; };

    /**
     * Provides several standard json-ld builders that contribute
     * to colleting and building json-ld data.
     */
    var JsonLdBuilderModule = /** @class */ (function () {
        function JsonLdBuilderModule() {
        }
        return JsonLdBuilderModule;
    }());
    JsonLdBuilderModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [
                        {
                            provide: SCHEMA_BUILDER,
                            useExisting: ProductSchemaBuilder,
                            multi: true,
                        },
                        {
                            provide: SCHEMA_BUILDER,
                            useExisting: BreadcrumbSchemaBuilder,
                            multi: true,
                        },
                        // lower level json-ld builder classes offering fine-graiend control
                        // for product related schema's
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdBaseProductBuilder,
                            multi: true,
                        },
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdProductOfferBuilder,
                            multi: true,
                        },
                        {
                            provide: JSONLD_PRODUCT_BUILDER,
                            useExisting: JsonLdProductReviewBuilder,
                            multi: true,
                        },
                    ],
                },] }
    ];

    /**
     * Generic carousel that renders CMS Components.
     */
    var BannerCarouselComponent = /** @class */ (function () {
        function BannerCarouselComponent(componentData, cmsService) {
            var _this = this;
            this.componentData = componentData;
            this.cmsService = cmsService;
            this.componentData$ = this.componentData.data$.pipe(operators.filter(Boolean), operators.tap(function (d) { return (_this.theme = d.effect + "-theme"); }));
            this.items$ = this.componentData$.pipe(operators.map(function (data) { return data.banners.trim().split(' '); }), operators.map(function (codes) { return codes.map(function (code) { return _this.cmsService.getComponentData(code); }); }));
            /**
             * Adds a specific theme for the carousel. The effect can be
             * used in CSS customisations.
             */
            this.theme = '';
        }
        /**
         * Returns an Obervable with an Array of Observables. This is done, so that
         * the component UI could consider to lazy load the UI components when they're
         * in the viewpoint.
         */
        BannerCarouselComponent.prototype.getItems = function () {
            return this.items$;
        };
        return BannerCarouselComponent;
    }());
    BannerCarouselComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-banner-carousel',
                    template: "<cx-carousel\n  [items]=\"getItems() | async\"\n  [template]=\"template\"\n  itemWidth=\"100%\"\n  class=\"inline-navigation\"\n></cx-carousel>\n\n<ng-template #template let-item=\"item\">\n  <ng-container\n    [cxComponentWrapper]=\"{\n      flexType: item.typeCode,\n      typeCode: item.typeCode,\n      uid: item?.uid\n    }\"\n  >\n  </ng-container>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    BannerCarouselComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: i1.CmsService }
    ]; };
    BannerCarouselComponent.propDecorators = {
        theme: [{ type: i0.HostBinding, args: ['class',] }]
    };

    var BannerCarouselModule = /** @class */ (function () {
        function BannerCarouselModule() {
        }
        return BannerCarouselModule;
    }());
    BannerCarouselModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, PageComponentModule, CarouselModule, MediaModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                RotatingImagesComponent: {
                                    component: BannerCarouselComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BannerCarouselComponent],
                    entryComponents: [BannerCarouselComponent],
                    exports: [BannerCarouselComponent],
                },] }
    ];

    var BannerComponent = /** @class */ (function () {
        function BannerComponent(component) {
            this.component = component;
        }
        return BannerComponent;
    }());
    BannerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-banner',
                    template: "<ng-container *ngIf=\"component.data$ | async as data\">\n  <cx-generic-link\n    [url]=\"data.urlLink\"\n    [target]=\"data.external ? '_blank' : null\"\n    [title]=\"data.media?.altText\"\n  >\n    <p class=\"headline\" *ngIf=\"data.headline\" [innerHTML]=\"data.headline\"></p>\n    <cx-media [container]=\"data.media\"></cx-media>\n    <p class=\"content\" *ngIf=\"data.content\" [innerHTML]=\"data.content\"></p>\n  </cx-generic-link>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    BannerComponent.ctorParameters = function () { return [
        { type: CmsComponentData }
    ]; };

    var BannerModule = /** @class */ (function () {
        function BannerModule() {
        }
        return BannerModule;
    }());
    BannerModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, GenericLinkModule, MediaModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                SimpleResponsiveBannerComponent: {
                                    component: BannerComponent,
                                },
                                BannerComponent: {
                                    component: BannerComponent,
                                },
                                SimpleBannerComponent: {
                                    component: BannerComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BannerComponent],
                    entryComponents: [BannerComponent],
                    exports: [BannerComponent],
                },] }
    ];

    var LinkComponent = /** @class */ (function () {
        function LinkComponent(component) {
            this.component = component;
        }
        return LinkComponent;
    }());
    LinkComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-link',
                    template: "<cx-generic-link\n  *ngIf=\"component.data$ | async as data\"\n  [url]=\"data.url\"\n  [style]=\"data.styleAttributes\"\n  >{{ data.linkName }}</cx-generic-link\n>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    LinkComponent.ctorParameters = function () { return [
        { type: CmsComponentData }
    ]; };

    var LinkModule = /** @class */ (function () {
        function LinkModule() {
        }
        return LinkModule;
    }());
    LinkModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, GenericLinkModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CMSLinkComponent: { component: LinkComponent },
                            },
                        }),
                    ],
                    declarations: [LinkComponent],
                    exports: [LinkComponent],
                    entryComponents: [LinkComponent],
                },] }
    ];

    var ParagraphComponent = /** @class */ (function () {
        function ParagraphComponent(component) {
            this.component = component;
        }
        return ParagraphComponent;
    }());
    ParagraphComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-paragraph',
                    template: "<p *ngIf=\"component.data$ | async as data\" [innerHTML]=\"data.content\"></p>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ParagraphComponent.ctorParameters = function () { return [
        { type: CmsComponentData }
    ]; };

    var CmsParagraphModule = /** @class */ (function () {
        function CmsParagraphModule() {
        }
        return CmsParagraphModule;
    }());
    CmsParagraphModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CMSParagraphComponent: {
                                    component: ParagraphComponent,
                                },
                                CMSTabParagraphComponent: {
                                    component: ParagraphComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ParagraphComponent],
                    exports: [ParagraphComponent],
                    entryComponents: [ParagraphComponent],
                },] }
    ];

    var TabParagraphContainerComponent = /** @class */ (function () {
        function TabParagraphContainerComponent(componentData, cmsService, winRef, breakpointService) {
            var _this = this;
            this.componentData = componentData;
            this.cmsService = cmsService;
            this.winRef = winRef;
            this.breakpointService = breakpointService;
            this.activeTabNum = 0;
            this.tabTitleParams = [];
            this.components$ = this.componentData.data$.pipe(operators.distinctUntilChanged(function (x, y) { return (x === null || x === void 0 ? void 0 : x.components) === (y === null || y === void 0 ? void 0 : y.components); }), operators.switchMap(function (data) {
                var _a;
                return rxjs.combineLatest(((_a = data === null || data === void 0 ? void 0 : data.components) !== null && _a !== void 0 ? _a : '').split(' ').map(function (component) { return _this.cmsService.getComponentData(component).pipe(operators.distinctUntilChanged(), operators.map(function (tab) {
                    if (!tab) {
                        return undefined;
                    }
                    if (!tab.flexType) {
                        tab = Object.assign(Object.assign({}, tab), { flexType: tab.typeCode });
                    }
                    return Object.assign(Object.assign({}, tab), { title: data.uid + ".tabs." + tab.uid });
                })); }));
            }));
        }
        TabParagraphContainerComponent.prototype.select = function (tabNum, event) {
            var _this = this;
            var _a;
            (_a = this.breakpointService) === null || _a === void 0 ? void 0 : _a.isDown(exports.BREAKPOINT.sm).pipe(operators.take(1)).subscribe(function (res) {
                var _a, _b;
                if (res) {
                    _this.activeTabNum = _this.activeTabNum === tabNum ? -1 : tabNum;
                    if (event && (event === null || event === void 0 ? void 0 : event.target)) {
                        var target = event.target;
                        var parentNode = target.parentNode;
                        (_b = (_a = _this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow) === null || _b === void 0 ? void 0 : _b.scrollTo(0, parentNode.offsetTop);
                    }
                }
                else {
                    _this.activeTabNum = tabNum;
                }
            });
        };
        TabParagraphContainerComponent.prototype.ngOnInit = function () {
            var _a, _b, _c, _d, _e;
            this.activeTabNum = (_e = (_d = (_c = (_b = (_a = this.winRef) === null || _a === void 0 ? void 0 : _a.nativeWindow) === null || _b === void 0 ? void 0 : _b.history) === null || _c === void 0 ? void 0 : _c.state) === null || _d === void 0 ? void 0 : _d.activeTab) !== null && _e !== void 0 ? _e : this.activeTabNum;
        };
        TabParagraphContainerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // If the sub cms components data exist, the components created before ngAfterViewInit are called.
            // In this case, the title parameters are directly pulled from them.
            // If the sub cms components data does not exist, it should should be loaded first.
            // In this case, listen to the changes to wait for them to be created.
            if (this.children.length > 0) {
                this.getTitleParams(this.children);
            }
            else {
                this.subscription = this.children.changes.subscribe(function (tabComps) { return _this.getTitleParams(tabComps); });
            }
        };
        TabParagraphContainerComponent.prototype.getTitleParams = function (children) {
            var _this = this;
            children.forEach(function (comp) {
                if (comp.cmpRef && comp.cmpRef.instance.tabTitleParam$) {
                    _this.tabTitleParams.push(comp.cmpRef.instance.tabTitleParam$);
                }
                else {
                    _this.tabTitleParams.push(null);
                }
            });
        };
        TabParagraphContainerComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return TabParagraphContainerComponent;
    }());
    TabParagraphContainerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-tab-paragraph-container',
                    template: "<ng-container *ngFor=\"let component of components$ | async; let i = index\">\n  <ng-container *ngIf=\"component\">\n    <button [class.active]=\"i === activeTabNum\" (click)=\"select(i, $event)\">\n      {{ component.title | cxTranslate: { param: tabTitleParams[i] | async } }}\n    </button>\n    <div [class.active]=\"i === activeTabNum\">\n      <ng-template [cxOutlet]=\"component.flexType\" [cxOutletContext]=\"{}\">\n        <ng-container [cxComponentWrapper]=\"component\"></ng-container>\n      </ng-template>\n    </div>\n  </ng-container>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    TabParagraphContainerComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: i1.CmsService },
        { type: i1.WindowRef },
        { type: BreakpointService }
    ]; };
    TabParagraphContainerComponent.propDecorators = {
        children: [{ type: i0.ViewChildren, args: [ComponentWrapperDirective,] }]
    };

    var TabParagraphContainerModule = /** @class */ (function () {
        function TabParagraphContainerModule() {
        }
        return TabParagraphContainerModule;
    }());
    TabParagraphContainerModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, PageComponentModule, OutletModule, i1.I18nModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CMSTabParagraphContainer: {
                                    component: TabParagraphContainerComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [TabParagraphContainerComponent],
                    entryComponents: [TabParagraphContainerComponent],
                    exports: [TabParagraphContainerComponent],
                },] }
    ];

    var AddressBookComponentService = /** @class */ (function () {
        function AddressBookComponentService(userAddressService, checkoutDeliveryService) {
            this.userAddressService = userAddressService;
            this.checkoutDeliveryService = checkoutDeliveryService;
        }
        AddressBookComponentService.prototype.getAddresses = function () {
            return this.userAddressService.getAddresses();
        };
        AddressBookComponentService.prototype.getAddressesStateLoading = function () {
            return this.userAddressService.getAddressesLoading();
        };
        AddressBookComponentService.prototype.loadAddresses = function () {
            this.userAddressService.loadAddresses();
        };
        AddressBookComponentService.prototype.addUserAddress = function (address) {
            this.userAddressService.addUserAddress(address);
        };
        AddressBookComponentService.prototype.updateUserAddress = function (addressId, address) {
            this.userAddressService.updateUserAddress(addressId, address);
            this.checkoutDeliveryService.clearCheckoutDeliveryDetails();
        };
        return AddressBookComponentService;
    }());
    AddressBookComponentService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AddressBookComponentService_Factory() { return new AddressBookComponentService(i0.ɵɵinject(i1.UserAddressService), i0.ɵɵinject(i1.CheckoutDeliveryService)); }, token: AddressBookComponentService, providedIn: "root" });
    AddressBookComponentService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AddressBookComponentService.ctorParameters = function () { return [
        { type: i1.UserAddressService },
        { type: i1.CheckoutDeliveryService }
    ]; };

    var AddressBookComponent = /** @class */ (function () {
        function AddressBookComponent(service, translation, userAddressService, checkoutDeliveryService) {
            this.service = service;
            this.translation = translation;
            this.userAddressService = userAddressService;
            this.checkoutDeliveryService = checkoutDeliveryService;
            this.showAddAddressForm = false;
            this.showEditAddressForm = false;
        }
        AddressBookComponent.prototype.ngOnInit = function () {
            this.addresses$ = this.service.getAddresses();
            this.addressesStateLoading$ = this.service.getAddressesStateLoading();
            this.service.loadAddresses();
        };
        AddressBookComponent.prototype.addAddressButtonHandle = function () {
            this.showEditAddressForm = false;
            this.showAddAddressForm = true;
        };
        AddressBookComponent.prototype.editAddressButtonHandle = function (address) {
            this.showAddAddressForm = false;
            this.showEditAddressForm = true;
            this.currentAddress = address;
        };
        AddressBookComponent.prototype.addAddressSubmit = function (address) {
            this.showAddAddressForm = false;
            this.service.addUserAddress(address);
        };
        AddressBookComponent.prototype.addAddressCancel = function () {
            this.showAddAddressForm = false;
        };
        AddressBookComponent.prototype.editAddressSubmit = function (address) {
            this.showEditAddressForm = false;
            this.service.updateUserAddress(this.currentAddress['id'], address);
        };
        AddressBookComponent.prototype.editAddressCancel = function () {
            this.showEditAddressForm = false;
        };
        AddressBookComponent.prototype.getCardContent = function (address) {
            return rxjs.combineLatest([
                this.translation.translate('addressCard.default'),
                this.translation.translate('addressCard.setAsDefault'),
                this.translation.translate('common.delete'),
                this.translation.translate('common.edit'),
                this.translation.translate('addressBook.areYouSureToDeleteAddress'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 5), defaultText = _b[0], setAsDefaultText = _b[1], textDelete = _b[2], textEdit = _b[3], textVerifyDeleteMsg = _b[4];
                var region = '';
                if (address.region && address.region.isocode) {
                    region = address.region.isocode + ', ';
                }
                var actions = [];
                if (!address.defaultAddress) {
                    actions.push({ name: setAsDefaultText, event: 'default' });
                }
                actions.push({ name: textEdit, event: 'edit' });
                actions.push({ name: textDelete, event: 'delete' });
                return {
                    textBold: address.firstName + ' ' + address.lastName,
                    text: [
                        address.line1,
                        address.line2,
                        address.town + ', ' + region + address.country.isocode,
                        address.postalCode,
                        address.phone,
                    ],
                    actions: actions,
                    header: address.defaultAddress ? "\u2713 " + defaultText : '',
                    deleteMsg: textVerifyDeleteMsg,
                };
            }));
        };
        AddressBookComponent.prototype.setAddressAsDefault = function (addressId) {
            this.userAddressService.setAddressAsDefault(addressId);
            this.checkoutDeliveryService.clearCheckoutDeliveryDetails();
        };
        AddressBookComponent.prototype.deleteAddress = function (addressId) {
            this.userAddressService.deleteUserAddress(addressId);
            this.checkoutDeliveryService.clearCheckoutDeliveryDetails();
        };
        AddressBookComponent.prototype.setEdit = function (addressId) {
            if (this.editCard !== addressId) {
                this.editCard = addressId;
            }
            else {
                this.deleteAddress(addressId);
            }
        };
        AddressBookComponent.prototype.cancelCard = function () {
            this.editCard = null;
        };
        return AddressBookComponent;
    }());
    AddressBookComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-address-book',
                    template: "<div class=\"cx-section\">\n  <ng-container\n    *ngIf=\"\n      (addresses$ | async).length &&\n      !(showAddAddressForm || showEditAddressForm)\n    \"\n  >\n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <button\n          class=\"btn btn-block btn-action\"\n          (click)=\"addAddressButtonHandle()\"\n        >\n          {{ 'addressBook.addNewAddress' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n\n    <div\n      class=\"row cx-address-deck\"\n      *ngIf=\"!(addressesStateLoading$ | async); else loading\"\n    >\n      <div\n        *ngFor=\"let address of addresses$ | async\"\n        class=\"col-md-6 cx-address-card\"\n      >\n        <cx-card\n          [border]=\"true\"\n          [fitToContainer]=\"true\"\n          [content]=\"getCardContent(address) | async\"\n          (editCard)=\"editAddressButtonHandle(address)\"\n          (setDefaultCard)=\"setAddressAsDefault(address.id)\"\n          (deleteCard)=\"setEdit(address.id)\"\n          [editMode]=\"address.id === editCard\"\n          (cancelCard)=\"cancelCard()\"\n        ></cx-card>\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"!(addresses$ | async).length || showAddAddressForm\">\n    <section>\n      <p class=\"cx-section-msg\">\n        {{ 'addressBook.addNewShippingAddress' | cxTranslate }}\n      </p>\n      <cx-address-form\n        class=\"cx-form\"\n        showTitleCode=\"true\"\n        [showCancelBtn]=\"!((addresses$ | async).length === 0)\"\n        actionBtnLabel=\"{{ 'addressBook.addAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [setAsDefaultField]=\"!((addresses$ | async).length === 0)\"\n        (submitAddress)=\"addAddressSubmit($event)\"\n        (backToAddress)=\"addAddressCancel()\"\n        (cancelCard)=\"cancelCard()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n\n  <ng-container *ngIf=\"showEditAddressForm\">\n    <section>\n      <p class=\"cx-section-msg\">\n        {{ 'addressBook.editShippingAddress' | cxTranslate }}\n      </p>\n      <cx-address-form\n        showTitleCode=\"true\"\n        actionBtnLabel=\"{{ 'addressBook.updateAddress' | cxTranslate }}\"\n        cancelBtnLabel=\"{{ 'addressBook.backToAddressList' | cxTranslate }}\"\n        [addressData]=\"currentAddress\"\n        (submitAddress)=\"editAddressSubmit($event)\"\n        (backToAddress)=\"editAddressCancel()\"\n      ></cx-address-form>\n    </section>\n  </ng-container>\n</div>\n\n<ng-template #loading>\n  <div class=\"col-md-12 cx-address-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n"
                },] }
    ];
    AddressBookComponent.ctorParameters = function () { return [
        { type: AddressBookComponentService },
        { type: i1.TranslationService },
        { type: i1.UserAddressService },
        { type: i1.CheckoutDeliveryService }
    ]; };

    var AddressBookModule = /** @class */ (function () {
        function AddressBookModule() {
        }
        return AddressBookModule;
    }());
    AddressBookModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        CardModule,
                        AddressFormModule,
                        SpinnerModule,
                        i1.I18nModule,
                    ],
                    declarations: [AddressBookComponent],
                    exports: [AddressBookComponent],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                AccountAddressBookComponent: {
                                    component: AddressBookComponent,
                                    providers: [
                                        {
                                            provide: AddressBookComponentService,
                                            useClass: AddressBookComponentService,
                                            deps: [i1.UserAddressService],
                                        },
                                    ],
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                        i1.UserAddressService,
                    ],
                    entryComponents: [AddressBookComponent],
                },] }
    ];

    var CloseAccountModalComponent = /** @class */ (function () {
        function CloseAccountModalComponent(modalService, userService, authService, globalMessageService, routingService, translationService) {
            this.modalService = modalService;
            this.userService = userService;
            this.authService = authService;
            this.globalMessageService = globalMessageService;
            this.routingService = routingService;
            this.translationService = translationService;
            this.iconTypes = exports.ICON_TYPE;
            this.subscription = new rxjs.Subscription();
        }
        CloseAccountModalComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.userToken$ = this.authService.getUserToken();
            this.userService.resetRemoveUserProcessState();
            this.subscription.add(this.userService
                .getRemoveUserResultSuccess()
                .subscribe(function (success) { return _this.onSuccess(success); }));
            this.subscription.add(this.userService
                .getRemoveUserResultError()
                .subscribe(function (error) { return _this.onError(error); }));
            this.isLoading$ = this.userService.getRemoveUserResultLoading();
        };
        CloseAccountModalComponent.prototype.onSuccess = function (success) {
            var _this = this;
            if (success) {
                this.dismissModal();
                this.translationService
                    .translate('closeAccount.accountClosedSuccessfully')
                    .pipe(operators.first())
                    .subscribe(function (text) {
                    _this.globalMessageService.add(text, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                });
                this.routingService.go({ cxRoute: 'home' });
            }
        };
        CloseAccountModalComponent.prototype.onError = function (error) {
            var _this = this;
            if (error) {
                this.dismissModal();
                this.translationService
                    .translate('closeAccount.accountClosedFailure')
                    .pipe(operators.first())
                    .subscribe(function (text) {
                    _this.globalMessageService.add(text, i1.GlobalMessageType.MSG_TYPE_ERROR);
                });
            }
        };
        CloseAccountModalComponent.prototype.dismissModal = function (reason) {
            this.modalService.dismissActiveModal(reason);
        };
        CloseAccountModalComponent.prototype.closeAccount = function () {
            this.userService.remove();
        };
        CloseAccountModalComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return CloseAccountModalComponent;
    }());
    CloseAccountModalComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-close-account-modal',
                    template: "<ng-container *ngIf=\"userToken$ | async as userToken\">\n  <div class=\"modal-header cx-dialog-header\">\n    <h3 class=\"modal-title\">\n      {{ 'closeAccount.confirmAccountClosure' | cxTranslate }}\n    </h3>\n    <button\n      type=\"button\"\n      class=\"close\"\n      aria-label=\"Close\"\n      (click)=\"dismissModal()\"\n    >\n      <span aria-hidden=\"true\">\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </span>\n    </button>\n  </div>\n\n  <div *ngIf=\"isLoading$ | async; else loaded\">\n    <div class=\"cx-spinner\">\n      <cx-spinner> </cx-spinner>\n    </div>\n  </div>\n\n  <ng-template #loaded>\n    <div class=\"modal-body\">\n      <div class=\"cx-row\">\n        <p class=\"cx-confirmation\">\n          {{ 'closeAccount.confirmAccountClosureMessage' | cxTranslate }}\n        </p>\n      </div>\n      <div class=\"cx-row\">\n        <div class=\"cx-btn-group\">\n          <button class=\"btn btn-primary\" (click)=\"closeAccount()\">\n            {{ 'closeAccount.closeMyAccount' | cxTranslate }}\n          </button>\n          <button (click)=\"dismissModal()\" class=\"btn btn-block btn-secondary\">\n            {{ 'common.cancel' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CloseAccountModalComponent.ctorParameters = function () { return [
        { type: ModalService },
        { type: i1.UserService },
        { type: i1.AuthService },
        { type: i1.GlobalMessageService },
        { type: i1.RoutingService },
        { type: i1.TranslationService }
    ]; };

    var CloseAccountComponent = /** @class */ (function () {
        function CloseAccountComponent(modalService) {
            this.modalService = modalService;
        }
        CloseAccountComponent.prototype.openModal = function () {
            this.modal = this.modalService.open(CloseAccountModalComponent, {
                centered: true,
            }).componentInstance;
        };
        return CloseAccountComponent;
    }());
    CloseAccountComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-close-account',
                    template: "<div class=\"col-lg-8 col-md-9\">\n  <div class=\"row cx-btn-group\">\n    <div class=\"col-sm-3\">\n      <a\n        [routerLink]=\"{ cxRoute: 'home' } | cxUrl\"\n        class=\"btn btn-block btn-secondary\"\n        >{{ 'common.cancel' | cxTranslate }}</a\n      >\n    </div>\n    <div class=\"col-sm-6\">\n      <button class=\"btn btn-primary\" (click)=\"openModal()\">\n        {{ 'closeAccount.closeMyAccount' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CloseAccountComponent.ctorParameters = function () { return [
        { type: ModalService }
    ]; };

    var CloseAccountModule = /** @class */ (function () {
        function CloseAccountModule() {
        }
        return CloseAccountModule;
    }());
    CloseAccountModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        IconModule,
                        SpinnerModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CloseAccountComponent: {
                                    component: CloseAccountComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CloseAccountComponent, CloseAccountModalComponent],
                    exports: [CloseAccountComponent, CloseAccountModalComponent],
                    entryComponents: [CloseAccountComponent, CloseAccountModalComponent],
                },] }
    ];

    var ForgotPasswordComponent = /** @class */ (function () {
        function ForgotPasswordComponent(fb, userService, routingService) {
            this.fb = fb;
            this.userService = userService;
            this.routingService = routingService;
        }
        ForgotPasswordComponent.prototype.ngOnInit = function () {
            this.forgotPasswordForm = this.fb.group({
                userEmail: [
                    '',
                    [forms.Validators.required, CustomFormValidators.emailValidator],
                ],
            });
        };
        ForgotPasswordComponent.prototype.requestForgotPasswordEmail = function () {
            if (this.forgotPasswordForm.valid) {
                this.userService.requestForgotPasswordEmail(this.forgotPasswordForm.value.userEmail);
                this.routingService.go({ cxRoute: 'login' });
            }
            else {
                this.forgotPasswordForm.markAllAsTouched();
            }
        };
        return ForgotPasswordComponent;
    }());
    ForgotPasswordComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-forgot-password',
                    template: "<form\n  (ngSubmit)=\"requestForgotPasswordEmail()\"\n  [formGroup]=\"forgotPasswordForm\"\n>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'forgottenPassword.emailAddress.label' | cxTranslate\n      }}</span>\n      <input\n        type=\"email\"\n        class=\"form-control\"\n        placeholder=\"{{\n          'forgottenPassword.emailAddress.placeholder' | cxTranslate\n        }}\"\n        formControlName=\"userEmail\"\n      />\n      <cx-form-errors\n        [control]=\"forgotPasswordForm.get('userEmail')\"\n      ></cx-form-errors>\n    </label>\n  </div>\n\n  <button type=\"submit\" class=\"btn btn-block btn-primary\">\n    {{ 'common.submit' | cxTranslate }}\n  </button>\n  <a\n    class=\"btn btn-block btn-secondary\"\n    [routerLink]=\"{ cxRoute: 'login' } | cxUrl\"\n    >{{ 'common.cancel' | cxTranslate }}</a\n  >\n</form>\n"
                },] }
    ];
    ForgotPasswordComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder },
        { type: i1.UserService },
        { type: i1.RoutingService }
    ]; };

    var ForgotPasswordModule = /** @class */ (function () {
        function ForgotPasswordModule() {
        }
        return ForgotPasswordModule;
    }());
    ForgotPasswordModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ForgotPasswordComponent: {
                                    component: ForgotPasswordComponent,
                                    guards: [i1.NotAuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ForgotPasswordComponent],
                    exports: [ForgotPasswordComponent],
                    entryComponents: [ForgotPasswordComponent],
                },] }
    ];

    var AmendOrderActionsComponent = /** @class */ (function () {
        function AmendOrderActionsComponent(routingService) {
            this.routingService = routingService;
            this.styles = 'row';
        }
        AmendOrderActionsComponent.prototype.continue = function (event) {
            if (this.amendOrderForm.valid) {
                this.routingService.go({
                    cxRoute: this.forwardRoute,
                    params: { code: this.orderCode },
                });
            }
            else {
                this.amendOrderForm.markAllAsTouched();
                event.stopPropagation();
            }
        };
        return AmendOrderActionsComponent;
    }());
    AmendOrderActionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-amend-order-actions',
                    template: "<div class=\"col-xs-12 col-md-4 col-lg-3\">\n  <a\n    [routerLink]=\"\n      {\n        cxRoute: backRoute,\n        params: { code: orderCode }\n      } | cxUrl\n    \"\n    class=\"btn btn-block btn-action\"\n  >\n    {{ 'common.back' | cxTranslate }}\n  </a>\n</div>\n<div class=\"col-xs-12 col-md-4 col-lg-3\">\n  <button\n    *ngIf=\"forwardRoute\"\n    class=\"btn btn-block btn-primary\"\n    (click)=\"continue($event)\"\n  >\n    {{ 'common.continue' | cxTranslate }}\n  </button>\n\n  <button *ngIf=\"!forwardRoute\" class=\"btn btn-block btn-primary\" type=\"submit\">\n    {{ 'orderDetails.cancellationAndReturn.submit' | cxTranslate }}\n  </button>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    AmendOrderActionsComponent.ctorParameters = function () { return [
        { type: i1.RoutingService }
    ]; };
    AmendOrderActionsComponent.propDecorators = {
        orderCode: [{ type: i0.Input }],
        amendOrderForm: [{ type: i0.Input }],
        backRoute: [{ type: i0.Input }],
        forwardRoute: [{ type: i0.Input }],
        styles: [{ type: i0.HostBinding, args: ['class',] }]
    };

    var AmendOrderActionsModule = /** @class */ (function () {
        function AmendOrderActionsModule() {
        }
        return AmendOrderActionsModule;
    }());
    AmendOrderActionsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.UrlModule, i1.I18nModule],
                    declarations: [AmendOrderActionsComponent],
                    exports: [AmendOrderActionsComponent],
                },] }
    ];

    (function (AmendOrderType) {
        AmendOrderType[AmendOrderType["CANCEL"] = 0] = "CANCEL";
        AmendOrderType[AmendOrderType["RETURN"] = 1] = "RETURN";
    })(exports.AmendOrderType || (exports.AmendOrderType = {}));

    function ValidateQuantityToCancel(control) {
        if (!control.value) {
            return null;
        }
        var quantity = Object.values(control.value).reduce(function (acc, val) { return acc + val; }, 0);
        return quantity > 0 ? null : { cxNoSelectedItemToCancel: true };
    }
    var OrderAmendService = /** @class */ (function () {
        function OrderAmendService(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
        }
        /**
         * Returns entries with an amended quantity.
         */
        OrderAmendService.prototype.getAmendedEntries = function () {
            var _this = this;
            return this.getForm().pipe(operators.switchMap(function (form) {
                return _this.getEntries().pipe(operators.map(function (entries) { return entries.filter(function (entry) { return _this.getFormControl(form, entry).value > 0; }); }));
            }));
        };
        OrderAmendService.prototype.getOrder = function () {
            return this.orderDetailsService.getOrderDetails();
        };
        /**
         * returns the form with form data at runtime
         */
        OrderAmendService.prototype.getForm = function () {
            var _this = this;
            return this.getOrder().pipe(operators.tap(function (order) {
                if (!_this.form || _this.form.get('orderCode').value !== order.code) {
                    _this.buildForm(order);
                }
            }), operators.map(function () { return _this.form; }));
        };
        OrderAmendService.prototype.buildForm = function (order) {
            var _this = this;
            this.form = new forms.FormGroup({});
            this.form.addControl('orderCode', new forms.FormControl(order.code));
            var entryGroup = new forms.FormGroup({}, { validators: [ValidateQuantityToCancel] });
            this.form.addControl('entries', entryGroup);
            (order.entries || []).forEach(function (entry) {
                var key = entry.entryNumber.toString();
                entryGroup.addControl(key, new forms.FormControl(0, {
                    validators: [
                        forms.Validators.min(0),
                        forms.Validators.max(_this.getMaxAmendQuantity(entry)),
                    ],
                }));
            });
        };
        OrderAmendService.prototype.getFormControl = function (form, entry) {
            return form.get('entries').get(entry.entryNumber.toString());
        };
        /**
         * As discussed, this calculation is moved to SPA side.
         * The calculation and validation should be in backend facade layer.
         */
        OrderAmendService.prototype.getAmendedPrice = function (entry) {
            var amendedQuantity = this.getFormControl(this.form, entry).value;
            var amendedPrice = Object.assign({}, entry.basePrice);
            amendedPrice.value =
                Math.round(entry.basePrice.value * amendedQuantity * 100) / 100;
            amendedPrice.formattedValue = i1$1.formatCurrency(amendedPrice.value, 
            // TODO: user current language
            'en', i1$1.getCurrencySymbol(amendedPrice.currencyIso, 'narrow'), amendedPrice.currencyIso);
            return amendedPrice;
        };
        OrderAmendService.prototype.getMaxAmendQuantity = function (entry) {
            return ((this.isCancellation()
                ? entry.cancellableQuantity
                : entry.returnableQuantity) || entry.quantity);
        };
        OrderAmendService.prototype.isCancellation = function () {
            return this.amendType === exports.AmendOrderType.CANCEL;
        };
        return OrderAmendService;
    }());
    OrderAmendService.decorators = [
        { type: i0.Injectable }
    ];
    OrderAmendService.ctorParameters = function () { return [
        { type: OrderDetailsService }
    ]; };

    var CancelOrReturnItemsComponent = /** @class */ (function () {
        function CancelOrReturnItemsComponent(orderAmendService) {
            this.orderAmendService = orderAmendService;
            this.isConfirmation = false;
            this.form$ = this.orderAmendService.getForm();
        }
        CancelOrReturnItemsComponent.prototype.getControl = function (form, entry) {
            var control = (form.get('entries').get(entry.entryNumber.toString()));
            return control;
        };
        CancelOrReturnItemsComponent.prototype.setAll = function (form) {
            var _this = this;
            this.entries.forEach(function (entry) { return _this.getControl(form, entry).setValue(_this.getMaxAmendQuantity(entry)); });
        };
        CancelOrReturnItemsComponent.prototype.getItemPrice = function (entry) {
            return this.orderAmendService.getAmendedPrice(entry);
        };
        CancelOrReturnItemsComponent.prototype.getMaxAmendQuantity = function (entry) {
            return this.orderAmendService.getMaxAmendQuantity(entry);
        };
        CancelOrReturnItemsComponent.prototype.isCancellation = function () {
            return this.orderAmendService.isCancellation();
        };
        return CancelOrReturnItemsComponent;
    }());
    CancelOrReturnItemsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-amend-order-items',
                    template: "<div *ngIf=\"form$ | async as form\">\n  <button\n    *ngIf=\"!isConfirmation\"\n    class=\"btn btn-link cx-action-link\"\n    (click)=\"setAll(form)\"\n  >\n    {{ 'orderDetails.cancellationAndReturn.setAll' | cxTranslate }}\n  </button>\n\n  <div class=\"d-none d-md-block cx-item-list-header\">\n    <div class=\"row\">\n      <div class=\"text-left col-6\">\n        {{ 'orderDetails.cancellationAndReturn.item' | cxTranslate }}\n      </div>\n      <div class=\"text-center col-2\">\n        {{ 'orderDetails.cancellationAndReturn.itemPrice' | cxTranslate }}\n      </div>\n      <div *ngIf=\"!isConfirmation\" class=\"text-center col-2\">\n        {{ 'orderDetails.cancellationAndReturn.quantity' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-qty col-2 text-right\">\n        {{\n          (isCancellation()\n            ? 'orderDetails.cancellationAndReturn.cancelQty'\n            : 'orderDetails.cancellationAndReturn.returnQty'\n          ) | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"isConfirmation\" class=\"cx-item-list-total col-2\">\n        {{ 'orderDetails.cancellationAndReturn.totalPrice' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"cx-item-list-row\" *ngFor=\"let item of entries; let i = index\">\n    <div class=\"row cx-item-list-items\">\n      <!-- Item Image -->\n      <cx-media\n        class=\"col-2\"\n        [container]=\"item.product.images?.PRIMARY\"\n      ></cx-media>\n\n      <!-- Item Information -->\n      <div class=\"cx-info col-10\">\n        <div class=\"cx-info-container row\">\n          <!-- Item Description -->\n          <div class=\"col-md-4 col-xl-5 cx-list-item-desc\">\n            <div *ngIf=\"item.product.name\" class=\"cx-name\">\n              {{ item.product.name }}\n            </div>\n            <div *ngIf=\"item.product.code\" class=\"cx-code\">\n              {{ 'cartItems.id' | cxTranslate }} {{ item.product.code }}\n            </div>\n            <!-- Variants -->\n            <ng-container *ngIf=\"item.product.baseOptions?.length\">\n              <div\n                *ngFor=\"\n                  let variant of item.product.baseOptions[0]?.selected\n                    ?.variantOptionQualifiers\n                \"\n                class=\"cx-property\"\n              >\n                <div class=\"cx-label\" *ngIf=\"variant.name\">\n                  {{ variant.name }}:\n                </div>\n                <div class=\"cx-value\" *ngIf=\"variant.value\">\n                  {{ variant.value }}\n                </div>\n              </div>\n            </ng-container>\n          </div>\n          <!-- Price -->\n          <div\n            *ngIf=\"item.basePrice\"\n            class=\"cx-price col-md-3 col-lg-3 col-xl-2\"\n          >\n            <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n              {{ 'orderDetails.cancellationAndReturn.itemPrice' | cxTranslate }}\n            </div>\n            <div *ngIf=\"item.basePrice\" class=\"cx-value\">\n              {{ item.basePrice?.formattedValue }}\n            </div>\n          </div>\n          <!-- item Quantity -->\n          <div *ngIf=\"!isConfirmation\" class=\"cx-request-qty col-md-3\">\n            <div\n              class=\"cx-label d-block d-md-none d-lg-none d-xl-none\"\n              placement=\"left\"\n              title=\"{{ 'cartItems.quantityTitle' | cxTranslate }}\"\n            >\n              {{ 'orderDetails.cancellationAndReturn.quantity' | cxTranslate }}\n            </div>\n            <div class=\"cx-value\">\n              {{ getMaxAmendQuantity(item) }}\n            </div>\n          </div>\n          <!-- Amended Quantity -->\n          <div class=\"cx-quantity col-xs-12 col-md-2 col-sm-12\">\n            <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n              {{\n                (isCancellation()\n                  ? 'orderDetails.cancellationAndReturn.cancelQty'\n                  : 'orderDetails.cancellationAndReturn.returnQty'\n                ) | cxTranslate\n              }}\n            </div>\n\n            <div\n              *ngIf=\"isConfirmation\"\n              class=\"w-100 text-center cx-order-quantity-value\"\n            >\n              {{ getControl(form, item).value }}\n            </div>\n            <cx-item-counter\n              *ngIf=\"!isConfirmation\"\n              [min]=\"0\"\n              [max]=\"getMaxAmendQuantity(item)\"\n              [control]=\"getControl(form, item)\"\n            >\n            </cx-item-counter>\n          </div>\n          <!-- Total Price -->\n          <div *ngIf=\"isConfirmation\" class=\"cx-total col-3\">\n            <div class=\"cx-label d-block d-md-none\">\n              {{\n                'orderDetails.cancellationAndReturn.totalPrice' | cxTranslate\n              }}\n            </div>\n            <div class=\"cx-value\">\n              {{ getItemPrice(item)?.formattedValue }}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CancelOrReturnItemsComponent.ctorParameters = function () { return [
        { type: OrderAmendService }
    ]; };
    CancelOrReturnItemsComponent.propDecorators = {
        entries: [{ type: i0.Input }],
        isConfirmation: [{ type: i0.Input }]
    };

    var AmendOrderItemsModule = /** @class */ (function () {
        function AmendOrderItemsModule() {
        }
        return AmendOrderItemsModule;
    }());
    AmendOrderItemsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        i1.I18nModule,
                        MediaModule,
                        ItemCounterModule,
                        i1.FeaturesConfigModule,
                        FormErrorsModule,
                    ],
                    declarations: [CancelOrReturnItemsComponent],
                    exports: [CancelOrReturnItemsComponent],
                    entryComponents: [CancelOrReturnItemsComponent],
                },] }
    ];

    var CancelOrderConfirmationComponent = /** @class */ (function () {
        function CancelOrderConfirmationComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getAmendedEntries();
        }
        CancelOrderConfirmationComponent.prototype.submit = function (form) {
            if (form.valid) {
                this.orderAmendService.save();
            }
            else {
                form.markAllAsTouched();
            }
        };
        return CancelOrderConfirmationComponent;
    }());
    CancelOrderConfirmationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cancel-order-confirmation',
                    template: "<form\n  *ngIf=\"form$ | async as form\"\n  [formGroup]=\"form\"\n  (ngSubmit)=\"submit(form)\"\n>\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items\n    *ngIf=\"entries$ | async as entries\"\n    [entries]=\"entries\"\n    [isConfirmation]=\"true\"\n  >\n  </cx-amend-order-items>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderCancel\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</form>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CancelOrderConfirmationComponent.ctorParameters = function () { return [
        { type: OrderAmendService }
    ]; };

    var OrderCancellationService = /** @class */ (function (_super) {
        __extends(OrderCancellationService, _super);
        function OrderCancellationService(orderDetailsService, userOrderService, routing, globalMessageService) {
            var _this = _super.call(this, orderDetailsService) || this;
            _this.orderDetailsService = orderDetailsService;
            _this.userOrderService = userOrderService;
            _this.routing = routing;
            _this.globalMessageService = globalMessageService;
            _this.amendType = exports.AmendOrderType.CANCEL;
            return _this;
        }
        /**
         * Return cancellable order entries.
         */
        OrderCancellationService.prototype.getEntries = function () {
            return this.getOrder().pipe(operators.filter(function (order) { return !!(order === null || order === void 0 ? void 0 : order.entries); }), operators.map(function (order) { return order.entries.filter(function (entry) { return entry.entryNumber !== -1 && entry.cancellableQuantity > 0; }); }));
        };
        OrderCancellationService.prototype.save = function () {
            var _this = this;
            var orderCode = this.form.value.orderCode;
            var entries = this.form.value.entries;
            var inputs = Object.keys(entries)
                .filter(function (entryNumber) { return entries[entryNumber] > 0; })
                .map(function (entryNumber) { return ({
                orderEntryNumber: Number(entryNumber),
                quantity: entries[entryNumber],
            }); });
            this.form.reset();
            this.userOrderService.cancelOrder(orderCode, {
                cancellationRequestEntryInputs: inputs,
            });
            this.userOrderService
                .getCancelOrderSuccess()
                .pipe(operators.first(Boolean))
                .subscribe(function () { return _this.afterSave(orderCode); });
        };
        OrderCancellationService.prototype.afterSave = function (orderCode) {
            this.userOrderService.resetCancelOrderProcessState();
            this.globalMessageService.add({
                key: 'orderDetails.cancellationAndReturn.cancelSuccess',
                params: { orderCode: orderCode },
            }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            this.routing.go({
                cxRoute: 'orders',
            });
        };
        return OrderCancellationService;
    }(OrderAmendService));
    OrderCancellationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OrderCancellationService_Factory() { return new OrderCancellationService(i0.ɵɵinject(OrderDetailsService), i0.ɵɵinject(i1.UserOrderService), i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.GlobalMessageService)); }, token: OrderCancellationService, providedIn: "root" });
    OrderCancellationService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    OrderCancellationService.ctorParameters = function () { return [
        { type: OrderDetailsService },
        { type: i1.UserOrderService },
        { type: i1.RoutingService },
        { type: i1.GlobalMessageService }
    ]; };

    var OrderCancellationGuard = /** @class */ (function () {
        function OrderCancellationGuard(routing, orderAmendService) {
            this.routing = routing;
            this.orderAmendService = orderAmendService;
        }
        OrderCancellationGuard.prototype.canActivate = function () {
            var _this = this;
            return this.orderAmendService.getForm().pipe(operators.map(function (form) {
                if (!form.valid) {
                    // the order code is not available in the route
                    // as long as we're inside a guard, hence we redirect
                    // to the common orders page.
                    _this.routing.go({ cxRoute: 'orders' });
                    return false;
                }
                else {
                    return true;
                }
            }));
        };
        return OrderCancellationGuard;
    }());
    OrderCancellationGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function OrderCancellationGuard_Factory() { return new OrderCancellationGuard(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(OrderCancellationService)); }, token: OrderCancellationGuard, providedIn: "root" });
    OrderCancellationGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    OrderCancellationGuard.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: OrderCancellationService }
    ]; };

    var ɵ0$1 = {
        cxRoute: 'orderCancelConfirmation',
    };
    var CancelOrderConfirmationModule = /** @class */ (function () {
        function CancelOrderConfirmationModule() {
        }
        return CancelOrderConfirmationModule;
    }());
    CancelOrderConfirmationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$1,
                            },
                        ]),
                        forms.ReactiveFormsModule,
                        AmendOrderItemsModule,
                        AmendOrderActionsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CancelOrderConfirmationComponent: {
                                    component: CancelOrderConfirmationComponent,
                                    guards: [i1.AuthGuard, OrderCancellationGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderCancellationService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [CancelOrderConfirmationComponent],
                    exports: [CancelOrderConfirmationComponent],
                    entryComponents: [CancelOrderConfirmationComponent],
                },] }
    ];

    var CancelOrderComponent = /** @class */ (function () {
        function CancelOrderComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getEntries();
        }
        return CancelOrderComponent;
    }());
    CancelOrderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-cancel-order',
                    template: "<ng-container *ngIf=\"form$ | async as form\">\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items *ngIf=\"entries$ | async as entries\" [entries]=\"entries\">\n  </cx-amend-order-items>\n\n  <cx-form-errors [control]=\"form.get('entries')\"></cx-form-errors>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderDetails\"\n      forwardRoute=\"orderCancelConfirmation\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CancelOrderComponent.ctorParameters = function () { return [
        { type: OrderAmendService }
    ]; };

    var ɵ0$2 = {
        cxRoute: 'orderCancel',
    };
    var CancelOrderModule = /** @class */ (function () {
        function CancelOrderModule() {
        }
        return CancelOrderModule;
    }());
    CancelOrderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$2,
                            },
                        ]),
                        AmendOrderItemsModule,
                        AmendOrderActionsModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CancelOrderComponent: {
                                    component: CancelOrderComponent,
                                    guards: [i1.AuthGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderCancellationService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [CancelOrderComponent],
                    exports: [CancelOrderComponent],
                    entryComponents: [CancelOrderComponent],
                },] }
    ];

    var OrderCancellationModule = /** @class */ (function () {
        function OrderCancellationModule() {
        }
        return OrderCancellationModule;
    }());
    OrderCancellationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [CancelOrderModule, CancelOrderConfirmationModule],
                },] }
    ];

    var OrderReturnService = /** @class */ (function (_super) {
        __extends(OrderReturnService, _super);
        function OrderReturnService(orderDetailsService, returnRequestService, routing, globalMessageService) {
            var _this = _super.call(this, orderDetailsService) || this;
            _this.orderDetailsService = orderDetailsService;
            _this.returnRequestService = returnRequestService;
            _this.routing = routing;
            _this.globalMessageService = globalMessageService;
            _this.amendType = exports.AmendOrderType.RETURN;
            return _this;
        }
        OrderReturnService.prototype.getEntries = function () {
            return this.getOrder().pipe(operators.filter(function (order) { return !!order.entries; }), operators.map(function (order) { return order.entries.filter(function (entry) { return entry.entryNumber !== -1 && entry.returnableQuantity > 0; }); }));
        };
        OrderReturnService.prototype.save = function () {
            var _this = this;
            var orderCode = this.form.value.orderCode;
            var entries = this.form.value.entries;
            var inputs = Object.keys(entries)
                .filter(function (entryNumber) { return entries[entryNumber] > 0; })
                .map(function (entryNumber) { return ({
                orderEntryNumber: Number(entryNumber),
                quantity: entries[entryNumber],
            }); });
            this.form.reset();
            this.returnRequestService.createOrderReturnRequest({
                orderCode: orderCode,
                returnRequestEntryInputs: inputs,
            });
            this.returnRequestService
                .getReturnRequestSuccess()
                .pipe(operators.first(Boolean))
                .subscribe(function () { return _this.afterSave(); });
        };
        OrderReturnService.prototype.afterSave = function () {
            var _this = this;
            this.returnRequestService
                .getOrderReturnRequest()
                .pipe(operators.first(function (r) { return !!r; }))
                .subscribe(function (returnRequest) {
                var rma = returnRequest.rma;
                _this.globalMessageService.add({
                    key: 'orderDetails.cancellationAndReturn.returnSuccess',
                    params: { rma: rma },
                }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                _this.routing.go({
                    cxRoute: 'returnRequestDetails',
                    params: { rma: rma },
                });
            });
        };
        return OrderReturnService;
    }(OrderAmendService));
    OrderReturnService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OrderReturnService_Factory() { return new OrderReturnService(i0.ɵɵinject(OrderDetailsService), i0.ɵɵinject(i1.OrderReturnRequestService), i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.GlobalMessageService)); }, token: OrderReturnService, providedIn: "root" });
    OrderReturnService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    OrderReturnService.ctorParameters = function () { return [
        { type: OrderDetailsService },
        { type: i1.OrderReturnRequestService },
        { type: i1.RoutingService },
        { type: i1.GlobalMessageService }
    ]; };

    var OrderReturnGuard = /** @class */ (function () {
        function OrderReturnGuard(routing, orderAmendService) {
            this.routing = routing;
            this.orderAmendService = orderAmendService;
        }
        OrderReturnGuard.prototype.canActivate = function () {
            var _this = this;
            return this.orderAmendService.getForm().pipe(operators.map(function (form) {
                if (!form.valid) {
                    // the order code is not available in the route
                    // as long as we're inside a guard, hence we redirect
                    // to the common orders page.
                    _this.routing.go({ cxRoute: 'orders' });
                    return false;
                }
                else {
                    return true;
                }
            }));
        };
        return OrderReturnGuard;
    }());
    OrderReturnGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function OrderReturnGuard_Factory() { return new OrderReturnGuard(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(OrderReturnService)); }, token: OrderReturnGuard, providedIn: "root" });
    OrderReturnGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    OrderReturnGuard.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: OrderReturnService }
    ]; };

    var ReturnOrderConfirmationComponent = /** @class */ (function () {
        function ReturnOrderConfirmationComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getAmendedEntries();
        }
        ReturnOrderConfirmationComponent.prototype.submit = function (form) {
            form.disable();
            this.orderAmendService.save();
        };
        return ReturnOrderConfirmationComponent;
    }());
    ReturnOrderConfirmationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-return-order-confirmation',
                    template: "<form\n  *ngIf=\"form$ | async as form\"\n  [formGroup]=\"form\"\n  (ngSubmit)=\"submit(form)\"\n>\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items\n    *ngIf=\"entries$ | async as entries\"\n    [entries]=\"entries\"\n    [isConfirmation]=\"true\"\n  >\n  </cx-amend-order-items>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderReturn\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</form>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ReturnOrderConfirmationComponent.ctorParameters = function () { return [
        { type: OrderAmendService }
    ]; };

    var ɵ0$3 = {
        cxRoute: 'orderReturnConfirmation',
    };
    var ReturnOrderConfirmationModule = /** @class */ (function () {
        function ReturnOrderConfirmationModule() {
        }
        return ReturnOrderConfirmationModule;
    }());
    ReturnOrderConfirmationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$3,
                            },
                        ]),
                        AmendOrderItemsModule,
                        i1.I18nModule,
                        forms.ReactiveFormsModule,
                        AmendOrderActionsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ReturnOrderConfirmationComponent: {
                                    component: ReturnOrderConfirmationComponent,
                                    guards: [i1.AuthGuard, OrderReturnGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderReturnService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [ReturnOrderConfirmationComponent],
                    exports: [ReturnOrderConfirmationComponent],
                    entryComponents: [ReturnOrderConfirmationComponent],
                },] }
    ];

    var ReturnOrderComponent = /** @class */ (function () {
        function ReturnOrderComponent(orderAmendService) {
            var _this = this;
            this.orderAmendService = orderAmendService;
            this.form$ = this.orderAmendService
                .getForm()
                .pipe(operators.tap(function (form) { return (_this.orderCode = form.value.orderCode); }));
            this.entries$ = this.orderAmendService.getEntries();
        }
        return ReturnOrderComponent;
    }());
    ReturnOrderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-return-order',
                    template: "<ng-container *ngIf=\"form$ | async as form\">\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <cx-amend-order-items *ngIf=\"entries$ | async as entries\" [entries]=\"entries\">\n  </cx-amend-order-items>\n\n  <ng-container *ngTemplateOutlet=\"actions\"></ng-container>\n\n  <ng-template #actions>\n    <cx-amend-order-actions\n      *ngIf=\"orderCode\"\n      [orderCode]=\"orderCode\"\n      [amendOrderForm]=\"form\"\n      backRoute=\"orderDetails\"\n      forwardRoute=\"orderReturnConfirmation\"\n    ></cx-amend-order-actions>\n  </ng-template>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ReturnOrderComponent.ctorParameters = function () { return [
        { type: OrderAmendService }
    ]; };

    var ɵ0$4 = {
        cxRoute: 'orderReturn',
    };
    var ReturnOrderModule = /** @class */ (function () {
        function ReturnOrderModule() {
        }
        return ReturnOrderModule;
    }());
    ReturnOrderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$4,
                            },
                        ]),
                        AmendOrderItemsModule,
                        AmendOrderActionsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ReturnOrderComponent: {
                                    component: ReturnOrderComponent,
                                    guards: [i1.AuthGuard],
                                    providers: [
                                        {
                                            provide: OrderAmendService,
                                            useExisting: OrderReturnService,
                                        },
                                    ],
                                },
                            },
                        }),
                    ],
                    declarations: [ReturnOrderComponent],
                    exports: [ReturnOrderComponent],
                    entryComponents: [ReturnOrderComponent],
                },] }
    ];

    var OrderReturnModule = /** @class */ (function () {
        function OrderReturnModule() {
        }
        return OrderReturnModule;
    }());
    OrderReturnModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [ReturnOrderModule, ReturnOrderConfirmationModule],
                },] }
    ];

    var OrderDetailActionsComponent = /** @class */ (function () {
        function OrderDetailActionsComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
            this.order$ = this.orderDetailsService.getOrderDetails();
        }
        return OrderDetailActionsComponent;
    }());
    OrderDetailActionsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-details-actions',
                    template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"cx-nav row\">\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button\n        [routerLink]=\"{ cxRoute: 'orders' } | cxUrl\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </div>\n\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <a\n        *ngIf=\"order.cancellable\"\n        [routerLink]=\"\n          {\n            cxRoute: 'orderCancel',\n            params: order\n          } | cxUrl\n        \"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'orderDetails.cancellationAndReturn.cancelAction' | cxTranslate }}\n      </a>\n\n      <a\n        *ngIf=\"order.returnable\"\n        [routerLink]=\"\n          {\n            cxRoute: 'orderReturn',\n            params: order\n          } | cxUrl\n        \"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'orderDetails.cancellationAndReturn.returnAction' | cxTranslate }}\n      </a>\n    </div>\n  </div>\n</ng-container>\n"
                },] }
    ];
    OrderDetailActionsComponent.ctorParameters = function () { return [
        { type: OrderDetailsService }
    ]; };

    var OrderDetailApprovalDetailsComponent = /** @class */ (function () {
        function OrderDetailApprovalDetailsComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
            this.order$ = this.orderDetailsService.getOrderDetails();
        }
        return OrderDetailApprovalDetailsComponent;
    }());
    OrderDetailApprovalDetailsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-details-approval-details',
                    template: "<ng-container *ngIf=\"order$ | async as order\">\n  <ng-container *ngIf=\"order.permissionResults?.length\">\n    <div class=\"cx-approval-header row\">\n      <div class=\"cx-approval-label col-sm-12\">\n        {{ 'orderDetails.approvalDetails.header' | cxTranslate }}\n      </div>\n    </div>\n    <div class=\"row\">\n      <table class=\"table table-striped cx-approval-table\">\n        <thead class=\"cx-approval-thead-mobile\">\n          <th scope=\"col\">\n            {{ 'orderDetails.approvalDetails.permission' | cxTranslate }}\n          </th>\n          <th scope=\"col\">\n            {{ 'orderDetails.approvalDetails.approver' | cxTranslate }}\n          </th>\n          <th scope=\"col\">\n            {{ 'orderDetails.approvalDetails.status' | cxTranslate }}\n          </th>\n          <th scope=\"col\">\n            {{ 'orderDetails.approvalDetails.approverComments' | cxTranslate }}\n          </th>\n        </thead>\n        <tbody>\n          <tr *ngFor=\"let permissionResult of order.permissionResults\">\n            <td class=\"cx-approval-permissionCode\">\n              <div class=\"d-md-none cx-approval-table-label\">\n                {{ 'orderDetails.approvalDetails.permission' | cxTranslate }}\n              </div>\n              {{\n                'orderDetails.approvalDetails.permissionType'\n                  | cxTranslate\n                    : { context: permissionResult.permissionType.code }\n              }}\n            </td>\n            <td class=\"cx-approval-approverName\">\n              <div class=\"d-md-none cx-approval-table-label\">\n                {{ 'orderDetails.approvalDetails.approver' | cxTranslate }}\n              </div>\n              {{ permissionResult.approverName }}\n            </td>\n            <td class=\"cx-approval-statusDisplay\">\n              <div class=\"d-md-none cx-approval-table-label\">\n                {{ 'orderDetails.approvalDetails.status' | cxTranslate }}\n              </div>\n              {{ permissionResult.statusDisplay }}\n            </td>\n            <td class=\"cx-approval-approvalNotes\">\n              <div class=\"d-md-none cx-approval-table-label\">\n                {{\n                  'orderDetails.approvalDetails.approverComments' | cxTranslate\n                }}\n              </div>\n              {{\n                permissionResult.approverNotes\n                  ? permissionResult.approverNotes\n                  : ('orderDetails.approvalDetails.noApprovalNotes'\n                    | cxTranslate)\n              }}\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </ng-container>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderDetailApprovalDetailsComponent.ctorParameters = function () { return [
        { type: OrderDetailsService }
    ]; };

    var completedValues = ['DELIVERY_COMPLETED', 'PICKUP_COMPLETE'];
    var cancelledValues = ['CANCELLED'];

    var OrderDetailItemsComponent = /** @class */ (function () {
        function OrderDetailItemsComponent(orderDetailsService, promotionService) {
            this.orderDetailsService = orderDetailsService;
            this.promotionService = promotionService;
            this.promotionLocation = i1.PromotionLocation.Order;
            this.order$ = this.orderDetailsService.getOrderDetails();
        }
        OrderDetailItemsComponent.prototype.ngOnInit = function () {
            this.orderPromotions$ = this.promotionService.getOrderPromotions(this.promotionLocation);
            this.others$ = this.getOtherStatus.apply(this, __spread(completedValues, cancelledValues));
            this.completed$ = this.getExactStatus(completedValues);
            this.cancel$ = this.getExactStatus(cancelledValues);
        };
        OrderDetailItemsComponent.prototype.getExactStatus = function (consignmentStatus) {
            return this.order$.pipe(operators.map(function (order) {
                if (Boolean(order.consignments)) {
                    return order.consignments.filter(function (consignment) { return consignmentStatus.includes(consignment.status); });
                }
            }));
        };
        OrderDetailItemsComponent.prototype.getOtherStatus = function () {
            var consignmentStatus = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                consignmentStatus[_i] = arguments[_i];
            }
            return this.order$.pipe(operators.map(function (order) {
                if (Boolean(order.consignments)) {
                    return order.consignments.filter(function (consignment) { return !consignmentStatus.includes(consignment.status); });
                }
            }));
        };
        return OrderDetailItemsComponent;
    }());
    OrderDetailItemsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-details-items',
                    template: "<ng-container *ngIf=\"order$ | async as order\">\n  <ng-container\n    *ngIf=\"order.consignments?.length || order.unconsignedEntries?.length\"\n  >\n    <ng-container *ngIf=\"orderPromotions$ | async as orderPromotions\">\n      <cx-promotions [promotions]=\"orderPromotions\"></cx-promotions>\n    </ng-container>\n  </ng-container>\n\n  <!-- consigned entries -->\n  <ng-container *ngIf=\"order.consignments?.length\">\n    <cx-order-consigned-entries\n      *ngIf=\"others$ | async as others\"\n      [order]=\"order\"\n      [consignments]=\"others\"\n    ></cx-order-consigned-entries>\n\n    <cx-order-consigned-entries\n      *ngIf=\"completed$ | async as completed\"\n      [order]=\"order\"\n      [consignments]=\"completed\"\n    ></cx-order-consigned-entries>\n\n    <cx-order-consigned-entries\n      *ngIf=\"cancel$ | async as cancel\"\n      [order]=\"order\"\n      [consignments]=\"cancel\"\n    ></cx-order-consigned-entries>\n  </ng-container>\n\n  <!-- unconsigned entries OR any entries -->\n  <ng-container\n    *ngIf=\"\n      order?.unconsignedEntries?.length ||\n      (order?.entries && order?.replenishmentOrderCode)\n    \"\n  >\n    <div class=\"cx-list row\">\n      <div *ngIf=\"order?.statusDisplay\" class=\"cx-list-header col-12\">\n        <div class=\"cx-list-status\">\n          {{\n            'orderDetails.statusDisplay_' + order?.statusDisplay | cxTranslate\n          }}\n        </div>\n      </div>\n      <div class=\"cx-list-item col-12\">\n        <cx-cart-item-list\n          [items]=\"\n            order?.unconsignedEntries ? order.unconsignedEntries : order.entries\n          \"\n          [readonly]=\"true\"\n          [promotionLocation]=\"promotionLocation\"\n        ></cx-cart-item-list>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n"
                },] }
    ];
    OrderDetailItemsComponent.ctorParameters = function () { return [
        { type: OrderDetailsService },
        { type: PromotionService }
    ]; };

    var TrackingEventsComponent = /** @class */ (function () {
        function TrackingEventsComponent(activeModal, userOrderService) {
            this.activeModal = activeModal;
            this.userOrderService = userOrderService;
        }
        TrackingEventsComponent.prototype.ngOnDestroy = function () {
            this.userOrderService.clearConsignmentTracking();
        };
        return TrackingEventsComponent;
    }());
    TrackingEventsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-tracking-events',
                    template: "<div class=\"cx-consignment-tracking-dialog\">\n  <!-- Modal Header -->\n  <ng-container *ngIf=\"tracking$ | async as consignmentTracking; else loading\">\n    <div class=\"header modal-header\">\n      <div class=\"title modal-title\">\n        {{ 'orderDetails.consignmentTracking.dialog.header' | cxTranslate }}\n      </div>\n      <button\n        type=\"button\"\n        class=\"close\"\n        aria-label=\"Close\"\n        (click)=\"activeModal.dismiss('Cross click')\"\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n    <!-- Modal Body -->\n    <!-- shipment header -->\n    <ng-container\n      *ngIf=\"\n        consignmentTracking?.carrierDetails && consignmentTracking?.trackingID;\n        else noTracking\n      \"\n    >\n      <div class=\"shipment-heading\">\n        <div class=\"row\">\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.shipped' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ shipDate | cxDate: 'medium' }}\n            </div>\n          </div>\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.estimate' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ consignmentTracking?.targetArrivalDate | cxDate: 'medium' }}\n            </div>\n          </div>\n        </div>\n\n        <div class=\"row\">\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.carrier' | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              {{ consignmentTracking?.carrierDetails?.name }}\n            </div>\n          </div>\n          <div class=\"col-sm-12 col-md-6\">\n            <div class=\"shipment-title\">\n              {{\n                'orderDetails.consignmentTracking.dialog.trackingId'\n                  | cxTranslate\n              }}\n            </div>\n            <div class=\"shipment-content\">\n              <ng-container *ngIf=\"consignmentTracking?.trackingUrl\">\n                <a target=\"_blank\" [href]=\"consignmentTracking.trackingUrl\">{{\n                  consignmentTracking?.trackingID\n                }}</a>\n              </ng-container>\n              <ng-container *ngIf=\"!consignmentTracking?.trackingUrl\">\n                <label>\n                  {{ consignmentTracking?.trackingID }}\n                </label>\n              </ng-container>\n            </div>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n\n    <!-- tracking events -->\n    <div class=\"events modal-body\">\n      <ng-container\n        *ngFor=\"let consignmentEvent of consignmentTracking.trackingEvents\"\n      >\n        <div class=\"event-body\">\n          <div class=\"event-content\">\n            {{ consignmentEvent.eventDate | cxDate: 'medium' }}\n          </div>\n          <div class=\"event-title\">\n            {{ consignmentEvent.referenceCode }}\n          </div>\n          <div class=\"event-content\">{{ consignmentEvent.detail }}</div>\n          <div class=\"event-city\">\n            location: {{ consignmentEvent.location }}\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </ng-container>\n\n  <ng-template #noTracking>\n    <div class=\"no-tracking-heading\">\n      <div class=\"shipment-content\">\n        {{ 'orderDetails.consignmentTracking.dialog.noTracking' | cxTranslate }}\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template #loading>\n    <div class=\"tracking-loading\">\n      <div class=\"header modal-header\">\n        <div class=\"title modal-title\">\n          {{\n            'orderDetails.consignmentTracking.dialog.loadingHeader'\n              | cxTranslate\n          }}\n        </div>\n        <button\n          type=\"button\"\n          class=\"close btn-dismiss\"\n          aria-label=\"Close\"\n          (click)=\"activeModal.dismiss('Cross click')\"\n        >\n          <span aria-hidden=\"true\">&times;</span>\n        </button>\n      </div>\n      <!-- Modal Body -->\n      <div class=\"body modal-body\">\n        <div class=\"row\">\n          <div class=\"col-sm-12\">\n            <cx-spinner></cx-spinner>\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n</div>\n"
                },] }
    ];
    TrackingEventsComponent.ctorParameters = function () { return [
        { type: i1$3.NgbActiveModal },
        { type: i1.UserOrderService }
    ]; };

    var ConsignmentTrackingComponent = /** @class */ (function () {
        function ConsignmentTrackingComponent(userOrderService, modalService) {
            this.userOrderService = userOrderService;
            this.modalService = modalService;
            this.consignmentStatus = [
                'SHIPPED',
                'IN_TRANSIT',
                'DELIVERY_COMPLETED',
                'DELIVERY_REJECTED',
                'DELIVERING',
            ];
        }
        ConsignmentTrackingComponent.prototype.ngOnInit = function () {
            this.consignmentTracking$ = this.userOrderService.getConsignmentTracking();
        };
        ConsignmentTrackingComponent.prototype.openTrackingDialog = function (consignment) {
            this.userOrderService.loadConsignmentTracking(this.orderCode, consignment.code);
            var modalInstance;
            this.modalRef = this.modalService.open(TrackingEventsComponent, {
                centered: true,
                size: 'lg',
            });
            modalInstance = this.modalRef.componentInstance;
            modalInstance.tracking$ = this.consignmentTracking$;
            modalInstance.shipDate = consignment.statusDate;
            modalInstance.consignmentCode = consignment.code;
        };
        ConsignmentTrackingComponent.prototype.ngOnDestroy = function () {
            this.userOrderService.clearConsignmentTracking();
        };
        return ConsignmentTrackingComponent;
    }());
    ConsignmentTrackingComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-consignment-tracking',
                    template: "<ng-container *ngIf=\"consignment && consignment.status\">\n  <div *ngIf=\"consignmentStatus.includes(consignment.status)\">\n    <button\n      (click)=\"openTrackingDialog(consignment)\"\n      class=\"btn btn-action btn-track\"\n      type=\"button\"\n    >\n      {{ 'orderDetails.consignmentTracking.action' | cxTranslate }}\n    </button>\n  </div>\n</ng-container>\n"
                },] }
    ];
    ConsignmentTrackingComponent.ctorParameters = function () { return [
        { type: i1.UserOrderService },
        { type: ModalService }
    ]; };
    ConsignmentTrackingComponent.propDecorators = {
        consignment: [{ type: i0.Input }],
        orderCode: [{ type: i0.Input }]
    };

    var OrderConsignedEntriesComponent = /** @class */ (function () {
        function OrderConsignedEntriesComponent() {
            this.promotionLocation = i1.PromotionLocation.Order;
        }
        OrderConsignedEntriesComponent.prototype.getConsignmentProducts = function (consignment) {
            var products = [];
            consignment.entries.forEach(function (element) {
                products.push(element.orderEntry);
            });
            return products;
        };
        return OrderConsignedEntriesComponent;
    }());
    OrderConsignedEntriesComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-consigned-entries',
                    template: "<div *ngFor=\"let consignment of consignments\" class=\"cx-list row\">\n  <div class=\"cx-list-header col-12\">\n    <div class=\"cx-list-status\">\n      <span *ngIf=\"consignment\">\n        {{\n          'orderDetails.deliveryStatus'\n            | cxTranslate: { context: consignment.status }\n        }}\n      </span>\n    </div>\n    <div *ngIf=\"consignment?.statusDate\" class=\"cx-list-date\">\n      <div>{{ consignment?.statusDate | cxDate }}</div>\n    </div>\n\n    <cx-consignment-tracking\n      [orderCode]=\"order.code\"\n      [consignment]=\"consignment\"\n      *cxFeature=\"'consignmentTracking'\"\n    >\n    </cx-consignment-tracking>\n  </div>\n  <div class=\"cx-list-item col-12\">\n    <cx-cart-item-list\n      [items]=\"consignment.entries\"\n      [readonly]=\"true\"\n      [promotionLocation]=\"promotionLocation\"\n    ></cx-cart-item-list>\n  </div>\n</div>\n"
                },] }
    ];
    OrderConsignedEntriesComponent.propDecorators = {
        consignments: [{ type: i0.Input }],
        order: [{ type: i0.Input }]
    };

    var OrderDetailShippingComponent = /** @class */ (function () {
        function OrderDetailShippingComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
        }
        OrderDetailShippingComponent.prototype.ngOnInit = function () {
            this.order$ = this.orderDetailsService.getOrderDetails();
        };
        return OrderDetailShippingComponent;
    }());
    OrderDetailShippingComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-details-shipping',
                    template: "<ng-container *ngIf=\"order$ | async as order\">\n  <cx-order-overview [order]=\"order\"></cx-order-overview>\n</ng-container>\n"
                },] }
    ];
    OrderDetailShippingComponent.ctorParameters = function () { return [
        { type: OrderDetailsService }
    ]; };

    var OrderDetailTotalsComponent = /** @class */ (function () {
        function OrderDetailTotalsComponent(orderDetailsService) {
            this.orderDetailsService = orderDetailsService;
        }
        OrderDetailTotalsComponent.prototype.ngOnInit = function () {
            this.order$ = this.orderDetailsService.getOrderDetails();
        };
        return OrderDetailTotalsComponent;
    }());
    OrderDetailTotalsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-details-totals',
                    template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"row justify-content-end\">\n    <div class=\"cx-summary col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <cx-order-summary [cart]=\"order\"></cx-order-summary>\n    </div>\n  </div>\n</ng-container>\n"
                },] }
    ];
    OrderDetailTotalsComponent.ctorParameters = function () { return [
        { type: OrderDetailsService }
    ]; };

    var moduleComponents = [
        OrderDetailActionsComponent,
        OrderDetailItemsComponent,
        OrderDetailTotalsComponent,
        OrderDetailShippingComponent,
        OrderDetailApprovalDetailsComponent,
        TrackingEventsComponent,
        ConsignmentTrackingComponent,
        OrderConsignedEntriesComponent,
    ];
    var ɵ0$5 = { pageLabel: 'order', cxRoute: 'orderGuest' }, ɵ1 = { cxRoute: 'orderDetails' };
    var OrderDetailsModule = /** @class */ (function () {
        function OrderDetailsModule() {
        }
        return OrderDetailsModule;
    }());
    OrderDetailsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        CartSharedModule,
                        CardModule,
                        i1$1.CommonModule,
                        i1.I18nModule,
                        i1.FeaturesConfigModule,
                        PromotionsModule,
                        OrderOverviewModule,
                        i1.UrlModule,
                        SpinnerModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [i1.AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$5,
                            },
                            {
                                path: null,
                                canActivate: [i1.AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ1,
                            },
                        ]),
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                AccountOrderDetailsActionsComponent: {
                                    component: OrderDetailActionsComponent,
                                },
                                AccountOrderDetailsApprovalDetailsComponent: {
                                    component: OrderDetailApprovalDetailsComponent,
                                },
                                AccountOrderDetailsItemsComponent: {
                                    component: OrderDetailItemsComponent,
                                },
                                AccountOrderDetailsTotalsComponent: {
                                    component: OrderDetailTotalsComponent,
                                },
                                AccountOrderDetailsShippingComponent: {
                                    component: OrderDetailShippingComponent,
                                },
                            },
                            features: {
                                consignmentTracking: '1.2',
                            },
                        }),
                        OrderDetailsService,
                    ],
                    declarations: __spread(moduleComponents),
                    exports: __spread(moduleComponents),
                    entryComponents: __spread(moduleComponents),
                },] }
    ];

    var OrderHistoryComponent = /** @class */ (function () {
        function OrderHistoryComponent(routing, userOrderService, translation, userReplenishmentOrderService) {
            var _this = this;
            this.routing = routing;
            this.userOrderService = userOrderService;
            this.translation = translation;
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.PAGE_SIZE = 5;
            this.orders$ = this.userOrderService.getOrderHistoryList(this.PAGE_SIZE).pipe(operators.tap(function (orders) {
                if (orders.pagination) {
                    _this.sortType = orders.pagination.sort;
                }
            }));
            this.hasReplenishmentOrder$ = this.userReplenishmentOrderService
                .getReplenishmentOrderDetails()
                .pipe(operators.map(function (order) { return order && Object.keys(order).length !== 0; }));
            this.isLoaded$ = this.userOrderService.getOrderHistoryListLoaded();
            /**
             * When "Order Return" feature is enabled, this component becomes one tab in
             * TabParagraphContainerComponent. This can be read from TabParagraphContainer.
             */
            this.tabTitleParam$ = this.orders$.pipe(operators.map(function (order) { return order.pagination.totalResults; }), operators.filter(function (totalResults) { return totalResults !== undefined; }), operators.take(1));
        }
        OrderHistoryComponent.prototype.ngOnDestroy = function () {
            this.userOrderService.clearOrderList();
        };
        OrderHistoryComponent.prototype.changeSortCode = function (sortCode) {
            var event = {
                sortCode: sortCode,
                currentPage: 0,
            };
            this.sortType = sortCode;
            this.fetchOrders(event);
        };
        OrderHistoryComponent.prototype.pageChange = function (page) {
            var event = {
                sortCode: this.sortType,
                currentPage: page,
            };
            this.fetchOrders(event);
        };
        OrderHistoryComponent.prototype.goToOrderDetail = function (order) {
            this.routing.go({
                cxRoute: 'orderDetails',
                params: order,
            });
        };
        OrderHistoryComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('sorting.date'),
                this.translation.translate('sorting.orderNumber'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), textByDate = _b[0], textByOrderNumber = _b[1];
                return {
                    byDate: textByDate,
                    byOrderNumber: textByOrderNumber,
                };
            }));
        };
        OrderHistoryComponent.prototype.fetchOrders = function (event) {
            this.userOrderService.loadOrderList(this.PAGE_SIZE, event.currentPage, event.sortCode);
        };
        return OrderHistoryComponent;
    }());
    OrderHistoryComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-history',
                    template: "<ng-container\n  *ngIf=\"{\n    orderHistory: orders$ | async,\n    replenishmentOrder: hasReplenishmentOrder$ | async\n  } as type\"\n>\n  <ng-container *ngIf=\"type.orderHistory\">\n    <div [ngClass]=\"type.replenishmentOrder ? '' : 'container'\">\n      <!-- HEADER -->\n      <div\n        [ngClass]=\"\n          type.replenishmentOrder\n            ? 'cx-replenishment-details-order-history-header'\n            : 'cx-order-history-header'\n        \"\n      >\n        <h4 *ngIf=\"type.replenishmentOrder\">\n          {{ 'orderHistory.replenishmentHistory' | cxTranslate }}\n        </h4>\n        <h3 *ngIf=\"!type.replenishmentOrder\">\n          {{ 'orderHistory.orderHistory' | cxTranslate }}\n        </h3>\n      </div>\n\n      <!-- BODY -->\n      <div class=\"cx-order-history-body\">\n        <ng-container\n          *ngIf=\"type.orderHistory.pagination.totalResults > 0; else noOrder\"\n        >\n          <!-- Select Form and Pagination Top -->\n          <div class=\"cx-order-history-sort top row\">\n            <div\n              class=\"cx-order-history-form-group form-group col-sm-12 col-md-4 col-lg-4\"\n            >\n              <cx-sorting\n                [sortOptions]=\"type.orderHistory.sorts\"\n                [sortLabels]=\"getSortLabels() | async\"\n                (sortListEvent)=\"changeSortCode($event)\"\n                [selectedOption]=\"type.orderHistory.pagination.sort\"\n                placeholder=\"{{\n                  'orderHistory.sortByMostRecent' | cxTranslate\n                }}\"\n              ></cx-sorting>\n            </div>\n            <div\n              *ngIf=\"type.orderHistory.pagination.totalPages > 1\"\n              class=\"cx-order-history-pagination\"\n            >\n              <cx-pagination\n                [pagination]=\"type.orderHistory.pagination\"\n                (viewPageEvent)=\"pageChange($event)\"\n              ></cx-pagination>\n            </div>\n          </div>\n          <!-- TABLE -->\n          <table class=\"table cx-order-history-table\">\n            <thead class=\"cx-order-history-thead-mobile\">\n              <th scope=\"col\">\n                {{ 'orderHistory.orderId' | cxTranslate }}\n              </th>\n              <th scope=\"col\">{{ 'orderHistory.date' | cxTranslate }}</th>\n              <th scope=\"col\">\n                {{ 'orderHistory.status' | cxTranslate }}\n              </th>\n              <th scope=\"col\">{{ 'orderHistory.total' | cxTranslate }}</th>\n            </thead>\n            <tbody>\n              <tr\n                *ngFor=\"let order of type.orderHistory.orders\"\n                (click)=\"goToOrderDetail(order)\"\n              >\n                <td class=\"cx-order-history-code\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.orderId' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{ order?.code }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-placed\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.date' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                    >{{ order?.placed | cxDate: 'longDate' }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-status\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.status' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{\n                      'orderDetails.statusDisplay_' + order?.statusDisplay\n                        | cxTranslate\n                    }}</a\n                  >\n                </td>\n                <td class=\"cx-order-history-total\">\n                  <div class=\"d-md-none cx-order-history-label\">\n                    {{ 'orderHistory.total' | cxTranslate }}\n                  </div>\n                  <a\n                    [routerLink]=\"\n                      {\n                        cxRoute: 'orderDetails',\n                        params: order\n                      } | cxUrl\n                    \"\n                    class=\"cx-order-history-value\"\n                  >\n                    {{ order?.total.formattedValue }}</a\n                  >\n                </td>\n              </tr>\n            </tbody>\n          </table>\n          <!-- Select Form and Pagination Bottom -->\n          <div class=\"cx-order-history-sort bottom row\">\n            <div\n              *ngIf=\"type.orderHistory.pagination.totalPages > 1\"\n              class=\"cx-order-history-pagination\"\n            >\n              <cx-pagination\n                [pagination]=\"type.orderHistory.pagination\"\n                (viewPageEvent)=\"pageChange($event)\"\n              ></cx-pagination>\n            </div>\n          </div>\n        </ng-container>\n\n        <!-- NO ORDER CONTAINER -->\n        <ng-template #noOrder>\n          <div\n            *ngIf=\"isLoaded$ | async\"\n            [ngClass]=\"\n              type.replenishmentOrder\n                ? 'cx-replenishment-details-order-history-no-order row'\n                : 'cx-order-history-no-order row'\n            \"\n          >\n            <div\n              [ngClass]=\"\n                type.replenishmentOrder ? '' : 'col-sm-12 col-md-6 col-lg-4'\n              \"\n            >\n              <ng-container *ngIf=\"type.replenishmentOrder; else otherOrder\">\n                <div>{{ 'orderHistory.notFound' | cxTranslate }}</div>\n              </ng-container>\n\n              <ng-template #otherOrder>\n                <div>{{ 'orderHistory.noOrders' | cxTranslate }}</div>\n                <a\n                  [routerLink]=\"{ cxRoute: 'home' } | cxUrl\"\n                  routerLinkActive=\"active\"\n                  class=\"btn btn-primary btn-block\"\n                  >{{ 'orderHistory.startShopping' | cxTranslate }}</a\n                >\n              </ng-template>\n            </div>\n          </div>\n        </ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderHistoryComponent.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.UserOrderService },
        { type: i1.TranslationService },
        { type: i1.UserReplenishmentOrderService }
    ]; };

    var ɵ0$6 = { cxRoute: 'orders' };
    var OrderHistoryModule = /** @class */ (function () {
        function OrderHistoryModule() {
        }
        return OrderHistoryModule;
    }());
    OrderHistoryModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [i1.AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$6,
                            },
                        ]),
                        i4.RouterModule,
                        forms.FormsModule,
                        ngSelect.NgSelectModule,
                        ListNavigationModule,
                        i1.UrlModule,
                        i1.I18nModule,
                    ],
                    declarations: [OrderHistoryComponent],
                    exports: [OrderHistoryComponent],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                AccountOrderHistoryComponent: {
                                    component: OrderHistoryComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    entryComponents: [OrderHistoryComponent],
                },] }
    ];

    var defaultReplenishmentOrderCancellationLayoutConfig = {
        launch: {
            REPLENISHMENT_ORDER: {
                inline: true,
                component: ReplenishmentOrderCancellationDialogComponent,
                dialogType: exports.DIALOG_TYPE.DIALOG,
            },
        },
    };

    var ReplenishmentOrderCancellationLaunchDialogService = /** @class */ (function () {
        function ReplenishmentOrderCancellationLaunchDialogService(launchDialogService) {
            this.launchDialogService = launchDialogService;
        }
        ReplenishmentOrderCancellationLaunchDialogService.prototype.openDialog = function (openElement, vcr, data) {
            var _this = this;
            var component = this.launchDialogService.launch(exports.LAUNCH_CALLER.REPLENISHMENT_ORDER, vcr, data);
            if (component) {
                return rxjs.combineLatest([
                    component,
                    this.launchDialogService.dialogClose,
                ]).pipe(operators.filter(function (_a) {
                    var _b = __read(_a, 2), close = _b[1];
                    return close && close !== undefined;
                }), operators.tap(function (_a) {
                    var _b = __read(_a, 1), comp = _b[0];
                    openElement === null || openElement === void 0 ? void 0 : openElement.nativeElement.focus();
                    _this.launchDialogService.clear(exports.LAUNCH_CALLER.REPLENISHMENT_ORDER);
                    comp.destroy();
                }), operators.map(function (_a) {
                    var _b = __read(_a, 1), comp = _b[0];
                    return comp;
                }));
            }
        };
        return ReplenishmentOrderCancellationLaunchDialogService;
    }());
    ReplenishmentOrderCancellationLaunchDialogService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ReplenishmentOrderCancellationLaunchDialogService_Factory() { return new ReplenishmentOrderCancellationLaunchDialogService(i0.ɵɵinject(LaunchDialogService)); }, token: ReplenishmentOrderCancellationLaunchDialogService, providedIn: "root" });
    ReplenishmentOrderCancellationLaunchDialogService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    ReplenishmentOrderCancellationLaunchDialogService.ctorParameters = function () { return [
        { type: LaunchDialogService }
    ]; };

    var ReplenishmentOrderCancellationComponent = /** @class */ (function () {
        function ReplenishmentOrderCancellationComponent(userReplenishmentOrderService, replenishmentOrderCancellationLaunchDialogService, vcr) {
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.replenishmentOrderCancellationLaunchDialogService = replenishmentOrderCancellationLaunchDialogService;
            this.vcr = vcr;
            this.subscription = new rxjs.Subscription();
            this.replenishmentOrder$ = this.userReplenishmentOrderService.getReplenishmentOrderDetails();
        }
        ReplenishmentOrderCancellationComponent.prototype.openDialog = function () {
            var dialog = this.replenishmentOrderCancellationLaunchDialogService.openDialog(this.element, this.vcr);
            if (dialog) {
                this.subscription.add(dialog.pipe(operators.take(1)).subscribe());
            }
        };
        ReplenishmentOrderCancellationComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.userReplenishmentOrderService.clearReplenishmentOrderDetails();
        };
        return ReplenishmentOrderCancellationComponent;
    }());
    ReplenishmentOrderCancellationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-replenishment-order-cancellation',
                    template: "<div class=\"cx-cancel-replenishment-btns row\">\n  <div class=\"col-xs-12 col-md-5 col-lg-4\">\n    <a\n      class=\"btn btn-block btn-action\"\n      [routerLink]=\"\n        {\n          cxRoute: 'replenishmentOrders'\n        } | cxUrl\n      \"\n    >\n      {{ 'common.back' | cxTranslate }}\n    </a>\n  </div>\n  <div\n    *ngIf=\"(replenishmentOrder$ | async).active\"\n    class=\"col-xs-12 col-md-5 col-lg-4\"\n  >\n    <button #element class=\"btn btn-block btn-action\" (click)=\"openDialog()\">\n      {{ 'orderDetails.cancelReplenishment.title' | cxTranslate }}\n    </button>\n  </div>\n</div>\n"
                },] }
    ];
    ReplenishmentOrderCancellationComponent.ctorParameters = function () { return [
        { type: i1.UserReplenishmentOrderService },
        { type: ReplenishmentOrderCancellationLaunchDialogService },
        { type: i0.ViewContainerRef }
    ]; };
    ReplenishmentOrderCancellationComponent.propDecorators = {
        element: [{ type: i0.ViewChild, args: ['element',] }]
    };

    var ReplenishmentOrderDetailsService = /** @class */ (function () {
        function ReplenishmentOrderDetailsService(routingService, userReplenishmentOrderService) {
            var _this = this;
            this.routingService = routingService;
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.replenishmentOrderCode$ = this.routingService
                .getRouterState()
                .pipe(operators.map(function (routingData) { return routingData.state.params.replenishmentOrderCode; }));
            this.replenishmentOrderLoad$ = this.replenishmentOrderCode$.pipe(operators.tap(function (replenishmentOrderCode) {
                if (Boolean(replenishmentOrderCode)) {
                    _this.userReplenishmentOrderService.loadReplenishmentOrderDetails(replenishmentOrderCode);
                }
                else {
                    _this.userReplenishmentOrderService.clearReplenishmentOrderDetails();
                }
            }), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        ReplenishmentOrderDetailsService.prototype.getOrderDetails = function () {
            var _this = this;
            return this.replenishmentOrderLoad$.pipe(operators.switchMap(function (_) { return _this.userReplenishmentOrderService.getReplenishmentOrderDetails(); }));
        };
        return ReplenishmentOrderDetailsService;
    }());
    ReplenishmentOrderDetailsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ReplenishmentOrderDetailsService_Factory() { return new ReplenishmentOrderDetailsService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.UserReplenishmentOrderService)); }, token: ReplenishmentOrderDetailsService, providedIn: "root" });
    ReplenishmentOrderDetailsService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ReplenishmentOrderDetailsService.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.UserReplenishmentOrderService }
    ]; };

    var moduleComponents$1 = [ReplenishmentOrderCancellationComponent];
    var ɵ0$7 = { cxRoute: 'replenishmentDetails' };
    var ReplenishmentOrderDetailsModule = /** @class */ (function () {
        function ReplenishmentOrderDetailsModule() {
        }
        return ReplenishmentOrderDetailsModule;
    }());
    ReplenishmentOrderDetailsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        CartSharedModule,
                        CardModule,
                        i1$1.CommonModule,
                        i1.I18nModule,
                        PromotionsModule,
                        i1.UrlModule,
                        ReplenishmentOrderCancellationDialogModule,
                        SpinnerModule,
                        ListNavigationModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [i1.AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$7,
                            },
                        ]),
                    ],
                    providers: [
                        i1.provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ReplenishmentDetailItemsComponent: {
                                    component: OrderDetailItemsComponent,
                                    providers: [
                                        {
                                            provide: OrderDetailsService,
                                            useExisting: ReplenishmentOrderDetailsService,
                                        },
                                    ],
                                },
                                ReplenishmentDetailTotalsComponent: {
                                    component: OrderDetailTotalsComponent,
                                    providers: [
                                        {
                                            provide: OrderDetailsService,
                                            useExisting: ReplenishmentOrderDetailsService,
                                        },
                                    ],
                                },
                                ReplenishmentDetailShippingComponent: {
                                    component: OrderDetailShippingComponent,
                                    providers: [
                                        {
                                            provide: OrderDetailsService,
                                            useExisting: ReplenishmentOrderDetailsService,
                                        },
                                    ],
                                },
                                ReplenishmentDetailActionsComponent: {
                                    component: ReplenishmentOrderCancellationComponent,
                                },
                                ReplenishmentDetailOrderHistoryComponent: {
                                    component: OrderHistoryComponent,
                                },
                            },
                        }),
                    ],
                    declarations: __spread(moduleComponents$1),
                    exports: __spread(moduleComponents$1),
                    entryComponents: __spread(moduleComponents$1),
                },] }
    ];

    var ReplenishmentOrderHistoryComponent = /** @class */ (function () {
        function ReplenishmentOrderHistoryComponent(routing, userReplenishmentOrderService, replenishmentOrderCancellationLaunchDialogService, translation, vcr) {
            var _this = this;
            this.routing = routing;
            this.userReplenishmentOrderService = userReplenishmentOrderService;
            this.replenishmentOrderCancellationLaunchDialogService = replenishmentOrderCancellationLaunchDialogService;
            this.translation = translation;
            this.vcr = vcr;
            this.subscription = new rxjs.Subscription();
            this.PAGE_SIZE = 5;
            this.replenishmentOrders$ = this.userReplenishmentOrderService
                .getReplenishmentOrderHistoryList(this.PAGE_SIZE)
                .pipe(operators.tap(function (replenishmentOrders) {
                if (replenishmentOrders.pagination) {
                    _this.sortType = replenishmentOrders.pagination.sort;
                }
            }));
            this.isLoaded$ = this.userReplenishmentOrderService.getReplenishmentOrderHistoryListSuccess();
        }
        ReplenishmentOrderHistoryComponent.prototype.changeSortCode = function (sortCode) {
            var event = {
                sortCode: sortCode,
                currentPage: 0,
            };
            this.sortType = sortCode;
            this.fetchReplenishmentOrders(event);
        };
        ReplenishmentOrderHistoryComponent.prototype.pageChange = function (page) {
            var event = {
                sortCode: this.sortType,
                currentPage: page,
            };
            this.fetchReplenishmentOrders(event);
        };
        ReplenishmentOrderHistoryComponent.prototype.goToOrderDetail = function (order) {
            this.routing.go({
                cxRoute: 'replenishmentDetails',
                params: order,
            });
        };
        ReplenishmentOrderHistoryComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('sorting.date'),
                this.translation.translate('sorting.replenishmentNumber'),
                this.translation.translate('sorting.nextOrderDate'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), textByDate = _b[0], textByOrderNumber = _b[1], textbyNextOrderDate = _b[2];
                return {
                    byDate: textByDate,
                    byReplenishmentNumber: textByOrderNumber,
                    byNextOrderDate: textbyNextOrderDate,
                };
            }));
        };
        ReplenishmentOrderHistoryComponent.prototype.openDialog = function (event, replenishmentOrderCode) {
            var dialog = this.replenishmentOrderCancellationLaunchDialogService.openDialog(this.element, this.vcr, replenishmentOrderCode);
            if (dialog) {
                this.subscription.add(dialog.pipe(operators.take(1)).subscribe());
            }
            event.stopPropagation();
        };
        ReplenishmentOrderHistoryComponent.prototype.fetchReplenishmentOrders = function (event) {
            this.userReplenishmentOrderService.loadReplenishmentOrderList(this.PAGE_SIZE, event.currentPage, event.sortCode);
        };
        ReplenishmentOrderHistoryComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.userReplenishmentOrderService.clearReplenishmentOrderList();
        };
        return ReplenishmentOrderHistoryComponent;
    }());
    ReplenishmentOrderHistoryComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-replenishment-order-history',
                    template: "<ng-container *ngIf=\"replenishmentOrders$ | async as replenishmentOrders\">\n  <div class=\"container\">\n    <!-- HEADER -->\n    <div class=\"cx-replenishment-order-history-header\">\n      <h3>\n        {{ 'orderHistory.replenishmentOrderHistory' | cxTranslate }}\n      </h3>\n    </div>\n\n    <!-- BODY -->\n    <div class=\"cx-replenishment-order-history-body\">\n      <ng-container\n        *ngIf=\"replenishmentOrders.pagination.totalResults > 0; else noOrder\"\n      >\n        <!-- Select Form and Pagination Top -->\n        <div class=\"cx-replenishment-order-history-sort top row\">\n          <div\n            class=\"cx-replenishment-order-history-form-group form-group col-sm-12 col-md-4 col-lg-4\"\n          >\n            <cx-sorting\n              [sortOptions]=\"replenishmentOrders.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"replenishmentOrders.pagination.sort\"\n              placeholder=\"{{ 'orderHistory.sortByMostRecent' | cxTranslate }}\"\n            ></cx-sorting>\n          </div>\n          <div\n            class=\"cx-replenishment-order-history-pagination\"\n            *ngIf=\"replenishmentOrders.pagination.totalPages > 1\"\n          >\n            <cx-pagination\n              [pagination]=\"replenishmentOrders.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <!-- TABLE -->\n        <table class=\"table cx-replenishment-order-history-table\">\n          <thead class=\"cx-replenishment-order-history-thead-mobile\">\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.replenishmentOrderId' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.purchaseOrderNumber' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.startOn' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.frequency' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.nextOrderDate' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\" class=\"cx-replenishment-order-history-total\">\n              <span class=\"cx-replenishment-order-history-ellipses\">\n                {{ 'orderHistory.total' | cxTranslate }}\n              </span>\n            </th>\n            <th scope=\"col\"></th>\n          </thead>\n          <tbody>\n            <tr\n              *ngFor=\"let order of replenishmentOrders.replenishmentOrders\"\n              (click)=\"goToOrderDetail(order)\"\n            >\n              <td class=\"cx-replenishment-order-history-code\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.replenishmentOrderId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.replenishmentOrderCode }}</a\n                >\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.purchaseOrderNumber' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value cx-purchase-order-number\"\n                >\n                  {{\n                    order?.purchaseOrderNumber?.length > 0\n                      ? order?.purchaseOrderNumber\n                      : ('orderHistory.emptyPurchaseOrderId' | cxTranslate)\n                  }}\n                </a>\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.startOn' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.firstDate | cxDate: 'M/d/yyyy' }}</a\n                >\n              </td>\n              <td class=\"cx-replenishment-order-history-frequency\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.frequency' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.trigger.displayTimeTable | slice: 0:-12 }}\n                </a>\n              </td>\n              <td>\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.nextOrderDate' | cxTranslate }}\n                </div>\n\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value cx-next-order-date\"\n                >\n                  {{\n                    order?.active\n                      ? (order?.trigger.activationTime | cxDate: 'M/d/yyyy')\n                      : ('orderHistory.cancelled' | cxTranslate)\n                  }}\n                </a>\n              </td>\n              <td class=\"cx-replenishment-order-history-total\">\n                <div class=\"d-md-none cx-replenishment-order-history-label\">\n                  {{ 'orderHistory.total' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'replenishmentDetails',\n                      params: order\n                    } | cxUrl\n                  \"\n                  class=\"cx-replenishment-order-history-value\"\n                >\n                  {{ order?.subTotal.formattedValue }}</a\n                >\n              </td>\n              <td class=\"cx-replenishment-order-history-cancel\">\n                <div\n                  class=\"d-md-none cx-replenishment-order-history-label\"\n                ></div>\n                <button\n                  (click)=\"openDialog($event, order?.replenishmentOrderCode)\"\n                  class=\"cx-order-cancel btn btn-link\"\n                  #element\n                  *ngIf=\"order?.active\"\n                >\n                  {{ 'orderHistory.cancel' | cxTranslate }}\n                </button>\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <!-- Select Form and Pagination Bottom -->\n        <div class=\"cx-replenishment-order-history-sort bottom row\">\n          <div class=\"cx-replenishment-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"replenishmentOrders.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n              *ngIf=\"replenishmentOrders.pagination.totalPages > 1\"\n            ></cx-pagination>\n          </div>\n        </div>\n      </ng-container>\n\n      <!-- NO ORDER CONTAINER -->\n      <ng-template #noOrder>\n        <div\n          class=\"cx-replenishment-order-history-no-order row\"\n          *ngIf=\"isLoaded$ | async\"\n        >\n          <div class=\"col-sm-12 col-md-6 col-lg-4\">\n            <div>{{ 'orderHistory.noReplenishmentOrders' | cxTranslate }}</div>\n            <a\n              [routerLink]=\"{ cxRoute: 'home' } | cxUrl\"\n              routerLinkActive=\"active\"\n              class=\"btn btn-primary btn-block\"\n              >{{ 'orderHistory.startShopping' | cxTranslate }}</a\n            >\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ReplenishmentOrderHistoryComponent.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.UserReplenishmentOrderService },
        { type: ReplenishmentOrderCancellationLaunchDialogService },
        { type: i1.TranslationService },
        { type: i0.ViewContainerRef }
    ]; };
    ReplenishmentOrderHistoryComponent.propDecorators = {
        element: [{ type: i0.ViewChild, args: ['element',] }]
    };

    var ɵ0$8 = { cxRoute: 'replenishmentOrders' };
    var ReplenishmentOrderHistoryModule = /** @class */ (function () {
        function ReplenishmentOrderHistoryModule() {
        }
        return ReplenishmentOrderHistoryModule;
    }());
    ReplenishmentOrderHistoryModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [i1.AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$8,
                            },
                        ]),
                        i4.RouterModule,
                        ListNavigationModule,
                        i1.UrlModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideConfig(defaultReplenishmentOrderCancellationLayoutConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                AccountReplenishmentHistoryComponent: {
                                    component: ReplenishmentOrderHistoryComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ReplenishmentOrderHistoryComponent],
                    exports: [ReplenishmentOrderHistoryComponent],
                    entryComponents: [ReplenishmentOrderHistoryComponent],
                },] }
    ];

    var ReturnRequestService = /** @class */ (function () {
        function ReturnRequestService(routingService, returnRequestService, globalMessageService) {
            this.routingService = routingService;
            this.returnRequestService = returnRequestService;
            this.globalMessageService = globalMessageService;
        }
        Object.defineProperty(ReturnRequestService.prototype, "isCancelling$", {
            get: function () {
                return this.returnRequestService.getCancelReturnRequestLoading();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ReturnRequestService.prototype, "isCancelSuccess$", {
            get: function () {
                return this.returnRequestService.getCancelReturnRequestSuccess();
            },
            enumerable: false,
            configurable: true
        });
        ReturnRequestService.prototype.getReturnRequest = function () {
            var _this = this;
            return rxjs.combineLatest([
                this.routingService.getRouterState(),
                this.returnRequestService.getOrderReturnRequest(),
                this.returnRequestService.getReturnRequestLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), routingState = _b[0], returnRequest = _b[1], isLoading = _b[2];
                return [
                    routingState.state.params['returnCode'],
                    returnRequest,
                    isLoading,
                ];
            }), operators.filter(function (_a) {
                var _b = __read(_a, 1), returnCode = _b[0];
                return Boolean(returnCode);
            }), operators.tap(function (_a) {
                var _b = __read(_a, 3), returnCode = _b[0], returnRequest = _b[1], isLoading = _b[2];
                if ((returnRequest === undefined || returnRequest.rma !== returnCode) &&
                    !isLoading) {
                    _this.returnRequestService.loadOrderReturnRequestDetail(returnCode);
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), _ = _b[0], returnRequest = _b[1];
                return returnRequest;
            }), operators.filter(Boolean), operators.distinctUntilChanged());
        };
        ReturnRequestService.prototype.clearReturnRequest = function () {
            this.returnRequestService.clearOrderReturnRequestDetail();
        };
        ReturnRequestService.prototype.cancelReturnRequest = function (returnRequestCode) {
            this.returnRequestService.cancelOrderReturnRequest(returnRequestCode, {
                status: 'CANCELLING',
            });
        };
        ReturnRequestService.prototype.cancelSuccess = function (rma) {
            this.returnRequestService.resetCancelReturnRequestProcessState();
            this.globalMessageService.add({
                key: 'returnRequest.cancelSuccess',
                params: { rma: rma },
            }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            this.routingService.go({
                cxRoute: 'orders',
            });
        };
        ReturnRequestService.prototype.backToList = function () {
            this.routingService.go({ cxRoute: 'orders' }, null, {
                state: {
                    activeTab: 1,
                },
            });
        };
        return ReturnRequestService;
    }());
    ReturnRequestService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ReturnRequestService_Factory() { return new ReturnRequestService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.OrderReturnRequestService), i0.ɵɵinject(i1.GlobalMessageService)); }, token: ReturnRequestService, providedIn: "root" });
    ReturnRequestService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ReturnRequestService.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.OrderReturnRequestService },
        { type: i1.GlobalMessageService }
    ]; };

    var ReturnRequestOverviewComponent = /** @class */ (function () {
        function ReturnRequestOverviewComponent(returnRequestService) {
            var _this = this;
            this.returnRequestService = returnRequestService;
            this.returnRequest$ = this.returnRequestService
                .getReturnRequest()
                .pipe(operators.tap(function (returnRequest) { return (_this.rma = returnRequest.rma); }));
            this.isCancelling$ = this.returnRequestService.isCancelling$;
        }
        ReturnRequestOverviewComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.returnRequestService.isCancelSuccess$.subscribe(function (success) {
                if (success) {
                    _this.returnRequestService.cancelSuccess(_this.rma);
                }
            });
        };
        ReturnRequestOverviewComponent.prototype.cancelReturn = function (returnRequestCode) {
            this.returnRequestService.cancelReturnRequest(returnRequestCode);
        };
        ReturnRequestOverviewComponent.prototype.back = function () {
            this.returnRequestService.backToList();
        };
        ReturnRequestOverviewComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return ReturnRequestOverviewComponent;
    }());
    ReturnRequestOverviewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-return-request-overview',
                    template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"cx-nav row\">\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button (click)=\"back()\" class=\"btn btn-block btn-action\">\n        {{ 'common.back' | cxTranslate }}\n      </button>\n    </div>\n\n    <div class=\"col-xs-12 col-md-4 col-lg-3\">\n      <button\n        *ngIf=\"returnRequest.cancellable\"\n        class=\"btn btn-block btn-primary\"\n        (click)=\"cancelReturn(returnRequest.rma)\"\n        [disabled]=\"isCancelling$ | async\"\n      >\n        {{ 'returnRequest.cancel' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n  <div class=\"cx-header row\">\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.returnRequestId' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">{{ returnRequest.rma }}</div>\n    </div>\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.orderCode' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">{{ returnRequest.order?.code }}</div>\n    </div>\n    <div class=\"cx-detail col-sm-12 col-md-4\">\n      <div class=\"cx-detail-label\">\n        {{ 'returnRequest.status' | cxTranslate }}\n      </div>\n      <div class=\"cx-detail-value\">\n        {{\n          'returnRequestList.statusDisplay'\n            | cxTranslate: { context: returnRequest.status }\n        }}\n      </div>\n    </div>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ReturnRequestOverviewComponent.ctorParameters = function () { return [
        { type: ReturnRequestService }
    ]; };

    var ReturnRequestItemsComponent = /** @class */ (function () {
        function ReturnRequestItemsComponent(returnRequestService) {
            this.returnRequestService = returnRequestService;
            this.returnRequest$ = this.returnRequestService.getReturnRequest();
        }
        return ReturnRequestItemsComponent;
    }());
    ReturnRequestItemsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-return-request-items',
                    template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"d-none d-md-block d-lg-block d-xl-block\">\n    <div class=\"cx-item-list-header row\">\n      <div class=\"cx-item-list-desc col-md-5 col-lg-5 col-xl-6\">\n        {{ 'returnRequest.item' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-price col-md-2 col-lg-2 col-xl-2\">\n        {{ 'returnRequest.itemPrice' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-qty col-md-3 col-lg-3 col-xl-2\">\n        {{ 'returnRequest.returnQty' | cxTranslate }}\n      </div>\n      <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n        {{ 'returnRequest.total' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n\n  <div\n    class=\"cx-item-list-row\"\n    *ngFor=\"let returnEntry of returnRequest.returnEntries; let i = index\"\n  >\n    <div class=\"cx-item-list-items\">\n      <div class=\"row\">\n        <!-- Item Image -->\n        <div class=\"col-2 cx-image-container\">\n          <cx-media\n            [container]=\"returnEntry.orderEntry?.product.images?.PRIMARY\"\n          ></cx-media>\n        </div>\n        <!-- Item Information -->\n        <div class=\"cx-info col-10\">\n          <div class=\"cx-info-container row\">\n            <!-- Item Description -->\n            <div class=\"col-md-3 col-lg-4 col-xl-5\">\n              <div *ngIf=\"returnEntry.orderEntry?.product.name\" class=\"cx-name\">\n                {{ returnEntry.orderEntry?.product.name }}\n              </div>\n              <div *ngIf=\"returnEntry.orderEntry?.product.code\" class=\"cx-code\">\n                {{ 'cartItems.id' | cxTranslate }}\n                {{ returnEntry.orderEntry?.product.code }}\n              </div>\n              <!-- Variants -->\n              <div\n                *ngFor=\"\n                  let variant of (returnEntry.orderEntry?.product\n                    .baseOptions)[0]?.selected?.variantOptionQualifiers\n                \"\n                class=\"cx-property\"\n              >\n                <div class=\"cx-label\" *ngIf=\"variant.name\">\n                  {{ variant.name }}:\n                </div>\n                <div class=\"cx-value\" *ngIf=\"variant.value\">\n                  {{ variant.value }}\n                </div>\n              </div>\n            </div>\n            <!-- Item Price -->\n            <div\n              *ngIf=\"returnEntry.orderEntry?.basePrice\"\n              class=\"cx-price col-md-3 col-lg-2 col-xl-2\"\n            >\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.itemPrice' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.orderEntry?.basePrice?.formattedValue }}\n              </div>\n            </div>\n            <!-- return Quantity -->\n            <div class=\"cx-quantity col-md-3 col-lg-3 col-xl-3\">\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.returnQty' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.expectedQuantity }}\n              </div>\n            </div>\n            <!-- Total Price -->\n            <div class=\"cx-total col-md-3 col-lg-3 col-xl-2\">\n              <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n                {{ 'returnRequest.total' | cxTranslate }}\n              </div>\n              <div class=\"cx-value\">\n                {{ returnEntry.refundAmount?.formattedValue }}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ReturnRequestItemsComponent.ctorParameters = function () { return [
        { type: ReturnRequestService }
    ]; };

    var ReturnRequestTotalsComponent = /** @class */ (function () {
        function ReturnRequestTotalsComponent(returnRequestService) {
            this.returnRequestService = returnRequestService;
            this.returnRequest$ = this.returnRequestService.getReturnRequest();
        }
        ReturnRequestTotalsComponent.prototype.ngOnDestroy = function () {
            this.returnRequestService.clearReturnRequest();
        };
        return ReturnRequestTotalsComponent;
    }());
    ReturnRequestTotalsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-return-request-totals',
                    template: "<ng-container *ngIf=\"returnRequest$ | async as returnRequest\">\n  <div class=\"row justify-content-end\">\n    <div class=\"cx-summary col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <h4>{{ 'returnRequest.summary' | cxTranslate }}</h4>\n      <div class=\"cx-summary-row\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.subtotal' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.subTotal?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.deliveryCode' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.deliveryCost?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row cx-summary-total\">\n        <div class=\"col-6 cx-summary-label\">\n          {{ 'returnRequest.estimatedRefund' | cxTranslate }}\n        </div>\n        <div class=\"col-6 cx-summary-amount\">\n          {{ returnRequest.totalPrice?.formattedValue }}\n        </div>\n      </div>\n      <div class=\"cx-summary-row cx-footnote\">\n        {{ 'returnRequest.note' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ReturnRequestTotalsComponent.ctorParameters = function () { return [
        { type: ReturnRequestService }
    ]; };

    var components = [
        ReturnRequestOverviewComponent,
        ReturnRequestItemsComponent,
        ReturnRequestTotalsComponent,
    ];
    var ɵ0$9 = { cxRoute: 'returnRequestDetails' };
    var ReturnRequestDetailModule = /** @class */ (function () {
        function ReturnRequestDetailModule() {
        }
        return ReturnRequestDetailModule;
    }());
    ReturnRequestDetailModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [i1.AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$9,
                            },
                        ]),
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        MediaModule,
                        i1.FeaturesConfigModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ReturnRequestOverviewComponent: {
                                    component: ReturnRequestOverviewComponent,
                                },
                                ReturnRequestItemsComponent: {
                                    component: ReturnRequestItemsComponent,
                                },
                                ReturnRequestTotalsComponent: {
                                    component: ReturnRequestTotalsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: __spread(components),
                    exports: __spread(components),
                    entryComponents: __spread(components),
                },] }
    ];

    var OrderReturnRequestListComponent = /** @class */ (function () {
        function OrderReturnRequestListComponent(returnRequestService, translation) {
            var _this = this;
            this.returnRequestService = returnRequestService;
            this.translation = translation;
            this.PAGE_SIZE = 5;
            this.returnRequests$ = this.returnRequestService.getOrderReturnRequestList(this.PAGE_SIZE).pipe(operators.tap(function (requestList) {
                if (requestList.pagination) {
                    _this.sortType = requestList.pagination.sort;
                }
            }));
            /**
             * When "Order Return" feature is enabled, this component becomes one tab in
             * TabParagraphContainerComponent. This can be read from TabParagraphContainer.
             */
            this.tabTitleParam$ = this.returnRequests$.pipe(operators.map(function (returnRequests) { return returnRequests.pagination.totalResults; }), operators.filter(function (totalResults) { return totalResults !== undefined; }), operators.take(1));
        }
        OrderReturnRequestListComponent.prototype.ngOnDestroy = function () {
            this.returnRequestService.clearOrderReturnRequestList();
        };
        OrderReturnRequestListComponent.prototype.changeSortCode = function (sortCode) {
            var event = {
                sortCode: sortCode,
                currentPage: 0,
            };
            this.sortType = sortCode;
            this.fetchReturnRequests(event);
        };
        OrderReturnRequestListComponent.prototype.pageChange = function (page) {
            var event = {
                sortCode: this.sortType,
                currentPage: page,
            };
            this.fetchReturnRequests(event);
        };
        OrderReturnRequestListComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('sorting.date'),
                this.translation.translate('sorting.rma'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), textByDate = _b[0], textByRma = _b[1];
                return {
                    byDate: textByDate,
                    byRMA: textByRma,
                };
            }));
        };
        OrderReturnRequestListComponent.prototype.fetchReturnRequests = function (event) {
            this.returnRequestService.loadOrderReturnRequestList(this.PAGE_SIZE, event.currentPage, event.sortCode);
        };
        return OrderReturnRequestListComponent;
    }());
    OrderReturnRequestListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-return-request-list',
                    template: "<ng-container *ngIf=\"returnRequests$ | async as returnRequests\">\n  <div class=\"container\">\n    <!-- BODY -->\n    <div class=\"cx-order-history-body\">\n      <ng-container *ngIf=\"returnRequests.pagination.totalResults > 0\">\n        <!-- Select Form and Pagination Top -->\n        <div class=\"cx-order-history-sort top row\">\n          <div\n            class=\"cx-order-history-form-group form-group col-sm-12 col-md-4 col-lg-4\"\n          >\n            <cx-sorting\n              [sortOptions]=\"returnRequests.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"returnRequests.pagination.sort\"\n              placeholder=\"{{\n                'returnRequestList.sortByMostRecent' | cxTranslate\n              }}\"\n            ></cx-sorting>\n          </div>\n          <div class=\"cx-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"returnRequests.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <!-- TABLE -->\n        <table class=\"table cx-order-history-table\">\n          <thead class=\"cx-order-history-thead-mobile\">\n            <th scope=\"col\">\n              {{ 'returnRequestList.returnRequestId' | cxTranslate }}\n            </th>\n            <th scope=\"col\">{{ 'returnRequestList.orderId' | cxTranslate }}</th>\n            <th scope=\"col\">\n              {{ 'returnRequestList.date' | cxTranslate }}\n            </th>\n            <th scope=\"col\">{{ 'returnRequestList.status' | cxTranslate }}</th>\n          </thead>\n          <tbody>\n            <tr *ngFor=\"let return of returnRequests.returnRequests\">\n              <td class=\"cx-order-history-code\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.returnRequestId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'returnRequestDetails',\n                      params: return\n                    } | cxUrl\n                  \"\n                  class=\"cx-order-history-value\"\n                >\n                  {{ return?.rma }}</a\n                >\n              </td>\n              <td class=\"cx-order-history-code\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.orderId' | cxTranslate }}\n                </div>\n                <a\n                  [routerLink]=\"\n                    {\n                      cxRoute: 'orderDetails',\n                      params: return?.order\n                    } | cxUrl\n                  \"\n                  class=\"cx-order-history-value\"\n                >\n                  {{ return?.order?.code }}</a\n                >\n              </td>\n\n              <td class=\"cx-order-history-placed\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.date' | cxTranslate }}\n                </div>\n                {{ return?.creationTime | cxDate: 'longDate' }}\n              </td>\n              <td class=\"cx-order-history-status\">\n                <div class=\"d-md-none cx-order-history-label\">\n                  {{ 'returnRequestList.status' | cxTranslate }}\n                </div>\n                {{\n                  'returnRequestList.statusDisplay'\n                    | cxTranslate: { context: return?.status }\n                }}\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <!-- Select Form and Pagination Bottom -->\n        <div class=\"cx-order-history-sort bottom row\">\n          <div\n            class=\"cx-order-history-form-group form-group col-sm-12 col-md-4 col-lg-4\"\n          >\n            <cx-sorting\n              [sortOptions]=\"returnRequests.sorts\"\n              [sortLabels]=\"getSortLabels() | async\"\n              (sortListEvent)=\"changeSortCode($event)\"\n              [selectedOption]=\"returnRequests.pagination.sort\"\n              placeholder=\"{{\n                'returnRequestList.sortByMostRecent' | cxTranslate\n              }}\"\n            ></cx-sorting>\n          </div>\n          <div class=\"cx-order-history-pagination\">\n            <cx-pagination\n              [pagination]=\"returnRequests.pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderReturnRequestListComponent.ctorParameters = function () { return [
        { type: i1.OrderReturnRequestService },
        { type: i1.TranslationService }
    ]; };

    var ReturnRequestListModule = /** @class */ (function () {
        function ReturnRequestListModule() {
        }
        return ReturnRequestListModule;
    }());
    ReturnRequestListModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        ListNavigationModule,
                        i1.UrlModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                OrderReturnRequestListComponent: {
                                    component: OrderReturnRequestListComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [OrderReturnRequestListComponent],
                    exports: [OrderReturnRequestListComponent],
                    entryComponents: [OrderReturnRequestListComponent],
                },] }
    ];

    var OrderModule = /** @class */ (function () {
        function OrderModule() {
        }
        return OrderModule;
    }());
    OrderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        OrderHistoryModule,
                        OrderDetailsModule,
                        ReplenishmentOrderDetailsModule,
                        OrderCancellationModule,
                        OrderReturnModule,
                        ReplenishmentOrderHistoryModule,
                        ReturnRequestListModule,
                        ReturnRequestDetailModule,
                    ],
                },] }
    ];

    var PaymentMethodsComponent = /** @class */ (function () {
        function PaymentMethodsComponent(userPaymentService, translation) {
            this.userPaymentService = userPaymentService;
            this.translation = translation;
            this.iconTypes = exports.ICON_TYPE;
        }
        PaymentMethodsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.paymentMethods$ = this.userPaymentService.getPaymentMethods().pipe(operators.tap(function (paymentDetails) {
                // Set first payment method to DEFAULT if none is set
                if (paymentDetails.length > 0 &&
                    !paymentDetails.find(function (paymentDetail) { return paymentDetail.defaultPayment; })) {
                    _this.setDefaultPaymentMethod(paymentDetails[0]);
                }
            }));
            this.editCard = null;
            this.loading$ = this.userPaymentService.getPaymentMethodsLoading();
            this.userPaymentService.loadPaymentMethods();
        };
        PaymentMethodsComponent.prototype.getCardContent = function (_a) {
            var _this = this;
            var defaultPayment = _a.defaultPayment, accountHolderName = _a.accountHolderName, expiryMonth = _a.expiryMonth, expiryYear = _a.expiryYear, cardNumber = _a.cardNumber, cardType = _a.cardType;
            return rxjs.combineLatest([
                this.translation.translate('paymentCard.setAsDefault'),
                this.translation.translate('common.delete'),
                this.translation.translate('paymentCard.deleteConfirmation'),
                this.translation.translate('paymentCard.expires', {
                    month: expiryMonth,
                    year: expiryYear,
                }),
                this.translation.translate('paymentCard.defaultPaymentMethod'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 5), textSetAsDefault = _b[0], textDelete = _b[1], textDeleteConfirmation = _b[2], textExpires = _b[3], textDefaultPaymentMethod = _b[4];
                var actions = [];
                if (!defaultPayment) {
                    actions.push({ name: textSetAsDefault, event: 'default' });
                }
                actions.push({ name: textDelete, event: 'edit' });
                var card = {
                    header: defaultPayment ? textDefaultPaymentMethod : null,
                    textBold: accountHolderName,
                    text: [cardNumber, textExpires],
                    actions: actions,
                    deleteMsg: textDeleteConfirmation,
                    img: _this.getCardIcon(cardType.code),
                };
                return card;
            }));
        };
        PaymentMethodsComponent.prototype.deletePaymentMethod = function (paymentMethod) {
            this.userPaymentService.deletePaymentMethod(paymentMethod.id);
            this.editCard = null;
        };
        PaymentMethodsComponent.prototype.setEdit = function (paymentMethod) {
            this.editCard = paymentMethod.id;
        };
        PaymentMethodsComponent.prototype.cancelCard = function () {
            this.editCard = null;
        };
        PaymentMethodsComponent.prototype.setDefaultPaymentMethod = function (paymentMethod) {
            this.userPaymentService.setPaymentMethodAsDefault(paymentMethod.id);
        };
        PaymentMethodsComponent.prototype.getCardIcon = function (code) {
            var ccIcon;
            if (code === 'visa') {
                ccIcon = this.iconTypes.VISA;
            }
            else if (code === 'master' || code === 'mastercard_eurocard') {
                ccIcon = this.iconTypes.MASTER_CARD;
            }
            else if (code === 'diners') {
                ccIcon = this.iconTypes.DINERS_CLUB;
            }
            else if (code === 'amex') {
                ccIcon = this.iconTypes.AMEX;
            }
            else {
                ccIcon = this.iconTypes.CREDIT_CARD;
            }
            return ccIcon;
        };
        return PaymentMethodsComponent;
    }());
    PaymentMethodsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-payment-methods',
                    template: "<ng-container *ngIf=\"paymentMethods$ | async as paymentMethods\">\n  <div class=\"cx-payment container\">\n    <div class=\"cx-header\">\n      <h3>{{ 'paymentMethods.paymentMethods' | cxTranslate }}</h3>\n    </div>\n\n    <div class=\"cx-body\">\n      <div class=\"cx-msg\">\n        {{\n          'paymentMethods.newPaymentMethodsAreAddedDuringCheckout' | cxTranslate\n        }}\n      </div>\n      <div *ngIf=\"loading$ | async; else cards\"><cx-spinner></cx-spinner></div>\n      <ng-template #cards>\n        <div class=\"cx-existing row\">\n          <div\n            class=\"cx-payment-card col-sm-12 col-md-12 col-lg-6\"\n            *ngFor=\"let paymentMethod of paymentMethods\"\n          >\n            <div class=\"cx-payment-inner\">\n              <cx-card\n                [border]=\"true\"\n                [fitToContainer]=\"true\"\n                [content]=\"getCardContent(paymentMethod) | async\"\n                (deleteCard)=\"deletePaymentMethod(paymentMethod)\"\n                (setDefaultCard)=\"setDefaultPaymentMethod(paymentMethod)\"\n                (editCard)=\"setEdit(paymentMethod)\"\n                [editMode]=\"editCard === paymentMethod.id\"\n                (cancelCard)=\"cancelCard()\"\n              ></cx-card>\n            </div>\n          </div>\n        </div>\n      </ng-template>\n    </div>\n  </div>\n</ng-container>\n"
                },] }
    ];
    PaymentMethodsComponent.ctorParameters = function () { return [
        { type: i1.UserPaymentService },
        { type: i1.TranslationService }
    ]; };

    var PaymentMethodsModule = /** @class */ (function () {
        function PaymentMethodsModule() {
        }
        return PaymentMethodsModule;
    }());
    PaymentMethodsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, CardModule, SpinnerModule, i1.I18nModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                AccountPaymentDetailsComponent: {
                                    component: PaymentMethodsComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [PaymentMethodsComponent],
                    exports: [PaymentMethodsComponent],
                    entryComponents: [PaymentMethodsComponent],
                },] }
    ];

    var ResetPasswordFormComponent = /** @class */ (function () {
        function ResetPasswordFormComponent(fb, routingService, userService) {
            this.fb = fb;
            this.routingService = routingService;
            this.userService = userService;
            this.subscription = new rxjs.Subscription();
            this.resetPasswordForm = this.fb.group({
                password: [
                    '',
                    [forms.Validators.required, CustomFormValidators.passwordValidator],
                ],
                repassword: ['', [forms.Validators.required]],
            }, {
                validators: CustomFormValidators.passwordsMustMatch('password', 'repassword'),
            });
        }
        ResetPasswordFormComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription.add(this.routingService
                .getRouterState()
                .subscribe(function (state) { return (_this.token = state.state.queryParams['token']); }));
            this.subscription.add(this.userService.isPasswordReset().subscribe(function (reset) {
                if (reset) {
                    _this.routingService.go({ cxRoute: 'login' });
                }
            }));
        };
        ResetPasswordFormComponent.prototype.resetPassword = function () {
            if (this.resetPasswordForm.valid) {
                var password = this.resetPasswordForm.get('password').value;
                this.userService.resetPassword(this.token, password);
            }
            else {
                this.resetPasswordForm.markAllAsTouched();
            }
        };
        ResetPasswordFormComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return ResetPasswordFormComponent;
    }());
    ResetPasswordFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-reset-password-form',
                    template: "<form\n  (ngSubmit)=\"resetPassword()\"\n  [formGroup]=\"resetPasswordForm\"\n  class=\"cx-reset-password-form-component\"\n>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'register.newPassword' | cxTranslate\n      }}</span>\n      <input\n        class=\"form-control\"\n        type=\"password\"\n        name=\"password\"\n        placeholder=\"{{ 'register.password.placeholder' | cxTranslate }}\"\n        formControlName=\"password\"\n      />\n      <cx-form-errors\n        [control]=\"resetPasswordForm.get('password')\"\n      ></cx-form-errors>\n    </label>\n  </div>\n\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'register.passwordMinRequirements' | cxTranslate\n      }}</span>\n      <input\n        class=\"form-control\"\n        type=\"password\"\n        name=\"confirmpassword\"\n        placeholder=\"{{ 'register.confirmPassword.placeholder' | cxTranslate }}\"\n        formControlName=\"repassword\"\n      />\n      <cx-form-errors\n        [control]=\"resetPasswordForm.get('repassword')\"\n      ></cx-form-errors>\n    </label>\n  </div>\n\n  <div class=\"form-group\">\n    <button class=\"btn btn-block btn-primary\" type=\"submit\">\n      {{ 'register.resetPassword' | cxTranslate }}\n    </button>\n  </div>\n</form>\n"
                },] }
    ];
    ResetPasswordFormComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder },
        { type: i1.RoutingService },
        { type: i1.UserService }
    ]; };

    var ResetPasswordModule = /** @class */ (function () {
        function ResetPasswordModule() {
        }
        return ResetPasswordModule;
    }());
    ResetPasswordModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        i4.RouterModule,
                        i1.I18nModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ResetPasswordComponent: {
                                    component: ResetPasswordFormComponent,
                                    guards: [i1.NotAuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ResetPasswordFormComponent],
                    exports: [ResetPasswordFormComponent],
                    entryComponents: [ResetPasswordFormComponent],
                },] }
    ];

    var UpdateEmailFormComponent = /** @class */ (function () {
        function UpdateEmailFormComponent(fb) {
            this.fb = fb;
            this.saveEmail = new i0.EventEmitter();
            this.cancelEmail = new i0.EventEmitter();
            this.updateEmailForm = this.fb.group({
                email: ['', [forms.Validators.required, CustomFormValidators.emailValidator]],
                confirmEmail: ['', [forms.Validators.required]],
                password: ['', [forms.Validators.required]],
            }, {
                validators: CustomFormValidators.emailsMustMatch('email', 'confirmEmail'),
            });
        }
        UpdateEmailFormComponent.prototype.onSubmit = function () {
            if (this.updateEmailForm.valid) {
                var newUid = this.updateEmailForm.get('confirmEmail').value;
                var password = this.updateEmailForm.get('password').value;
                this.saveEmail.emit({ newUid: newUid, password: password });
            }
            else {
                this.updateEmailForm.markAllAsTouched();
            }
        };
        UpdateEmailFormComponent.prototype.onCancel = function () {
            this.cancelEmail.emit();
        };
        return UpdateEmailFormComponent;
    }());
    UpdateEmailFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-update-email-form',
                    template: "<form (ngSubmit)=\"onSubmit()\" [formGroup]=\"updateEmailForm\">\n  <div class=\"form-group row\">\n    <div class=\"col-md-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updateEmailForm.newEmailAddress.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"email\"\n          name=\"email\"\n          formControlName=\"email\"\n          placeholder=\"{{\n            'updateEmailForm.newEmailAddress.placeholder' | cxTranslate\n          }}\"\n          class=\"form-control\"\n        />\n        <cx-form-errors\n          [control]=\"updateEmailForm.get('email')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n\n  <div class=\"form-group row\">\n    <div class=\"col-sm-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updateEmailForm.confirmNewEmailAddress.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"email\"\n          name=\"confirmEmail\"\n          formControlName=\"confirmEmail\"\n          placeholder=\"{{\n            'updateEmailForm.confirmNewEmailAddress.placeholder' | cxTranslate\n          }}\"\n          class=\"form-control\"\n        />\n        <cx-form-errors\n          [control]=\"updateEmailForm.get('confirmEmail')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n\n  <div class=\"form-group row\">\n    <div class=\"col-sm-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updateEmailForm.password.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"password\"\n          name=\"password\"\n          formControlName=\"password\"\n          placeholder=\"{{\n            'updateEmailForm.password.placeholder' | cxTranslate\n          }}\"\n          class=\"form-control\"\n          autocomplete=\"new-password\"\n        />\n        <cx-form-errors\n          [control]=\"updateEmailForm.get('password')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n\n  <div class=\"form-group row\">\n    <div class=\"col-lg-6\">\n      <button\n        class=\"btn btn-block btn-secondary\"\n        type=\"button\"\n        (click)=\"onCancel()\"\n      >\n        {{ 'common.cancel' | cxTranslate }}\n      </button>\n    </div>\n    <div class=\"col-lg-6\">\n      <button class=\"btn btn-block btn-primary\" type=\"submit\">\n        {{ 'common.save' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</form>\n"
                },] }
    ];
    UpdateEmailFormComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    UpdateEmailFormComponent.propDecorators = {
        saveEmail: [{ type: i0.Output }],
        cancelEmail: [{ type: i0.Output }]
    };

    var UpdateEmailComponent = /** @class */ (function () {
        function UpdateEmailComponent(routingService, globalMessageService, userService, authService) {
            this.routingService = routingService;
            this.globalMessageService = globalMessageService;
            this.userService = userService;
            this.authService = authService;
            this.subscription = new rxjs.Subscription();
        }
        UpdateEmailComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.userService.resetUpdateEmailResultState();
            this.subscription.add(this.userService
                .getUpdateEmailResultSuccess()
                .subscribe(function (success) { return _this.onSuccess(success); }));
            this.isLoading$ = this.userService.getUpdateEmailResultLoading();
        };
        UpdateEmailComponent.prototype.onCancel = function () {
            this.routingService.go({ cxRoute: 'home' });
        };
        UpdateEmailComponent.prototype.onSubmit = function (_a) {
            var newUid = _a.newUid, password = _a.password;
            this.newUid = newUid;
            this.userService.updateEmail(password, newUid);
        };
        UpdateEmailComponent.prototype.onSuccess = function (success) {
            if (success) {
                this.globalMessageService.add({
                    key: 'updateEmailForm.emailUpdateSuccess',
                    params: { newUid: this.newUid },
                }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                this.authService.logout();
                this.routingService.go({ cxRoute: 'login' }, null, {
                    state: {
                        newUid: this.newUid,
                    },
                });
            }
        };
        UpdateEmailComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.userService.resetUpdateEmailResultState();
        };
        return UpdateEmailComponent;
    }());
    UpdateEmailComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-update-email',
                    template: "<ng-container>\n  <div *ngIf=\"isLoading$ | async; else loaded\">\n    <div class=\"cx-spinner\">\n      <cx-spinner> </cx-spinner>\n    </div>\n  </div>\n\n  <ng-template #loaded>\n    <div class=\"container\">\n      <div class=\"row d-flex justify-content-center\">\n        <cx-update-email-form\n          class=\"col-md-6\"\n          (saveEmail)=\"onSubmit($event)\"\n          (cancelEmail)=\"onCancel()\"\n        >\n        </cx-update-email-form>\n      </div>\n    </div>\n  </ng-template>\n</ng-container>\n"
                },] }
    ];
    UpdateEmailComponent.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.GlobalMessageService },
        { type: i1.UserService },
        { type: i1.AuthService }
    ]; };

    var UpdateEmailModule = /** @class */ (function () {
        function UpdateEmailModule() {
        }
        return UpdateEmailModule;
    }());
    UpdateEmailModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        SpinnerModule,
                        i1.I18nModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                UpdateEmailComponent: {
                                    component: UpdateEmailComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [UpdateEmailFormComponent, UpdateEmailComponent],
                    exports: [UpdateEmailComponent, UpdateEmailFormComponent],
                    entryComponents: [UpdateEmailComponent],
                },] }
    ];

    var UpdatePasswordFormComponent = /** @class */ (function () {
        function UpdatePasswordFormComponent(fb) {
            this.fb = fb;
            this.submitted = new i0.EventEmitter();
            this.cancelled = new i0.EventEmitter();
        }
        UpdatePasswordFormComponent.prototype.ngOnInit = function () {
            this.updatePasswordForm = this.fb.group({
                oldPassword: ['', [forms.Validators.required]],
                newPassword: [
                    '',
                    [forms.Validators.required, CustomFormValidators.passwordValidator],
                ],
                newPasswordConfirm: ['', [forms.Validators.required]],
            }, {
                validators: CustomFormValidators.passwordsMustMatch('newPassword', 'newPasswordConfirm'),
            });
        };
        UpdatePasswordFormComponent.prototype.onSubmit = function () {
            if (this.updatePasswordForm.valid) {
                this.submitted.emit({
                    oldPassword: this.updatePasswordForm.value.oldPassword,
                    newPassword: this.updatePasswordForm.value.newPassword,
                });
            }
            else {
                this.updatePasswordForm.markAllAsTouched();
            }
        };
        UpdatePasswordFormComponent.prototype.onCancel = function () {
            this.cancelled.emit();
        };
        return UpdatePasswordFormComponent;
    }());
    UpdatePasswordFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-update-password-form',
                    template: "<form\n  (ngSubmit)=\"onSubmit()\"\n  [formGroup]=\"updatePasswordForm\"\n  class=\"cx-update-password-component\"\n>\n  <div class=\"form-group row\">\n    <div class=\"col-md-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updatePasswordForm.oldPassword.label' | cxTranslate\n        }}</span>\n        <input\n          class=\"form-control\"\n          type=\"password\"\n          name=\"oldPassword\"\n          placeholder=\"{{\n            'updatePasswordForm.oldPassword.placeholder' | cxTranslate\n          }}\"\n          formControlName=\"oldPassword\"\n        />\n        <cx-form-errors\n          [control]=\"updatePasswordForm.get('oldPassword')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n  <div class=\"form-group row\">\n    <div class=\"col-md-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updatePasswordForm.newPassword.label' | cxTranslate\n        }}</span>\n        <input\n          class=\"form-control\"\n          type=\"password\"\n          name=\"newPassword\"\n          placeholder=\"{{\n            'updatePasswordForm.newPassword.placeholder' | cxTranslate\n          }}\"\n          formControlName=\"newPassword\"\n        />\n        <cx-form-errors\n          [control]=\"updatePasswordForm.get('newPassword')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n  <div class=\"form-group row\">\n    <div class=\"col-md-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updatePasswordForm.confirmPassword.label' | cxTranslate\n        }}</span>\n        <input\n          class=\"form-control\"\n          type=\"password\"\n          name=\"newPasswordConfirm\"\n          placeholder=\"{{\n            'updatePasswordForm.confirmPassword.placeholder' | cxTranslate\n          }}\"\n          formControlName=\"newPasswordConfirm\"\n        />\n        <cx-form-errors\n          [control]=\"updatePasswordForm.get('newPasswordConfirm')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n  <div class=\"form-group row\">\n    <div class=\"col-lg-6 col-md-12\">\n      <button\n        class=\"btn btn-block btn-secondary\"\n        type=\"button\"\n        (click)=\"onCancel()\"\n      >\n        {{ 'common.cancel' | cxTranslate }}\n      </button>\n    </div>\n    <div class=\"col-lg-6 col-md-12\">\n      <button class=\"btn btn-block btn-primary\" type=\"submit\">\n        {{ 'common.save' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</form>\n"
                },] }
    ];
    UpdatePasswordFormComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    UpdatePasswordFormComponent.propDecorators = {
        submitted: [{ type: i0.Output }],
        cancelled: [{ type: i0.Output }]
    };

    var UpdatePasswordComponent = /** @class */ (function () {
        function UpdatePasswordComponent(routingService, userService, globalMessageService) {
            this.routingService = routingService;
            this.userService = userService;
            this.globalMessageService = globalMessageService;
            this.subscription = new rxjs.Subscription();
        }
        UpdatePasswordComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.userService.resetUpdatePasswordProcessState();
            this.loading$ = this.userService.getUpdatePasswordResultLoading();
            this.subscription.add(this.userService
                .getUpdatePasswordResultSuccess()
                .subscribe(function (success) { return _this.onSuccess(success); }));
        };
        UpdatePasswordComponent.prototype.onSuccess = function (success) {
            if (success) {
                this.globalMessageService.add({ key: 'updatePasswordForm.passwordUpdateSuccess' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                this.routingService.go({ cxRoute: 'home' });
            }
        };
        UpdatePasswordComponent.prototype.onCancel = function () {
            this.routingService.go({ cxRoute: 'home' });
        };
        UpdatePasswordComponent.prototype.onSubmit = function (_a) {
            var oldPassword = _a.oldPassword, newPassword = _a.newPassword;
            this.userService.updatePassword(oldPassword, newPassword);
        };
        UpdatePasswordComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.userService.resetUpdatePasswordProcessState();
        };
        return UpdatePasswordComponent;
    }());
    UpdatePasswordComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-update-password',
                    template: "<ng-container>\n  <div *ngIf=\"loading$ | async; else updateForm\">\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n\n  <ng-template #updateForm>\n    <div class=\"container\">\n      <div class=\"row d-flex justify-content-center\">\n        <cx-update-password-form\n          class=\"col-md-6\"\n          (cancelled)=\"onCancel()\"\n          (submitted)=\"onSubmit($event)\"\n        ></cx-update-password-form>\n      </div>\n    </div>\n  </ng-template>\n</ng-container>\n"
                },] }
    ];
    UpdatePasswordComponent.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.UserService },
        { type: i1.GlobalMessageService }
    ]; };

    var UpdatePasswordModule = /** @class */ (function () {
        function UpdatePasswordModule() {
        }
        return UpdatePasswordModule;
    }());
    UpdatePasswordModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        SpinnerModule,
                        i1.I18nModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                UpdatePasswordComponent: {
                                    component: UpdatePasswordComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [UpdatePasswordComponent, UpdatePasswordFormComponent],
                    exports: [UpdatePasswordComponent, UpdatePasswordFormComponent],
                    entryComponents: [UpdatePasswordComponent],
                },] }
    ];

    var UpdateProfileFormComponent = /** @class */ (function () {
        function UpdateProfileFormComponent(fb) {
            this.fb = fb;
            this.submitted = new i0.EventEmitter();
            this.cancelled = new i0.EventEmitter();
            this.updateProfileForm = this.fb.group({
                titleCode: [''],
                firstName: ['', forms.Validators.required],
                lastName: ['', forms.Validators.required],
            });
        }
        UpdateProfileFormComponent.prototype.ngOnInit = function () {
            if (this.user) {
                this.updateProfileForm.patchValue(this.user);
            }
        };
        UpdateProfileFormComponent.prototype.onSubmit = function () {
            if (this.updateProfileForm.valid) {
                this.submitted.emit({
                    userUpdates: Object.assign({}, this.updateProfileForm.value),
                });
            }
            else {
                this.updateProfileForm.markAllAsTouched();
            }
        };
        UpdateProfileFormComponent.prototype.onCancel = function () {
            this.cancelled.emit();
        };
        return UpdateProfileFormComponent;
    }());
    UpdateProfileFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-update-profile-form',
                    template: "<form (ngSubmit)=\"onSubmit()\" [formGroup]=\"updateProfileForm\">\n  <div class=\"form-group row\">\n    <div class=\"col-md-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updateProfileForm.title' | cxTranslate\n        }}</span>\n        <select formControlName=\"titleCode\" class=\"form-control\">\n          <option value=\"\">{{ 'updateProfileForm.none' | cxTranslate }}</option>\n          <option *ngFor=\"let title of titles\" [value]=\"title.code\">\n            {{ title.name }}\n          </option>\n        </select>\n      </label>\n    </div>\n  </div>\n  <div class=\"form-group row\">\n    <div class=\"col-md-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updateProfileForm.firstName.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"text\"\n          class=\"form-control\"\n          name=\"firstName\"\n          placeholder=\"{{\n            'updateProfileForm.firstName.placeholder' | cxTranslate\n          }}\"\n          formControlName=\"firstName\"\n        />\n        <cx-form-errors\n          [control]=\"updateProfileForm.get('firstName')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n  <div class=\"form-group row\">\n    <div class=\"col-md-12\">\n      <label>\n        <span class=\"label-content\">{{\n          'updateProfileForm.lastName.label' | cxTranslate\n        }}</span>\n        <input\n          type=\"text\"\n          class=\"form-control\"\n          name=\"lastName\"\n          placeholder=\"{{\n            'updateProfileForm.lastName.placeholder' | cxTranslate\n          }}\"\n          formControlName=\"lastName\"\n        />\n        <cx-form-errors\n          [control]=\"updateProfileForm.get('lastName')\"\n        ></cx-form-errors>\n      </label>\n    </div>\n  </div>\n\n  <div class=\"form-group row\">\n    <div class=\"col-lg-6 col-md-12\">\n      <button\n        class=\"btn btn-block btn-secondary\"\n        type=\"button\"\n        (click)=\"onCancel()\"\n      >\n        {{ 'common.cancel' | cxTranslate }}\n      </button>\n    </div>\n    <div class=\"col-lg-6 col-md-12\">\n      <button class=\"btn btn-block btn-primary\" type=\"submit\">\n        {{ 'common.save' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</form>\n"
                },] }
    ];
    UpdateProfileFormComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    UpdateProfileFormComponent.propDecorators = {
        user: [{ type: i0.Input }],
        titles: [{ type: i0.Input }],
        submitted: [{ type: i0.Output }],
        cancelled: [{ type: i0.Output }]
    };

    var UpdateProfileComponent = /** @class */ (function () {
        function UpdateProfileComponent(routingService, userService, globalMessageService) {
            this.routingService = routingService;
            this.userService = userService;
            this.globalMessageService = globalMessageService;
            this.subscription = new rxjs.Subscription();
        }
        UpdateProfileComponent.prototype.ngOnInit = function () {
            var _this = this;
            // reset the previous form processing state
            this.userService.resetUpdatePersonalDetailsProcessingState();
            this.user$ = this.userService.get();
            this.titles$ = this.userService.getTitles();
            this.loading$ = this.userService.getUpdatePersonalDetailsResultLoading();
            this.subscription.add(this.userService
                .getUpdatePersonalDetailsResultSuccess()
                .subscribe(function (success) { return _this.onSuccess(success); }));
        };
        UpdateProfileComponent.prototype.onSuccess = function (success) {
            if (success) {
                this.globalMessageService.add({ key: 'updateProfileForm.profileUpdateSuccess' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                this.routingService.go({ cxRoute: 'home' });
            }
        };
        UpdateProfileComponent.prototype.onCancel = function () {
            this.routingService.go({ cxRoute: 'home' });
        };
        UpdateProfileComponent.prototype.onSubmit = function (_a) {
            var userUpdates = _a.userUpdates;
            this.userService.updatePersonalDetails(userUpdates);
        };
        UpdateProfileComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            // clean up the state
            this.userService.resetUpdatePersonalDetailsProcessingState();
        };
        return UpdateProfileComponent;
    }());
    UpdateProfileComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-update-profile',
                    template: "<ng-container>\n  <div *ngIf=\"loading$ | async; else updateForm\">\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n\n  <ng-template #updateForm>\n    <div class=\"container\">\n      <div class=\"row d-flex justify-content-center\">\n        <cx-update-profile-form\n          *ngIf=\"(user$ | async)?.uid\"\n          class=\"col-md-6\"\n          [user]=\"user$ | async\"\n          [titles]=\"titles$ | async\"\n          (cancelled)=\"onCancel()\"\n          (submitted)=\"onSubmit($event)\"\n        ></cx-update-profile-form>\n      </div>\n    </div>\n  </ng-template>\n</ng-container>\n"
                },] }
    ];
    UpdateProfileComponent.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.UserService },
        { type: i1.GlobalMessageService }
    ]; };

    var UpdateProfileModule = /** @class */ (function () {
        function UpdateProfileModule() {
        }
        return UpdateProfileModule;
    }());
    UpdateProfileModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        SpinnerModule,
                        i1.I18nModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                UpdateProfileComponent: {
                                    component: UpdateProfileComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [UpdateProfileComponent, UpdateProfileFormComponent],
                    exports: [UpdateProfileComponent, UpdateProfileFormComponent],
                    entryComponents: [UpdateProfileComponent],
                },] }
    ];

    var MyCouponsComponentService = /** @class */ (function () {
        function MyCouponsComponentService(routingService, translation) {
            this.routingService = routingService;
            this.translation = translation;
            this.RELEVANCE = ':relevance';
            this.CUSTOMER_COUPON_CODE = ':customerCouponCode:';
        }
        MyCouponsComponentService.prototype.launchSearchPage = function (coupon) {
            this.routingService.go({
                cxRoute: 'search',
                params: { query: this.buildSearchParam(coupon) },
            }, { couponcode: coupon.couponId });
        };
        MyCouponsComponentService.prototype.buildSearchParam = function (coupon) {
            return coupon.allProductsApplicable
                ? this.RELEVANCE
                : this.RELEVANCE + this.CUSTOMER_COUPON_CODE + coupon.couponId;
        };
        MyCouponsComponentService.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translation.translate('myCoupons.startDateAsc'),
                this.translation.translate('myCoupons.startDateDesc'),
                this.translation.translate('myCoupons.endDateAsc'),
                this.translation.translate('myCoupons.endDateDesc'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 4), textByStartDateAsc = _b[0], textByStartDateDesc = _b[1], textByEndDateAsc = _b[2], textByEndDateDesc = _b[3];
                return {
                    byStartDateAsc: textByStartDateAsc,
                    byStartDateDesc: textByStartDateDesc,
                    byEndDateAsc: textByEndDateAsc,
                    byEndDateDesc: textByEndDateDesc,
                };
            }));
        };
        return MyCouponsComponentService;
    }());
    MyCouponsComponentService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MyCouponsComponentService_Factory() { return new MyCouponsComponentService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.TranslationService)); }, token: MyCouponsComponentService, providedIn: "root" });
    MyCouponsComponentService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    MyCouponsComponentService.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: i1.TranslationService }
    ]; };

    var MyCouponsComponent = /** @class */ (function () {
        function MyCouponsComponent(couponService, myCouponsComponentService) {
            this.couponService = couponService;
            this.myCouponsComponentService = myCouponsComponentService;
            this.iconTypes = exports.ICON_TYPE;
            this.subscriptions = new rxjs.Subscription();
            this.PAGE_SIZE = 10;
            this.sortMapping = {
                byStartDateAsc: 'startDate:asc',
                byStartDateDesc: 'startDate:desc',
                byEndDateAsc: 'endDate:asc',
                byEndDateDesc: 'endDate:desc',
            };
            this.sort = 'byStartDateAsc';
            this.sortOptions = [
                {
                    code: 'byStartDateAsc',
                    selected: false,
                },
                {
                    code: 'byStartDateDesc',
                    selected: false,
                },
                {
                    code: 'byEndDateAsc',
                    selected: false,
                },
                {
                    code: 'byEndDateDesc',
                    selected: false,
                },
            ];
        }
        MyCouponsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.couponResult$ = this.couponService
                .getCustomerCoupons(this.PAGE_SIZE)
                .pipe(operators.tap(function (coupons) { return (_this.pagination = {
                currentPage: coupons.pagination.page,
                pageSize: coupons.pagination.count,
                totalPages: coupons.pagination.totalPages,
                totalResults: coupons.pagination.totalCount,
                sort: _this.sort,
            }); }));
            this.couponsLoading$ = this.couponService.getCustomerCouponsLoading();
            this.couponSubscriptionLoading$ = rxjs.combineLatest([
                this.couponService.getSubscribeCustomerCouponResultLoading(),
                this.couponService.getUnsubscribeCustomerCouponResultLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), subscribing = _b[0], unsubscribing = _b[1];
                return subscribing || unsubscribing;
            }));
            this.sortLabels = this.myCouponsComponentService.getSortLabels();
            this.subscriptions
                .add(this.couponService
                .getSubscribeCustomerCouponResultError()
                .subscribe(function (error) {
                _this.subscriptionFail(error);
            }))
                .add(this.couponService
                .getUnsubscribeCustomerCouponResultError()
                .subscribe(function (error) {
                _this.subscriptionFail(error);
            }));
        };
        MyCouponsComponent.prototype.subscriptionFail = function (error) {
            if (error) {
                this.couponService.loadCustomerCoupons(this.PAGE_SIZE);
            }
        };
        MyCouponsComponent.prototype.sortChange = function (sort) {
            this.sort = sort;
            this.couponService.loadCustomerCoupons(this.PAGE_SIZE, this.pagination.currentPage, this.sortMapping[sort]);
        };
        MyCouponsComponent.prototype.pageChange = function (page) {
            this.couponService.loadCustomerCoupons(this.PAGE_SIZE, page, this.sortMapping[this.sort]);
        };
        MyCouponsComponent.prototype.notificationChange = function (_a) {
            var couponId = _a.couponId, notification = _a.notification;
            if (notification) {
                this.couponService.subscribeCustomerCoupon(couponId);
            }
            else {
                this.couponService.unsubscribeCustomerCoupon(couponId);
            }
        };
        MyCouponsComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
        };
        return MyCouponsComponent;
    }());
    MyCouponsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-my-coupons',
                    template: "<div class=\"cx-section\">\n  <ng-container *ngIf=\"!(couponsLoading$ | async); else loading\">\n    <ng-container *ngIf=\"couponResult$ | async as couponResult\">\n      <div class=\"cx-my-coupons-header\">\n        <h3>{{ 'myCoupons.myCoupons' | cxTranslate }}</h3>\n      </div>\n\n      <ng-container\n        *ngIf=\"couponResult.pagination.totalCount > 0; else noCoupons\"\n      >\n        <div class=\"cx-my-coupons-sort top row\">\n          <div\n            class=\"cx-my-coupons-form-group form-group col-sm-12 col-md-4 col-lg-4\"\n          >\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n            >\n            </cx-sorting>\n          </div>\n          <div class=\"cx-my-coupons-pagination cx-mycoupon-thead-mobile\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n\n        <div class=\"row cx-coupon-deck\">\n          <div\n            *ngFor=\"let coupon of couponResult.coupons\"\n            class=\"col-md-6 cx-coupon-card\"\n          >\n            <cx-coupon-card\n              [coupon]=\"coupon\"\n              [couponSubscriptionLoading$]=\"couponSubscriptionLoading$\"\n              (notificationChanged)=\"notificationChange($event)\"\n            ></cx-coupon-card>\n          </div>\n        </div>\n\n        <div class=\"cx-my-coupons-sort bottom row\">\n          <div\n            class=\"cx-my-coupons-form-group form-group cx-mycoupon-thead-mobile col-sm-12 col-md-4 col-lg-4\"\n          >\n            <cx-sorting\n              [sortOptions]=\"sortOptions\"\n              [sortLabels]=\"sortLabels | async\"\n              (sortListEvent)=\"sortChange($event)\"\n              [selectedOption]=\"sort\"\n              placeholder=\"{{ 'myCoupons.sortByMostRecent' | cxTranslate }}\"\n            >\n            </cx-sorting>\n          </div>\n          <div class=\"cx-my-coupons-pagination\">\n            <cx-pagination\n              [pagination]=\"pagination\"\n              (viewPageEvent)=\"pageChange($event)\"\n            ></cx-pagination>\n          </div>\n        </div>\n        <div class=\"cx-my-coupons-notes\">\n          <span>\n            <cx-icon [type]=\"iconTypes.INFO\"></cx-icon>\n            {{ 'myCoupons.notesPreffix' | cxTranslate\n            }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n              'myCoupons.notesLink' | cxTranslate\n            }}</a\n            >{{ 'myCoupons.notesSuffix' | cxTranslate }}</span\n          >\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <ng-template #noCoupons>\n      <section>\n        <p class=\"cx-section-msg\">\n          {{ 'myCoupons.noCouponsMessage' | cxTranslate }}\n        </p>\n      </section>\n    </ng-template>\n  </ng-container>\n\n  <ng-template #loading>\n    <div class=\"col-md-12 cx-coupon-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</div>\n"
                },] }
    ];
    MyCouponsComponent.ctorParameters = function () { return [
        { type: i1.CustomerCouponService },
        { type: MyCouponsComponentService }
    ]; };

    var CouponDialogComponent = /** @class */ (function () {
        function CouponDialogComponent(modalService) {
            this.modalService = modalService;
            this.iconTypes = exports.ICON_TYPE;
        }
        CouponDialogComponent.prototype.dismissModal = function (reason) {
            this.modalService.dismissActiveModal(reason);
        };
        return CouponDialogComponent;
    }());
    CouponDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-coupon-dialog',
                    template: "<div #dialog>\n  <!-- Modal Header -->\n\n  <div class=\"cx-dialog-header modal-header\">\n    <div class=\"cx-dialog-title modal-title\">\n      {{ 'myCoupons.dialogTitle' | cxTranslate }}\n    </div>\n    <button\n      type=\"button\"\n      class=\"close\"\n      aria-label=\"Close\"\n      (click)=\"dismissModal('Cross click')\"\n    >\n      <span aria-hidden=\"true\">\n        <cx-icon [type]=\"iconTypes.CLOSE\"></cx-icon>\n      </span>\n    </button>\n  </div>\n  <!-- Modal Body -->\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"cx-dialog-item col-sm-12 col-md-12\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n        <div class=\"cx-coupon-description\">{{ coupon?.description }}</div>\n\n        <div class=\"cx-coupon-dialog-date\">\n          <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n          <div class=\"cx-coupon-date\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n\n        <div class=\"cx-coupon-dialog-status\">\n          <p>{{ 'myCoupons.status' | cxTranslate }}</p>\n          <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n            {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    CouponDialogComponent.ctorParameters = function () { return [
        { type: ModalService }
    ]; };
    CouponDialogComponent.propDecorators = {
        dialog: [{ type: i0.ViewChild, args: ['dialog', { read: i0.ElementRef },] }]
    };

    var CouponCardComponent = /** @class */ (function () {
        function CouponCardComponent(modalService, myCouponsComponentService) {
            this.modalService = modalService;
            this.myCouponsComponentService = myCouponsComponentService;
            this.notificationChanged = new i0.EventEmitter();
        }
        CouponCardComponent.prototype.onSubscriptionChange = function () {
            this.notificationChanged.emit({
                couponId: this.coupon.couponId,
                notification: !this.coupon.notificationOn,
            });
        };
        CouponCardComponent.prototype.readMore = function () {
            var modalInstance;
            this.modalRef = this.modalService.open(CouponDialogComponent, {
                centered: true,
                size: 'lg',
            });
            modalInstance = this.modalRef.componentInstance;
            modalInstance.coupon = this.coupon;
        };
        CouponCardComponent.prototype.findProducts = function () {
            this.myCouponsComponentService.launchSearchPage(this.coupon);
        };
        return CouponCardComponent;
    }());
    CouponCardComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-coupon-card',
                    template: "<div class=\"card\">\n  <div class=\"card-body cx-card-body\">\n    <div class=\"cx-coupon-data\">\n      <div class=\"cx-coupon-card-row top\">\n        <div class=\"cx-coupon-card-head\">\n          <span class=\"card-label-bold cx-coupon-card-id\">{{\n            coupon?.couponId\n          }}</span>\n          <span>: {{ coupon?.name }}</span>\n        </div>\n\n        <div class=\"cx-coupon-status {{ coupon?.status | lowercase }}\">\n          {{ 'myCoupons.' + coupon?.status | cxTranslate }}\n        </div>\n      </div>\n\n      <div class=\"cx-coupon-card-date\">\n        <p>{{ 'myCoupons.effectiveTitle' | cxTranslate }}</p>\n        <div class=\"cx-coupon-date\">\n          <div class=\"cx-coupon-date-start\">\n            {{ coupon?.startDate | cxDate: 'medium' }} -&nbsp;\n          </div>\n          <div class=\"cx-coupon-date-end\">\n            {{ coupon?.endDate | cxDate: 'medium' }}\n          </div>\n        </div>\n      </div>\n\n      <a (click)=\"readMore()\" class=\"cx-card-read-more\">{{\n        'myCoupons.readMore' | cxTranslate\n      }}</a>\n\n      <div class=\"cx-coupon-card-row bottom\">\n        <div class=\"cx-coupon-notification form-check\">\n          <label>\n            <input\n              type=\"checkbox\"\n              class=\"form-check-input\"\n              [checked]=\"coupon?.notificationOn\"\n              [class.disabled]=\"couponSubscriptionLoading$ | async\"\n              [disabled]=\"couponSubscriptionLoading$ | async\"\n              (change)=\"onSubscriptionChange()\"\n            />\n            <span class=\"form-check-label\">\n              {{ 'myCoupons.notification' | cxTranslate }}\n            </span>\n          </label>\n        </div>\n\n        <div class=\"cx-coupon-find-product col-lg-6 col-md-12 col-sm-6\">\n          <button class=\"btn btn-block btn-action\" (click)=\"findProducts()\">\n            {{ 'myCoupons.findProducts' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    CouponCardComponent.ctorParameters = function () { return [
        { type: ModalService },
        { type: MyCouponsComponentService }
    ]; };
    CouponCardComponent.propDecorators = {
        coupon: [{ type: i0.Input }],
        couponSubscriptionLoading$: [{ type: i0.Input }],
        notificationChanged: [{ type: i0.Output }]
    };

    var CouponClaimComponent = /** @class */ (function () {
        function CouponClaimComponent(couponService, routingService, messageService) {
            this.couponService = couponService;
            this.routingService = routingService;
            this.messageService = messageService;
        }
        CouponClaimComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.routingService
                .getRouterState()
                .subscribe(function (k) {
                var couponCode = k.state.params.couponCode;
                if (couponCode) {
                    _this.couponService.claimCustomerCoupon(couponCode);
                    _this.subscription = _this.couponService
                        .getClaimCustomerCouponResultSuccess()
                        .subscribe(function (success) {
                        if (success) {
                            _this.messageService.add({ key: 'myCoupons.claimCustomerCoupon' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
                        }
                        _this.routingService.go({ cxRoute: 'coupons' });
                    });
                }
                else {
                    _this.routingService.go({ cxRoute: 'notFound' });
                }
            })
                .unsubscribe();
        };
        CouponClaimComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return CouponClaimComponent;
    }());
    CouponClaimComponent.decorators = [
        { type: i0.Component, args: [{
                    template: "",
                    selector: 'cx-coupon-claim'
                },] }
    ];
    CouponClaimComponent.ctorParameters = function () { return [
        { type: i1.CustomerCouponService },
        { type: i1.RoutingService },
        { type: i1.GlobalMessageService }
    ]; };

    var ɵ0$a = { cxRoute: 'couponClaim' };
    var MyCouponsModule = /** @class */ (function () {
        function MyCouponsModule() {
        }
        return MyCouponsModule;
    }());
    MyCouponsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        CardModule,
                        SpinnerModule,
                        i1.I18nModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        IconModule,
                        ListNavigationModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [i1.AuthGuard, CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$a,
                            },
                        ]),
                    ],
                    declarations: [
                        MyCouponsComponent,
                        CouponCardComponent,
                        CouponDialogComponent,
                        CouponClaimComponent,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                MyCouponsComponent: {
                                    component: MyCouponsComponent,
                                    guards: [i1.AuthGuard],
                                },
                                CouponClaimComponent: {
                                    component: CouponClaimComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [MyCouponsComponent, CouponClaimComponent],
                    entryComponents: [
                        MyCouponsComponent,
                        CouponDialogComponent,
                        CouponClaimComponent,
                    ],
                },] }
    ];

    var NotificationPreferenceComponent = /** @class */ (function () {
        function NotificationPreferenceComponent(notificationPreferenceService) {
            this.notificationPreferenceService = notificationPreferenceService;
            this.preferences = [];
        }
        NotificationPreferenceComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.notificationPreferenceService.resetNotificationPreferences();
            this.preferences$ = this.notificationPreferenceService
                .getPreferences()
                .pipe(operators.tap(function (preferences) { return (_this.preferences = preferences); }));
            this.notificationPreferenceService.loadPreferences();
            this.isLoading$ = rxjs.combineLatest([
                this.notificationPreferenceService.getPreferencesLoading(),
                this.notificationPreferenceService.getUpdatePreferencesResultLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), prefsLoading = _b[0], updateLoading = _b[1];
                return prefsLoading || updateLoading;
            }));
        };
        NotificationPreferenceComponent.prototype.updatePreference = function (preference) {
            var updatedPreferences = [];
            this.preferences.forEach(function (p) {
                if (p.channel === preference.channel) {
                    updatedPreferences.push(Object.assign(Object.assign({}, p), { enabled: !p.enabled }));
                }
                else {
                    updatedPreferences.push(p);
                }
            });
            this.notificationPreferenceService.updatePreferences(updatedPreferences);
        };
        return NotificationPreferenceComponent;
    }());
    NotificationPreferenceComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-notification-preference',
                    template: "<ng-container *ngIf=\"preferences$ | async as preferences\">\n  <div *ngIf=\"preferences.length > 0; else loading\">\n    <div class=\"row d-flex justify-content-center\">\n      <div class=\"col-md-8\">\n        <div class=\"pref-header\">\n          {{ 'notificationPreference.message' | cxTranslate }}\n        </div>\n        <div class=\"form-check cx-notification-channels\">\n          <ng-container *ngFor=\"let preference of preferences\">\n            <label *ngIf=\"preference.visible\" class=\"pref-channel\">\n              <input\n                class=\"form-check-input cx-np-checkbox\"\n                role=\"checkbox\"\n                type=\"checkbox\"\n                [checked]=\"preference.enabled\"\n                (change)=\"updatePreference(preference)\"\n                [disabled]=\"isLoading$ | async\"\n              />\n              <span class=\"form-check-label\">\n                {{\n                  'notificationPreference.' + preference.channel | cxTranslate\n                }}\n                {{ preference.value }}\n              </span>\n            </label>\n          </ng-container>\n        </div>\n        <label class=\"pref-note\"\n          ><strong>{{ 'notificationPreference.note' | cxTranslate }}</strong\n          >{{ 'notificationPreference.noteMessage' | cxTranslate }}\n        </label>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #loading>\n    <div class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </ng-template>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NotificationPreferenceComponent.ctorParameters = function () { return [
        { type: i1.UserNotificationPreferenceService }
    ]; };

    var NotificationPreferenceModule = /** @class */ (function () {
        function NotificationPreferenceModule() {
        }
        return NotificationPreferenceModule;
    }());
    NotificationPreferenceModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [NotificationPreferenceComponent],
                    imports: [i1$1.CommonModule, SpinnerModule, i1.I18nModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                NotificationPreferenceComponent: {
                                    component: NotificationPreferenceComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [NotificationPreferenceComponent],
                    entryComponents: [NotificationPreferenceComponent],
                },] }
    ];

    var MyInterestsComponent = /** @class */ (function () {
        function MyInterestsComponent(productInterestService, translationService, productService) {
            this.productInterestService = productInterestService;
            this.translationService = translationService;
            this.productService = productService;
            this.DEFAULT_PAGE_SIZE = 10;
            this.sortMapping = {
                byNameAsc: 'name:asc',
                byNameDesc: 'name:desc',
            };
            this.sort = 'byNameAsc';
            this.sortOptions = [
                {
                    code: 'byNameAsc',
                    selected: false,
                },
                {
                    code: 'byNameDesc',
                    selected: false,
                },
            ];
        }
        MyInterestsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.interests$ = this.productInterestService
                .getAndLoadProductInterests(this.DEFAULT_PAGE_SIZE)
                .pipe(operators.tap(function (interests) { return (_this.pagination = {
                currentPage: interests.pagination.page,
                pageSize: interests.pagination.count,
                totalPages: interests.pagination.totalPages,
                totalResults: interests.pagination.totalCount,
                sort: 'byNameAsc',
            }); }), operators.map(function (interest) { return (Object.assign(Object.assign({}, interest), { results: interest.results
                    ? interest.results.map(function (result) { return (Object.assign(Object.assign({}, result), { product$: _this.getProduct(result) })); })
                    : interest.results })); }));
            this.getInterestsloading$ = this.productInterestService.getProdutInterestsLoading();
            this.isRemoveDisabled$ = rxjs.combineLatest([
                this.getInterestsloading$,
                this.productInterestService.getRemoveProdutInterestLoading(),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), getLoading = _b[0], removeLoading = _b[1];
                return getLoading || removeLoading;
            }));
            this.sortLabels = this.getSortLabels();
        };
        MyInterestsComponent.prototype.getSortLabels = function () {
            return rxjs.combineLatest([
                this.translationService.translate('myInterests.sorting.byNameAsc'),
                this.translationService.translate('myInterests.sorting.byNameDesc'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), asc = _b[0], desc = _b[1];
                return {
                    byNameAsc: asc,
                    byNameDesc: desc,
                };
            }));
        };
        MyInterestsComponent.prototype.getProduct = function (interest) {
            return this.productService.get(interest.product.code, i1.ProductScope.DETAILS);
        };
        MyInterestsComponent.prototype.removeInterest = function (relation) {
            this.productInterestService.removeProdutInterest({
                product: relation.product,
                productInterestEntry: relation.productInterestEntry,
            });
        };
        MyInterestsComponent.prototype.sortChange = function (sort) {
            this.sort = sort;
            this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, 0, this.sortMapping[sort]);
        };
        MyInterestsComponent.prototype.pageChange = function (page) {
            this.productInterestService.loadProductInterests(this.DEFAULT_PAGE_SIZE, page, this.sortMapping[this.sort]);
        };
        MyInterestsComponent.prototype.ngOnDestroy = function () {
            this.productInterestService.clearProductInterests();
            this.productInterestService.resetRemoveInterestState();
        };
        return MyInterestsComponent;
    }());
    MyInterestsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-my-interests',
                    template: "<div *ngIf=\"interests$ | async as interests\" class=\"container\">\n  <div class=\"cx-product-interests-title h3\">\n    <h3>{{ 'myInterests.header' | cxTranslate }}</h3>\n  </div>\n  <div\n    class=\"cx-product-interests-body\"\n    *ngIf=\"!(getInterestsloading$ | async); else loading\"\n  >\n    <ng-container *ngIf=\"interests.pagination.totalCount > 0; else noInterest\">\n      <div class=\"cx-product-interests-sort top row\">\n        <div\n          class=\"cx-product-interests-form-group form-group col-sm-12 col-md-4 col-lg-4\"\n        >\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortByMostRecent' | cxTranslate }}\"\n          >\n          </cx-sorting>\n        </div>\n        <div\n          class=\"cx-product-interests-pagination cx-product-interests-thead-mobile\"\n        >\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n      <table class=\"table cx-product-interests-table\">\n        <thead class=\"cx-product-interests-thead-mobile\">\n          <th scope=\"col\">\n            {{ 'myInterests.item' | cxTranslate }}\n          </th>\n          <th scope=\"col\"></th>\n          <th scope=\"col\">\n            {{ 'myInterests.price' | cxTranslate }}\n          </th>\n          <th scope=\"col\">\n            {{ 'myInterests.notifications' | cxTranslate }}\n          </th>\n          <th scope=\"col\"></th>\n        </thead>\n        <tbody>\n          <tr\n            *ngFor=\"let interest of interests.results\"\n            class=\"cx-product-interests-product-item\"\n          >\n            <ng-container *ngIf=\"interest.product$ | async as product\">\n              <td>\n                <div class=\"cx-product-interests-label\">\n                  <a\n                    class=\"cx-product-interests-product-image-link\"\n                    tabindex=\"-1\"\n                    [routerLink]=\"\n                      { cxRoute: 'product', params: product } | cxUrl\n                    \"\n                  >\n                    <cx-media [container]=\"product.images?.PRIMARY\"></cx-media>\n                  </a>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-info col-10\">\n                  <div class=\"cx-info-container row\">\n                    <div>\n                      <div *ngIf=\"product.name\" class=\"cx-name\">\n                        <a\n                          class=\"cx-link cx-product-interests-product-code-link\"\n                          [routerLink]=\"\n                            { cxRoute: 'product', params: product } | cxUrl\n                          \"\n                        >\n                          {{ product.name }}\n                        </a>\n                      </div>\n                      <div *ngIf=\"product.code\" class=\"cx-code\">\n                        <span>{{\n                          'myInterests.productId'\n                            | cxTranslate: { code: product.code }\n                        }}</span>\n                      </div>\n\n                      <ng-container\n                        *ngFor=\"let baseOptions of product.baseOptions\"\n                      >\n                        <div\n                          *ngFor=\"\n                            let variant of baseOptions.selected\n                              ?.variantOptionQualifiers\n                          \"\n                          class=\"cx-property\"\n                        >\n                          <div\n                            class=\"cx-label cx-product-interests-variant-name\"\n                          >\n                            {{ variant.name }}\n                          </div>\n                          <div\n                            class=\"cx-value cx-product-interests-variant-value\"\n                          >\n                            {{ variant.value }}\n                          </div>\n                        </div>\n                      </ng-container>\n                      <div\n                        class=\"cx-property\"\n                        *ngIf=\"product.stock.stockLevelStatus === 'outOfStock'\"\n                      >\n                        <div\n                          class=\"cx-label cx-product-interests-product-stock\"\n                        >\n                          {{ 'myInterests.outOfStock' | cxTranslate }}\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-product-interests-product-price\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.price' | cxTranslate }}\n                  </div>\n                  <span>{{ product.price.formattedValue }}</span>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-product-interests-subscriptions\">\n                  <div class=\"d-md-none cx-product-interests-label\">\n                    {{ 'myInterests.notifications' | cxTranslate }}\n                  </div>\n                  <div\n                    class=\"cx-product-interests-notification\"\n                    *ngFor=\"let interestEntry of interest.productInterestEntry\"\n                  >\n                    <span class=\"cx-product-interests-type\">\n                      {{\n                        'myInterests.' + interestEntry.interestType\n                          | cxTranslate\n                      }}\n                    </span>\n                    <span class=\"cx-product-interests-expiration-date\">\n                      {{\n                        'myInterests.expirationDate'\n                          | cxTranslate\n                            : {\n                                expirationDate:\n                                  interestEntry.expirationDate | date\n                              }\n                      }}\n                    </span>\n                  </div>\n                </div>\n              </td>\n              <td>\n                <div class=\"cx-actions cx-product-interests-remove-button\">\n                  <button\n                    type=\"button\"\n                    class=\"link cx-product-interests-remove-btn\"\n                    [disabled]=\"isRemoveDisabled$ | async\"\n                    (click)=\"removeInterest(interest)\"\n                  >\n                    {{ 'myInterests.remove' | cxTranslate }}\n                  </button>\n                </div>\n              </td>\n            </ng-container>\n          </tr>\n        </tbody>\n      </table>\n      <div class=\"cx-product-interests-sort bottom row\">\n        <div\n          class=\"cx-product-interests-form-group cx-product-interests-thead-mobile form-group col-sm-12 col-md-4 col-lg-4\"\n        >\n          <cx-sorting\n            [sortOptions]=\"sortOptions\"\n            [sortLabels]=\"sortLabels | async\"\n            (sortListEvent)=\"sortChange($event)\"\n            [selectedOption]=\"sort\"\n            placeholder=\"{{ 'myInterests.sortByMostRecent' | cxTranslate }}\"\n          >\n          </cx-sorting>\n        </div>\n        <div class=\"cx-product-interests-pagination\">\n          <cx-pagination\n            [pagination]=\"pagination\"\n            (viewPageEvent)=\"pageChange($event)\"\n          ></cx-pagination>\n        </div>\n      </div>\n    </ng-container>\n  </div>\n</div>\n<ng-template #noInterest>\n  <div class=\"cx-product-interests-message\">\n    {{ 'myInterests.noInterests' | cxTranslate }}\n  </div>\n</ng-template>\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    MyInterestsComponent.ctorParameters = function () { return [
        { type: i1.UserInterestsService },
        { type: i1.TranslationService },
        { type: i1.ProductService }
    ]; };

    var MyInterestsModule = /** @class */ (function () {
        function MyInterestsModule() {
        }
        return MyInterestsModule;
    }());
    MyInterestsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [MyInterestsComponent],
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        i4.RouterModule,
                        ListNavigationModule,
                        i1.I18nModule,
                        i1.UrlModule,
                        MediaModule,
                        SpinnerModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                MyInterestsComponent: {
                                    component: MyInterestsComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    exports: [MyInterestsComponent],
                    entryComponents: [MyInterestsComponent],
                },] }
    ];

    var BreadcrumbComponent = /** @class */ (function () {
        function BreadcrumbComponent(component, pageMetaService, translation) {
            this.component = component;
            this.pageMetaService = pageMetaService;
            this.translation = translation;
        }
        BreadcrumbComponent.prototype.ngOnInit = function () {
            this.setTitle();
            this.setCrumbs();
        };
        BreadcrumbComponent.prototype.setTitle = function () {
            this.title$ = this.pageMetaService.getMeta().pipe(operators.filter(Boolean), operators.map(function (meta) { return meta.heading || meta.title; }));
        };
        BreadcrumbComponent.prototype.setCrumbs = function () {
            this.crumbs$ = rxjs.combineLatest([
                this.pageMetaService.getMeta(),
                this.translation.translate('common.home'),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), meta = _b[0], textHome = _b[1];
                return (meta === null || meta === void 0 ? void 0 : meta.breadcrumbs) ? meta.breadcrumbs : [{ label: textHome, link: '/' }];
            }));
        };
        return BreadcrumbComponent;
    }());
    BreadcrumbComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-breadcrumb',
                    template: "<nav>\n  <span *ngFor=\"let crumb of crumbs$ | async\">\n    <a [routerLink]=\"crumb.link\" [innerHTML]=\"crumb.label\"></a>\n  </span>\n</nav>\n<h1>{{ title$ | async }}</h1>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    BreadcrumbComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: i1.PageMetaService },
        { type: i1.TranslationService }
    ]; };

    var BreadcrumbModule = /** @class */ (function () {
        function BreadcrumbModule() {
        }
        return BreadcrumbModule;
    }());
    BreadcrumbModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.CmsPageTitleModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                BreadcrumbComponent: {
                                    component: BreadcrumbComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [BreadcrumbComponent],
                    exports: [BreadcrumbComponent],
                    entryComponents: [BreadcrumbComponent],
                },] }
    ];

    var NavigationService = /** @class */ (function () {
        function NavigationService(cmsService, semanticPathService) {
            this.cmsService = cmsService;
            this.semanticPathService = semanticPathService;
        }
        NavigationService.prototype.createNavigation = function (data$) {
            return rxjs.combineLatest([data$, this.getNavigationNode(data$)]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 2), data = _b[0], nav = _b[1];
                return data
                    ? {
                        title: data.name,
                        children: [nav],
                    }
                    : undefined;
            }));
        };
        /**
         * returns an observable with the `NavigationNode` for the given `CmsNavigationComponent`.
         * This function will load the navigation underlying entries and childs if they haven't been
         * loaded so far.
         */
        NavigationService.prototype.getNavigationNode = function (data$) {
            var _this = this;
            if (!data$) {
                return rxjs.of();
            }
            return data$.pipe(operators.filter(function (data) { return !!data; }), operators.switchMap(function (data) {
                var navigation = data.navigationNode ? data.navigationNode : data;
                return _this.cmsService.getNavigationEntryItems(navigation.uid).pipe(operators.tap(function (items) {
                    if (items === undefined) {
                        _this.loadNavigationEntryItems(navigation, true);
                    }
                    else {
                        // we should check whether the existing node items are what expected
                        var expectedItems = [];
                        _this.loadNavigationEntryItems(navigation, false, expectedItems);
                        var existingItems_1 = Object.keys(items).map(function (key) { return items[key].uid; });
                        var missingItems = expectedItems.filter(function (it) { return !existingItems_1.includes(it.id); });
                        if (missingItems.length > 0) {
                            _this.cmsService.loadNavigationItems(navigation.uid, missingItems);
                        }
                    }
                }), operators.filter(Boolean), operators.map(function (items) { return _this.populateNavigationNode(navigation, items); }));
            }));
        };
        /**
         * Loads all navigation entry items' type and id. Dispatch action to load all these items
         * @param nodeData
         * @param root
         * @param itemsList
         */
        NavigationService.prototype.loadNavigationEntryItems = function (nodeData, root, itemsList) {
            var _this = this;
            if (itemsList === void 0) { itemsList = []; }
            if (nodeData.entries && nodeData.entries.length > 0) {
                nodeData.entries.forEach(function (entry) {
                    itemsList.push({
                        superType: entry.itemSuperType,
                        id: entry.itemId,
                    });
                });
            }
            if (nodeData.children && nodeData.children.length > 0) {
                nodeData.children.forEach(function (child) { return _this.loadNavigationEntryItems(child, false, itemsList); });
            }
            if (root) {
                this.cmsService.loadNavigationItems(nodeData.uid, itemsList);
            }
        };
        /**
         * Create a new node tree for the view
         * @param nodeData
         * @param items
         */
        NavigationService.prototype.populateNavigationNode = function (nodeData, items) {
            var _this = this;
            var node = {};
            if (nodeData.title) {
                // the node title will be populated by the first entry (if any)
                // if there's no nodeData.title available
                node.title = nodeData.title;
            }
            if (nodeData.entries && nodeData.entries.length > 0) {
                this.populateLink(node, nodeData.entries[0], items);
            }
            if (nodeData.children && nodeData.children.length > 0) {
                var children = nodeData.children
                    .map(function (child) { return _this.populateNavigationNode(child, items); })
                    .filter(Boolean);
                if (children.length > 0) {
                    node.children = children;
                }
            }
            // return null in case there are no children
            return Object.keys(node).length === 0 ? null : node;
        };
        /**
         * The node link is driven by the first entry.
         */
        NavigationService.prototype.populateLink = function (node, entry, items) {
            var item = items[entry.itemId + "_" + entry.itemSuperType];
            // now we only consider CMSLinkComponent
            if (item && entry.itemType === 'CMSLinkComponent') {
                if (!node.title) {
                    node.title = item.linkName;
                }
                var url = this.getLink(item);
                // only populate the node link if we have a visible node
                if (node.title && url) {
                    node.url = url;
                    // the backend provide boolean value for the target
                    // in case the link should be opened in a new window
                    node.target = !!item.target ? '_blank' : '';
                }
            }
        };
        /**
         *
         * Gets the URL or link to a related item (category),
         * also taking into account content pages (contentPageLabelOrId)
         * and product pages (productCode)
         */
        NavigationService.prototype.getLink = function (item) {
            if (item.url) {
                return item.url;
            }
            else if (item.contentPageLabelOrId) {
                return item.contentPageLabelOrId;
            }
            else if (item.categoryCode) {
                return this.semanticPathService.transform({
                    cxRoute: 'category',
                    params: {
                        code: item.categoryCode,
                        name: item.name,
                    },
                });
            }
            else if (item.productCode) {
                return this.semanticPathService.transform({
                    cxRoute: 'product',
                    params: {
                        code: item.productCode,
                        name: item.name,
                    },
                });
            }
        };
        return NavigationService;
    }());
    NavigationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NavigationService_Factory() { return new NavigationService(i0.ɵɵinject(i1.CmsService), i0.ɵɵinject(i1.SemanticPathService)); }, token: NavigationService, providedIn: "root" });
    NavigationService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    NavigationService.ctorParameters = function () { return [
        { type: i1.CmsService },
        { type: i1.SemanticPathService }
    ]; };

    var CategoryNavigationComponent = /** @class */ (function () {
        function CategoryNavigationComponent(componentData, service) {
            this.componentData = componentData;
            this.service = service;
            this.node$ = this.service.getNavigationNode(this.componentData.data$);
            this.data$ = this.componentData.data$;
        }
        return CategoryNavigationComponent;
    }());
    CategoryNavigationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-category-navigation',
                    template: "<cx-navigation-ui\n  *ngIf=\"data$ | async as data\"\n  [node]=\"node$ | async\"\n  [ngClass]=\"data.styleClass\"\n  [wrapAfter]=\"data.wrapAfter\"\n></cx-navigation-ui>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CategoryNavigationComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: NavigationService }
    ]; };

    var NavigationUIComponent = /** @class */ (function () {
        function NavigationUIComponent(router, renderer, elemRef) {
            var _this = this;
            this.router = router;
            this.renderer = renderer;
            this.elemRef = elemRef;
            /**
             * the icon type that will be used for navigation nodes
             * with children.
             */
            this.iconType = exports.ICON_TYPE;
            /**
             * Indicates whether the navigation should support flyout.
             * If flyout is set to true, the
             * nested child navigation nodes will only appear on hover or focus.
             */
            this.flyout = true;
            this.isOpen = false;
            this.openNodes = [];
            this.subscriptions = new rxjs.Subscription();
            this.resize = new i0.EventEmitter();
            this.subscriptions.add(this.router.events
                .pipe(operators.filter(function (event) { return event instanceof i4.NavigationEnd; }))
                .subscribe(function () { return _this.clear(); }));
            this.subscriptions.add(this.resize.pipe(operators.debounceTime(50)).subscribe(function () {
                _this.alignWrappersToRightIfStickOut();
            }));
        }
        NavigationUIComponent.prototype.onResize = function () {
            this.resize.next();
        };
        NavigationUIComponent.prototype.toggleOpen = function (event) {
            if (event.type === 'keydown') {
                event.preventDefault();
            }
            var node = event.currentTarget;
            if (this.openNodes.includes(node)) {
                if (event.type === 'keydown') {
                    this.back();
                }
                else {
                    this.openNodes = this.openNodes.filter(function (n) { return n !== node; });
                    this.renderer.removeClass(node, 'is-open');
                }
            }
            else {
                this.openNodes.push(node);
            }
            this.updateClasses();
            event.stopImmediatePropagation();
            event.stopPropagation();
        };
        NavigationUIComponent.prototype.back = function () {
            if (this.openNodes[this.openNodes.length - 1]) {
                this.renderer.removeClass(this.openNodes[this.openNodes.length - 1], 'is-open');
                this.openNodes.pop();
                this.updateClasses();
            }
        };
        NavigationUIComponent.prototype.clear = function () {
            this.openNodes = [];
            this.updateClasses();
        };
        NavigationUIComponent.prototype.onMouseEnter = function (event) {
            this.alignWrapperToRightIfStickOut(event.currentTarget);
            this.focusAfterPreviousClicked(event);
        };
        NavigationUIComponent.prototype.getTotalDepth = function (node, depth) {
            var _this = this;
            if (depth === void 0) { depth = 0; }
            if (node.children && node.children.length > 0) {
                return Math.max.apply(Math, __spread(node.children.map(function (n) { return _this.getTotalDepth(n, depth + 1); })));
            }
            else {
                return depth;
            }
        };
        NavigationUIComponent.prototype.getColumnCount = function (length) {
            return Math.round(length / (this.wrapAfter || length));
        };
        NavigationUIComponent.prototype.focusAfterPreviousClicked = function (event) {
            var target = ((event.target || event.relatedTarget));
            if (target.ownerDocument.activeElement.matches('nav[tabindex]') &&
                target.parentElement.matches('.flyout')) {
                target.focus();
            }
            return target.ownerDocument;
        };
        NavigationUIComponent.prototype.ngOnDestroy = function () {
            if (this.subscriptions) {
                this.subscriptions.unsubscribe();
            }
        };
        NavigationUIComponent.prototype.alignWrapperToRightIfStickOut = function (node) {
            var wrapper = node.querySelector('.wrapper');
            var body = node.closest('body');
            if (wrapper) {
                this.renderer.removeStyle(wrapper, 'margin-left');
                if (wrapper.offsetLeft + wrapper.offsetWidth >
                    body.offsetLeft + body.offsetWidth) {
                    this.renderer.setStyle(wrapper, 'margin-left', node.offsetWidth - wrapper.offsetWidth + "px");
                }
            }
        };
        NavigationUIComponent.prototype.alignWrappersToRightIfStickOut = function () {
            var _this = this;
            var navs = this.elemRef.nativeElement.childNodes;
            Array.from(navs)
                .filter(function (node) { return node.tagName === 'NAV'; })
                .forEach(function (nav) { return _this.alignWrapperToRightIfStickOut(nav); });
        };
        NavigationUIComponent.prototype.updateClasses = function () {
            var _this = this;
            this.openNodes.forEach(function (node, i) {
                if (i + 1 < _this.openNodes.length) {
                    _this.renderer.addClass(node, 'is-opened');
                    _this.renderer.removeClass(node, 'is-open');
                }
                else {
                    _this.renderer.removeClass(node, 'is-opened');
                    _this.renderer.addClass(node, 'is-open');
                }
            });
            this.isOpen = this.openNodes.length > 0;
        };
        return NavigationUIComponent;
    }());
    NavigationUIComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-navigation-ui',
                    template: "<div\n  *ngIf=\"flyout && node?.children.length > 1\"\n  class=\"back is-open\"\n  (click)=\"back()\"\n>\n  <h5>\n    <cx-icon [type]=\"iconType.CARET_LEFT\"></cx-icon>\n    {{ 'common.back' | cxTranslate }}\n  </h5>\n</div>\n\n<ng-container *ngFor=\"let child of node?.children\">\n  <ng-container *ngTemplateOutlet=\"nav; context: { node: child, depth: 0 }\">\n  </ng-container>\n</ng-container>\n\n<!-- we generate links in a recursive manner -->\n<ng-template #nav let-node=\"node\" let-depth=\"depth\">\n  <nav\n    (click)=\"toggleOpen($event)\"\n    (mouseenter)=\"onMouseEnter($event)\"\n    (keydown.space)=\"toggleOpen($event)\"\n    (keydown.esc)=\"back()\"\n  >\n    <cx-generic-link\n      *ngIf=\"\n        node.url && (!node.children || node.children?.length === 0);\n        else heading\n      \"\n      [url]=\"node.url\"\n      [target]=\"node.target\"\n    >\n      {{ node.title }}\n      <cx-icon\n        *ngIf=\"flyout && node.children?.length > 0\"\n        [type]=\"iconType.CARET_DOWN\"\n      ></cx-icon>\n    </cx-generic-link>\n\n    <ng-template #heading>\n      <h5\n        [attr.aria-label]=\"node.title\"\n        [attr.tabindex]=\"flyout && (depth === 0 || node.url) ? 0 : -1\"\n      >\n        {{ node.title }}\n        <cx-icon\n          *ngIf=\"flyout && node.children?.length > 0\"\n          [type]=\"iconType.CARET_DOWN\"\n        ></cx-icon>\n      </h5>\n    </ng-template>\n\n    <!-- we add a wrapper to allow for better layout handling in CSS -->\n    <div class=\"wrapper\" *ngIf=\"node.children?.length > 0\">\n      <cx-generic-link\n        *ngIf=\"node.url\"\n        [url]=\"node.url\"\n        [target]=\"node.target\"\n        class=\"all\"\n      >\n        {{ 'navigation.shopAll' | cxTranslate: { navNode: node.title } }}\n      </cx-generic-link>\n      <div\n        class=\"childs\"\n        [attr.depth]=\"getTotalDepth(node)\"\n        [attr.wrap-after]=\"node.children?.length > wrapAfter ? wrapAfter : null\"\n        [attr.columns]=\"getColumnCount(node.children?.length)\"\n      >\n        <ng-container *ngFor=\"let child of node.children\">\n          <ng-container\n            *ngTemplateOutlet=\"nav; context: { node: child, depth: depth + 1 }\"\n          >\n          </ng-container>\n        </ng-container>\n      </div>\n    </div>\n  </nav>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NavigationUIComponent.ctorParameters = function () { return [
        { type: i4.Router },
        { type: i0.Renderer2 },
        { type: i0.ElementRef }
    ]; };
    NavigationUIComponent.propDecorators = {
        node: [{ type: i0.Input }],
        wrapAfter: [{ type: i0.Input }],
        flyout: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.flyout',] }],
        isOpen: [{ type: i0.Input }, { type: i0.HostBinding, args: ['class.is-open',] }],
        onResize: [{ type: i0.HostListener, args: ['window:resize',] }]
    };

    var NavigationComponent = /** @class */ (function () {
        function NavigationComponent(componentData, service) {
            this.componentData = componentData;
            this.service = service;
            this.node$ = this.service.createNavigation(this.componentData.data$);
            this.styleClass$ = this.componentData.data$.pipe(operators.map(function (d) { return d === null || d === void 0 ? void 0 : d.styleClass; }));
        }
        return NavigationComponent;
    }());
    NavigationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-navigation',
                    template: "<cx-navigation-ui [node]=\"node$ | async\" [ngClass]=\"styleClass$ | async\">\n</cx-navigation-ui>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NavigationComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: NavigationService }
    ]; };

    var NavigationModule = /** @class */ (function () {
        function NavigationModule() {
        }
        return NavigationModule;
    }());
    NavigationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        IconModule,
                        GenericLinkModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                NavigationComponent: {
                                    component: NavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [NavigationComponent, NavigationUIComponent],
                    entryComponents: [NavigationComponent],
                    exports: [NavigationComponent, NavigationUIComponent],
                },] }
    ];

    var CategoryNavigationModule = /** @class */ (function () {
        function CategoryNavigationModule() {
        }
        return CategoryNavigationModule;
    }());
    CategoryNavigationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, NavigationModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CategoryNavigationComponent: {
                                    component: CategoryNavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [CategoryNavigationComponent],
                    entryComponents: [CategoryNavigationComponent],
                    exports: [CategoryNavigationComponent],
                },] }
    ];

    var FooterNavigationComponent = /** @class */ (function () {
        function FooterNavigationComponent(componentData, service) {
            this.componentData = componentData;
            this.service = service;
            this.node$ = this.service.getNavigationNode(this.componentData.data$);
            this.styleClass$ = this.componentData.data$.pipe(operators.map(function (d) { return d === null || d === void 0 ? void 0 : d.styleClass; }));
        }
        return FooterNavigationComponent;
    }());
    FooterNavigationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-footer-navigation',
                    template: "<cx-navigation-ui\n  [node]=\"node$ | async\"\n  [flyout]=\"false\"\n  [ngClass]=\"styleClass$ | async\"\n></cx-navigation-ui>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    FooterNavigationComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: NavigationService }
    ]; };

    var FooterNavigationModule = /** @class */ (function () {
        function FooterNavigationModule() {
        }
        return FooterNavigationModule;
    }());
    FooterNavigationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        NavigationModule,
                        GenericLinkModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                FooterNavigationComponent: {
                                    component: FooterNavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [FooterNavigationComponent],
                    entryComponents: [FooterNavigationComponent],
                    exports: [FooterNavigationComponent],
                },] }
    ];

    var HAS_SEARCH_RESULT_CLASS = 'has-searchbox-results';
    var SearchBoxComponentService = /** @class */ (function () {
        function SearchBoxComponentService(searchService, routingService, translationService, winRef) {
            this.searchService = searchService;
            this.routingService = routingService;
            this.translationService = translationService;
            this.winRef = winRef;
        }
        /**
         * Executes the search for products and suggestions,
         * unless the configuration is setup to not search for
         * products or suggestions.
         */
        SearchBoxComponentService.prototype.search = function (query, config) {
            if (!query || query === '') {
                this.clearResults();
                return;
            }
            if (config.minCharactersBeforeRequest &&
                query.length < config.minCharactersBeforeRequest) {
                return;
            }
            if (config.displayProducts) {
                this.searchService.search(query, {
                    pageSize: config.maxProducts,
                });
            }
            if (config.displaySuggestions) {
                this.searchService.searchSuggestions(query, {
                    pageSize: config.maxSuggestions,
                });
            }
        };
        /**
         * Returns an observable with the SearchResults. When there's any
         * result, the body tag will get a classname, so that specific style
         * rules can be applied.
         */
        SearchBoxComponentService.prototype.getResults = function (config) {
            var _this = this;
            return rxjs.combineLatest([
                this.getProductResults(config),
                this.getProductSuggestions(config),
                this.getSearchMessage(config),
            ]).pipe(operators.map(function (_a) {
                var _b = __read(_a, 3), productResults = _b[0], suggestions = _b[1], message = _b[2];
                return {
                    products: productResults ? productResults.products : null,
                    suggestions: suggestions,
                    message: message,
                };
            }), operators.tap(function (results) { return _this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, _this.hasResults(results)); }));
        };
        /**
         * Clears the searchbox results, so that old values are
         * no longer emited upon next search.
         */
        SearchBoxComponentService.prototype.clearResults = function () {
            this.searchService.clearResults();
            this.toggleBodyClass(HAS_SEARCH_RESULT_CLASS, false);
        };
        SearchBoxComponentService.prototype.hasBodyClass = function (className) {
            return this.winRef.document.body.classList.contains(className);
        };
        SearchBoxComponentService.prototype.toggleBodyClass = function (className, add) {
            if (add === undefined) {
                this.winRef.document.body.classList.toggle(className);
            }
            else {
                add
                    ? this.winRef.document.body.classList.add(className)
                    : this.winRef.document.body.classList.remove(className);
            }
        };
        /**
         * For search results model, it returns true when:
         * * there is any product OR
         * * the is any search suggestion OR
         * * there is a message.
         *
         * Otherwise it returns false.
         */
        SearchBoxComponentService.prototype.hasResults = function (results) {
            return ((!!results.products && results.products.length > 0) ||
                (!!results.suggestions && results.suggestions.length > 0) ||
                !!results.message);
        };
        /**
         * Emits product search results in case when the config property `displayProducts` is true.
         * Otherwise it emits an empty object.
         */
        SearchBoxComponentService.prototype.getProductResults = function (config) {
            if (config.displayProducts) {
                return this.searchService.getResults();
            }
            else {
                return rxjs.of({});
            }
        };
        /**
         * Loads suggestions from the backend. In case there's no suggestion
         * available, we try to get an exact match suggestion.
         */
        SearchBoxComponentService.prototype.getProductSuggestions = function (config) {
            var _this = this;
            if (!config.displaySuggestions) {
                return rxjs.of([]);
            }
            else {
                return this.searchService.getSuggestionResults().pipe(operators.map(function (res) { return res.map(function (suggestion) { return suggestion.value; }); }), operators.switchMap(function (suggestions) {
                    if (suggestions.length === 0) {
                        return _this.getExactSuggestion(config).pipe(operators.map(function (match) { return (match ? [match] : []); }));
                    }
                    else {
                        return rxjs.of(suggestions);
                    }
                }));
            }
        };
        /**
         * Whenever there is at least 1 product, we simulate
         * a suggestion to provide easy access to the search result page
         */
        SearchBoxComponentService.prototype.getExactSuggestion = function (config) {
            var _this = this;
            return this.getProductResults(config).pipe(operators.switchMap(function (productResult) {
                return productResult.products && productResult.products.length > 0
                    ? _this.fetchTranslation('searchBox.help.exactMatch', {
                        term: productResult.freeTextSearch,
                    })
                    : rxjs.of(null);
            }));
        };
        /**
         * Emits a 'no match' message, in case the product search results and search suggestions are empty.
         * Otherwise it emits null.
         */
        SearchBoxComponentService.prototype.getSearchMessage = function (config) {
            var _this = this;
            return rxjs.combineLatest([
                this.getProductResults(config),
                this.getProductSuggestions(config),
            ]).pipe(operators.switchMap(function (_a) {
                var _b = __read(_a, 2), productResult = _b[0], suggestions = _b[1];
                if (productResult &&
                    productResult.products &&
                    productResult.products.length === 0 &&
                    suggestions &&
                    suggestions.length === 0) {
                    return _this.fetchTranslation('searchBox.help.noMatch');
                }
                else {
                    return rxjs.of(null);
                }
            }));
        };
        /**
         * Navigates to the search result page with a given query
         */
        SearchBoxComponentService.prototype.launchSearchPage = function (query) {
            this.routingService.go({
                cxRoute: 'search',
                params: { query: query },
            });
        };
        SearchBoxComponentService.prototype.fetchTranslation = function (translationKey, options) {
            return this.translationService.translate(translationKey, options);
        };
        return SearchBoxComponentService;
    }());
    SearchBoxComponentService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SearchBoxComponentService_Factory() { return new SearchBoxComponentService(i0.ɵɵinject(i1.SearchboxService), i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.TranslationService), i0.ɵɵinject(i1.WindowRef)); }, token: SearchBoxComponentService, providedIn: "root" });
    SearchBoxComponentService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    SearchBoxComponentService.ctorParameters = function () { return [
        { type: i1.SearchboxService },
        { type: i1.RoutingService },
        { type: i1.TranslationService },
        { type: i1.WindowRef }
    ]; };

    var DEFAULT_SEARCHBOX_CONFIG = {
        minCharactersBeforeRequest: 1,
        displayProducts: true,
        displaySuggestions: true,
        maxProducts: 5,
        maxSuggestions: 5,
        displayProductImages: true,
    };
    var SearchBoxComponent = /** @class */ (function () {
        /**
         * The component data is optional, so that this component
         * can be reused without CMS integration.
         */
        function SearchBoxComponent(searchBoxComponentService, componentData, winRef) {
            var _this = this;
            this.searchBoxComponentService = searchBoxComponentService;
            this.componentData = componentData;
            this.winRef = winRef;
            this.iconTypes = exports.ICON_TYPE;
            /**
             * In some occasions we need to ignore the close event,
             * for example when we click inside the search result section.
             */
            this.ignoreCloseEvent = false;
            this.results$ = this.config$.pipe(operators.tap(function (c) { return (_this.config = c); }), operators.switchMap(function (config) { return _this.searchBoxComponentService.getResults(config); }));
        }
        Object.defineProperty(SearchBoxComponent.prototype, "queryText", {
            /**
             * Sets the search box input field
             */
            set: function (value) {
                if (value) {
                    this.search(value);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SearchBoxComponent.prototype, "config$", {
            /**
             * Returns the backend configuration or default configuration for the searchbox.
             */
            get: function () {
                if (this.componentData) {
                    return this.componentData.data$.pipe(
                    // Since the backend returns string values (i.e. displayProducts: "true") for
                    // boolean values, we replace them with boolean values.
                    operators.map(function (c) {
                        return Object.assign(Object.assign({}, c), { displayProducts: (c === null || c === void 0 ? void 0 : c.displayProducts) === 'true' || (c === null || c === void 0 ? void 0 : c.displayProducts) === true, displayProductImages: (c === null || c === void 0 ? void 0 : c.displayProductImages) === 'true' ||
                                (c === null || c === void 0 ? void 0 : c.displayProductImages) === true, displaySuggestions: (c === null || c === void 0 ? void 0 : c.displaySuggestions) === 'true' ||
                                (c === null || c === void 0 ? void 0 : c.displaySuggestions) === true });
                    }));
                }
                else {
                    return rxjs.of(DEFAULT_SEARCHBOX_CONFIG);
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Closes the searchbox and opens the search result page.
         */
        SearchBoxComponent.prototype.search = function (query) {
            this.searchBoxComponentService.search(query, this.config);
            // force the searchbox to open
            this.open();
        };
        /**
         * Opens the typeahead searchbox
         */
        SearchBoxComponent.prototype.open = function () {
            this.searchBoxComponentService.toggleBodyClass('searchbox-is-active', true);
        };
        /**
         * Closes the typehead searchbox.
         */
        SearchBoxComponent.prototype.close = function (event, force) {
            var _this = this;
            // Use timeout to detect changes
            setTimeout(function () {
                if ((!_this.ignoreCloseEvent && !_this.isSearchboxFocused()) || force) {
                    _this.blurSearchBox(event);
                }
            });
        };
        SearchBoxComponent.prototype.blurSearchBox = function (event) {
            this.searchBoxComponentService.toggleBodyClass('searchbox-is-active', false);
            if (event && event.target) {
                event.target.blur();
            }
        };
        // Check if focus is on searchbox or result list elements
        SearchBoxComponent.prototype.isSearchboxFocused = function () {
            return (this.getResultElements().includes(this.getFocusedElement()) ||
                this.winRef.document.querySelector('input[aria-label="search"]') ===
                    this.getFocusedElement());
        };
        /**
         * Especially in mobile we do not want the search icon
         * to focus the input again when it's already open.
         * */
        SearchBoxComponent.prototype.avoidReopen = function (event) {
            if (this.searchBoxComponentService.hasBodyClass('searchbox-is-active')) {
                this.close(event);
                event.preventDefault();
            }
        };
        // Return result list as HTMLElement array
        SearchBoxComponent.prototype.getResultElements = function () {
            return Array.from(this.winRef.document.querySelectorAll('.products > a, .suggestions > a'));
        };
        // Return focused element as HTMLElement
        SearchBoxComponent.prototype.getFocusedElement = function () {
            return this.winRef.document.activeElement;
        };
        SearchBoxComponent.prototype.getFocusedIndex = function () {
            return this.getResultElements().indexOf(this.getFocusedElement());
        };
        // Focus on previous item in results list
        SearchBoxComponent.prototype.focusPreviousChild = function (event) {
            event.preventDefault(); // Negate normal keyscroll
            var _a = __read([
                this.getResultElements(),
                this.getFocusedIndex(),
            ], 2), results = _a[0], focusedIndex = _a[1];
            // Focus on last index moving to first
            if (results.length) {
                if (focusedIndex < 1) {
                    results[results.length - 1].focus();
                }
                else {
                    results[focusedIndex - 1].focus();
                }
            }
        };
        // Focus on next item in results list
        SearchBoxComponent.prototype.focusNextChild = function (event) {
            event.preventDefault(); // Negate normal keyscroll
            var _a = __read([
                this.getResultElements(),
                this.getFocusedIndex(),
            ], 2), results = _a[0], focusedIndex = _a[1];
            // Focus on first index moving to last
            if (results.length) {
                if (focusedIndex >= results.length - 1) {
                    results[0].focus();
                }
                else {
                    results[focusedIndex + 1].focus();
                }
            }
        };
        /**
         * Opens the PLP with the given query.
         *
         * TODO: if there's a single product match, we could open the PDP.
         */
        SearchBoxComponent.prototype.launchSearchResult = function (event, query) {
            if (!query || query.trim().length === 0) {
                return;
            }
            this.close(event);
            this.searchBoxComponentService.launchSearchPage(query);
        };
        /**
         * Disables closing the search result list.
         */
        SearchBoxComponent.prototype.disableClose = function () {
            this.ignoreCloseEvent = true;
        };
        /**
         * Clears the search box input field
         */
        SearchBoxComponent.prototype.clear = function (el) {
            this.disableClose();
            el.value = '';
            this.searchBoxComponentService.clearResults();
        };
        return SearchBoxComponent;
    }());
    SearchBoxComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-searchbox',
                    template: "<label class=\"searchbox\" [class.dirty]=\"!!searchInput.value\">\n  <input\n    #searchInput\n    [placeholder]=\"'searchBox.placeholder' | cxTranslate\"\n    aria-label=\"search\"\n    (focus)=\"open()\"\n    (input)=\"search(searchInput.value)\"\n    (blur)=\"close($event)\"\n    (keydown.escape)=\"close($event)\"\n    (keydown.enter)=\"\n      close($event, true); launchSearchResult($event, searchInput.value)\n    \"\n    (keydown.arrowup)=\"focusPreviousChild($event)\"\n    (keydown.arrowdown)=\"focusNextChild($event)\"\n  />\n\n  <cx-icon\n    [type]=\"iconTypes.RESET\"\n    aria-label=\"reset\"\n    (mousedown)=\"clear(searchInput)\"\n    (keydown.enter)=\"clear(searchInput)\"\n    class=\"reset\"\n    tabindex=\"0\"\n  ></cx-icon>\n\n  <cx-icon\n    [type]=\"iconTypes.SEARCH\"\n    aria-label=\"search\"\n    class=\"search\"\n    (mousedown)=\"avoidReopen($event)\"\n    (keydown.enter)=\"avoidReopen($event)\"\n    tabindex=\"0\"\n  ></cx-icon>\n</label>\n\n<div\n  *ngIf=\"results$ | async as result\"\n  class=\"results\"\n  (click)=\"close($event, true)\"\n>\n  <div\n    *ngIf=\"result.message\"\n    class=\"message\"\n    [innerHTML]=\"result.message\"\n  ></div>\n\n  <div class=\"suggestions\">\n    <a\n      *ngFor=\"let suggestion of result.suggestions\"\n      [innerHTML]=\"suggestion | cxHighlight: searchInput.value\"\n      [routerLink]=\"\n        {\n          cxRoute: 'search',\n          params: { query: suggestion }\n        } | cxUrl\n      \"\n      (keydown.arrowup)=\"focusPreviousChild($event)\"\n      (keydown.arrowdown)=\"focusNextChild($event)\"\n      (keydown.enter)=\"close($event, true)\"\n      (keydown.escape)=\"close($event, true)\"\n      (blur)=\"close($event)\"\n    >\n    </a>\n  </div>\n\n  <div class=\"products\" *ngIf=\"result.products\">\n    <a\n      *ngFor=\"let product of result.products\"\n      [routerLink]=\"\n        {\n          cxRoute: 'product',\n          params: product\n        } | cxUrl\n      \"\n      [class.has-media]=\"config.displayProductImages\"\n      (keydown.arrowup)=\"focusPreviousChild($event)\"\n      (keydown.arrowdown)=\"focusNextChild($event)\"\n      (keydown.enter)=\"close($event, true)\"\n      (keydown.escape)=\"close($event, true)\"\n      (blur)=\"close($event)\"\n    >\n      <cx-media\n        *ngIf=\"config.displayProductImages\"\n        [container]=\"product.images?.PRIMARY\"\n        [alt]=\"product.summary\"\n      ></cx-media>\n      <h4 class=\"name\" [innerHTML]=\"product.nameHtml\"></h4>\n      <span class=\"price\">{{ product.price?.formattedValue }}</span>\n    </a>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    SearchBoxComponent.ctorParameters = function () { return [
        { type: SearchBoxComponentService },
        { type: CmsComponentData, decorators: [{ type: i0.Optional }] },
        { type: i1.WindowRef }
    ]; };
    SearchBoxComponent.propDecorators = {
        queryText: [{ type: i0.Input, args: ['queryText',] }]
    };

    var HighlightPipe = /** @class */ (function () {
        function HighlightPipe() {
        }
        HighlightPipe.prototype.transform = function (text, match) {
            if (!match) {
                return text;
            }
            return text.replace(match.trim(), "<span class=\"highlight\">" + match.trim() + "</span>");
        };
        return HighlightPipe;
    }());
    HighlightPipe.decorators = [
        { type: i0.Pipe, args: [{ name: 'cxHighlight' },] }
    ];

    var SearchBoxModule = /** @class */ (function () {
        function SearchBoxModule() {
        }
        return SearchBoxModule;
    }());
    SearchBoxModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        MediaModule,
                        IconModule,
                        i1.UrlModule,
                        i1.I18nModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                SearchBoxComponent: {
                                    component: SearchBoxComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [SearchBoxComponent, HighlightPipe],
                    entryComponents: [SearchBoxComponent],
                    exports: [SearchBoxComponent],
                },] }
    ];

    var OrderConfirmationItemsComponent = /** @class */ (function () {
        function OrderConfirmationItemsComponent(checkoutService, promotionService) {
            this.checkoutService = checkoutService;
            this.promotionService = promotionService;
            this.promotionLocation = i1.PromotionLocation.Checkout;
        }
        OrderConfirmationItemsComponent.prototype.ngOnInit = function () {
            this.order$ = this.checkoutService.getOrderDetails();
            this.orderPromotions$ = this.promotionService.getOrderPromotions(this.promotionLocation);
        };
        OrderConfirmationItemsComponent.prototype.ngOnDestroy = function () {
            this.checkoutService.clearCheckoutData();
        };
        return OrderConfirmationItemsComponent;
    }());
    OrderConfirmationItemsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-confirmation-items',
                    template: "<div class=\"cx-order-items container\" *ngIf=\"order$ | async as order\">\n  <h4 class=\"cx-order-items-header\">\n    {{ 'checkoutOrderConfirmation.orderItems' | cxTranslate }}\n  </h4>\n\n  <ng-container *ngIf=\"orderPromotions$ | async as orderPromotions\">\n    <cx-promotions [promotions]=\"orderPromotions\"></cx-promotions>\n  </ng-container>\n\n  <cx-cart-item-list\n    [items]=\"order.entries\"\n    [readonly]=\"true\"\n    [promotionLocation]=\"promotionLocation\"\n  ></cx-cart-item-list>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderConfirmationItemsComponent.ctorParameters = function () { return [
        { type: i1.CheckoutService },
        { type: PromotionService }
    ]; };

    var OrderConfirmationOverviewComponent = /** @class */ (function () {
        function OrderConfirmationOverviewComponent(checkoutService) {
            this.checkoutService = checkoutService;
        }
        OrderConfirmationOverviewComponent.prototype.ngOnInit = function () {
            this.order$ = this.checkoutService.getOrderDetails();
        };
        OrderConfirmationOverviewComponent.prototype.ngOnDestroy = function () {
            this.checkoutService.clearCheckoutData();
        };
        return OrderConfirmationOverviewComponent;
    }());
    OrderConfirmationOverviewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-confirmation-overview',
                    template: "<ng-container *ngIf=\"order$ | async as order\">\n  <cx-order-overview [order]=\"order\"></cx-order-overview>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderConfirmationOverviewComponent.ctorParameters = function () { return [
        { type: i1.CheckoutService }
    ]; };

    var OrderConfirmationThankYouMessageComponent = /** @class */ (function () {
        function OrderConfirmationThankYouMessageComponent(checkoutService) {
            this.checkoutService = checkoutService;
            this.isGuestCustomer = false;
        }
        OrderConfirmationThankYouMessageComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.order$ = this.checkoutService.getOrderDetails().pipe(operators.tap(function (order) {
                _this.isGuestCustomer = order.guestCustomer;
                _this.orderGuid = order.guid;
            }));
            this.isReplenishmentOrderType$ = this.checkoutService
                .getCurrentOrderType()
                .pipe(operators.map(function (orderType) { return i1.ORDER_TYPE.SCHEDULE_REPLENISHMENT_ORDER === orderType; }));
        };
        OrderConfirmationThankYouMessageComponent.prototype.ngOnDestroy = function () {
            this.checkoutService.clearCheckoutData();
        };
        return OrderConfirmationThankYouMessageComponent;
    }());
    OrderConfirmationThankYouMessageComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-confirmation-thank-you-message',
                    template: "<ng-container *ngIf=\"order$ | async as order\">\n  <div class=\"cx-page-header\">\n    <h1 class=\"cx-page-title\">\n      {{ 'checkoutOrderConfirmation.confirmationOfOrder' | cxTranslate }}\n      {{\n        (isReplenishmentOrderType$ | async)\n          ? order.replenishmentOrderCode\n          : order.code\n      }}\n    </h1>\n  </div>\n\n  <div class=\"cx-order-confirmation-message\">\n    <h2>{{ 'checkoutOrderConfirmation.thankYou' | cxTranslate }}</h2>\n    <p>\n      {{ 'checkoutOrderConfirmation.invoiceHasBeenSentByEmail' | cxTranslate }}\n    </p>\n  </div>\n\n  <div *ngIf=\"isGuestCustomer\">\n    <cx-guest-register-form\n      [guid]=\"orderGuid\"\n      [email]=\"order.paymentInfo.billingAddress.email\"\n    ></cx-guest-register-form>\n  </div>\n\n  <cx-add-to-home-screen-banner></cx-add-to-home-screen-banner>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderConfirmationThankYouMessageComponent.ctorParameters = function () { return [
        { type: i1.CheckoutService }
    ]; };

    var OrderConfirmationTotalsComponent = /** @class */ (function () {
        function OrderConfirmationTotalsComponent(checkoutService) {
            this.checkoutService = checkoutService;
        }
        OrderConfirmationTotalsComponent.prototype.ngOnInit = function () {
            this.order$ = this.checkoutService.getOrderDetails();
        };
        OrderConfirmationTotalsComponent.prototype.ngOnDestroy = function () {
            this.checkoutService.clearCheckoutData();
        };
        return OrderConfirmationTotalsComponent;
    }());
    OrderConfirmationTotalsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-order-confirmation-totals',
                    template: "<div class=\"cx-order-summary container\" *ngIf=\"order$ | async as order\">\n  <div class=\"row justify-content-end\">\n    <div class=\"col-sm-12 col-md-6 col-lg-5 col-xl-4\">\n      <cx-order-summary [cart]=\"order\"></cx-order-summary>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    OrderConfirmationTotalsComponent.ctorParameters = function () { return [
        { type: i1.CheckoutService }
    ]; };

    var GuestRegisterFormComponent = /** @class */ (function () {
        function GuestRegisterFormComponent(userService, routingService, authService, fb) {
            this.userService = userService;
            this.routingService = routingService;
            this.authService = authService;
            this.fb = fb;
            this.guestRegisterForm = this.fb.group({
                password: [
                    '',
                    [forms.Validators.required, CustomFormValidators.passwordValidator],
                ],
                passwordconf: ['', forms.Validators.required],
            }, {
                validators: CustomFormValidators.passwordsMustMatch('password', 'passwordconf'),
            });
        }
        GuestRegisterFormComponent.prototype.submit = function () {
            var _this = this;
            if (this.guestRegisterForm.valid) {
                this.userService.registerGuest(this.guid, this.guestRegisterForm.value.password);
                if (!this.subscription) {
                    this.subscription = this.authService
                        .getUserToken()
                        .subscribe(function (token) {
                        if (token.access_token) {
                            _this.routingService.go({ cxRoute: 'home' });
                        }
                    });
                }
            }
            else {
                this.guestRegisterForm.markAllAsTouched();
            }
        };
        GuestRegisterFormComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return GuestRegisterFormComponent;
    }());
    GuestRegisterFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-guest-register-form',
                    template: "<div class=\"register-guest\">\n  <div class=\"col-md-6 col-lg-4\">\n    <h3>{{ 'checkoutOrderConfirmation.createAccount' | cxTranslate }}</h3>\n    <p>\n      {{\n        'checkoutOrderConfirmation.createAccountForNext'\n          | cxTranslate: { email: email }\n      }}\n    </p>\n\n    <form (ngSubmit)=\"submit()\" [formGroup]=\"guestRegisterForm\">\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'register.password.label' | cxTranslate\n          }}</span>\n          <input\n            class=\"form-control\"\n            type=\"password\"\n            name=\"password\"\n            placeholder=\"{{ 'register.password.placeholder' | cxTranslate }}\"\n            formControlName=\"password\"\n          />\n          <cx-form-errors\n            [control]=\"guestRegisterForm.get('password')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'register.confirmPassword.label' | cxTranslate\n          }}</span>\n          <input\n            class=\"form-control\"\n            type=\"password\"\n            name=\"passwordconf\"\n            placeholder=\"{{\n              'register.confirmPassword.placeholder' | cxTranslate\n            }}\"\n            formControlName=\"passwordconf\"\n          />\n          <cx-form-errors\n            [control]=\"guestRegisterForm.get('passwordconf')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n\n      <button type=\"submit\" class=\"btn btn-block btn-primary\">\n        {{ 'common.submit' | cxTranslate }}\n      </button>\n    </form>\n  </div>\n</div>\n"
                },] }
    ];
    GuestRegisterFormComponent.ctorParameters = function () { return [
        { type: i1.UserService },
        { type: i1.RoutingService },
        { type: i1.AuthService },
        { type: forms.FormBuilder }
    ]; };
    GuestRegisterFormComponent.propDecorators = {
        guid: [{ type: i0.Input }],
        email: [{ type: i0.Input }]
    };

    var OrderConfirmationGuard = /** @class */ (function () {
        function OrderConfirmationGuard(checkoutService, router, semanticPathService) {
            this.checkoutService = checkoutService;
            this.router = router;
            this.semanticPathService = semanticPathService;
        }
        OrderConfirmationGuard.prototype.canActivate = function () {
            var _this = this;
            return this.checkoutService.getOrderDetails().pipe(operators.map(function (orderDetails) {
                if (orderDetails && Object.keys(orderDetails).length !== 0) {
                    return true;
                }
                else {
                    return _this.router.parseUrl(_this.semanticPathService.get('orders'));
                }
            }));
        };
        return OrderConfirmationGuard;
    }());
    OrderConfirmationGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function OrderConfirmationGuard_Factory() { return new OrderConfirmationGuard(i0.ɵɵinject(i1.CheckoutService), i0.ɵɵinject(i4.Router), i0.ɵɵinject(i1.SemanticPathService)); }, token: OrderConfirmationGuard, providedIn: "root" });
    OrderConfirmationGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    OrderConfirmationGuard.ctorParameters = function () { return [
        { type: i1.CheckoutService },
        { type: i4.Router },
        { type: i1.SemanticPathService }
    ]; };

    var orderConfirmationComponents = [
        OrderConfirmationItemsComponent,
        OrderConfirmationOverviewComponent,
        OrderConfirmationThankYouMessageComponent,
        OrderConfirmationTotalsComponent,
        GuestRegisterFormComponent,
    ];
    var OrderConfirmationModule = /** @class */ (function () {
        function OrderConfirmationModule() {
        }
        return OrderConfirmationModule;
    }());
    OrderConfirmationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        CartSharedModule,
                        CardModule,
                        PwaModule,
                        PromotionsModule,
                        i1.I18nModule,
                        forms.ReactiveFormsModule,
                        i1.FeaturesConfigModule,
                        FormErrorsModule,
                        OrderOverviewModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                OrderConfirmationThankMessageComponent: {
                                    component: OrderConfirmationThankYouMessageComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                OrderConfirmationItemsComponent: {
                                    component: OrderConfirmationItemsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                OrderConfirmationTotalsComponent: {
                                    component: OrderConfirmationTotalsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                OrderConfirmationOverviewComponent: {
                                    component: OrderConfirmationOverviewComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                            },
                        }),
                    ],
                    declarations: __spread(orderConfirmationComponents),
                    exports: __spread(orderConfirmationComponents),
                    entryComponents: __spread(orderConfirmationComponents),
                },] }
    ];

    var ReplenishmentOrderConfirmationModule = /** @class */ (function () {
        function ReplenishmentOrderConfirmationModule() {
        }
        return ReplenishmentOrderConfirmationModule;
    }());
    ReplenishmentOrderConfirmationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        CartSharedModule,
                        CardModule,
                        PwaModule,
                        PromotionsModule,
                        i1.I18nModule,
                        forms.ReactiveFormsModule,
                        i1.FeaturesConfigModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ReplenishmentConfirmationMessageComponent: {
                                    component: OrderConfirmationThankYouMessageComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                ReplenishmentConfirmationOverviewComponent: {
                                    component: OrderConfirmationOverviewComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                ReplenishmentConfirmationItemsComponent: {
                                    component: OrderConfirmationItemsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                                ReplenishmentConfirmationTotalsComponent: {
                                    component: OrderConfirmationTotalsComponent,
                                    guards: [OrderConfirmationGuard],
                                },
                            },
                        }),
                    ],
                },] }
    ];

    var ProductCarouselService = /** @class */ (function () {
        function ProductCarouselService(productService, referenceService, semanticPathService) {
            this.productService = productService;
            this.referenceService = referenceService;
            this.semanticPathService = semanticPathService;
        }
        /**
         * Loads the product data and converts it `CarouselItem`.
         */
        ProductCarouselService.prototype.loadProduct = function (code) {
            var _this = this;
            return this.productService.get(code).pipe(operators.filter(Boolean), operators.map(function (product) { return _this.convertProduct(product); }));
        };
        ProductCarouselService.prototype.getProductReferences = function (code, referenceType, displayTitle, displayProductPrices) {
            var _this = this;
            return this.referenceService.get(code, referenceType).pipe(operators.filter(Boolean), operators.map(function (refs) { return refs.map(function (ref) { return _this.convertProduct(ref.target, displayTitle, displayProductPrices); }); }));
        };
        /**
         * Converts the product to a generic CarouselItem
         */
        ProductCarouselService.prototype.convertProduct = function (source, displayTitle, displayProductPrices) {
            if (displayTitle === void 0) { displayTitle = true; }
            if (displayProductPrices === void 0) { displayProductPrices = true; }
            var item = {};
            if (displayTitle) {
                item.title = source.name;
            }
            if (displayProductPrices && source.price && source.price.formattedValue) {
                item.price = source.price.formattedValue;
            }
            if (source.images && source.images.PRIMARY) {
                item.media = {
                    container: source.images.PRIMARY,
                    format: 'product',
                };
            }
            item.route = this.semanticPathService.transform({
                cxRoute: 'product',
                params: source,
            });
            return item;
        };
        return ProductCarouselService;
    }());
    ProductCarouselService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProductCarouselService_Factory() { return new ProductCarouselService(i0.ɵɵinject(i1.ProductService), i0.ɵɵinject(i1.ProductReferenceService), i0.ɵɵinject(i1.SemanticPathService)); }, token: ProductCarouselService, providedIn: "root" });
    ProductCarouselService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ProductCarouselService.ctorParameters = function () { return [
        { type: i1.ProductService },
        { type: i1.ProductReferenceService },
        { type: i1.SemanticPathService }
    ]; };

    var ProductCarouselComponent = /** @class */ (function () {
        function ProductCarouselComponent(componentData, productService) {
            var _this = this;
            this.componentData = componentData;
            this.productService = productService;
            this.PRODUCT_SCOPE = i1.ProductScope.LIST;
            this.componentData$ = this.componentData.data$.pipe(operators.filter(Boolean));
            /**
             * returns an Obervable string for the title.
             */
            this.title$ = this.componentData$.pipe(operators.map(function (data) { return data.title; }));
            /**
             * Obervable that holds an Array of Observables. This is done, so that
             * the component UI could consider to lazy load the UI components when they're
             * in the viewpoint.
             */
            this.items$ = this.componentData$.pipe(operators.map(function (data) { return data.productCodes.trim().split(' '); }), operators.map(function (codes) { return codes.map(function (code) { return _this.productService.get(code, _this.PRODUCT_SCOPE); }); }));
        }
        return ProductCarouselComponent;
    }());
    ProductCarouselComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-carousel',
                    template: "<cx-carousel\n  [items]=\"items$ | async\"\n  [title]=\"title$ | async\"\n  [template]=\"carouselItem\"\n  itemWidth=\"285px\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media [container]=\"item.images?.PRIMARY\"></cx-media>\n    <h4>\n      {{ item.name }}\n    </h4>\n    <div class=\"price\">\n      {{ item.price?.formattedValue }}\n    </div>\n  </a>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductCarouselComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: i1.ProductService }
    ]; };

    var ProductCarouselModule = /** @class */ (function () {
        function ProductCarouselModule() {
        }
        return ProductCarouselModule;
    }());
    ProductCarouselModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, CarouselModule, MediaModule, i4.RouterModule, i1.UrlModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductCarouselComponent: {
                                    component: ProductCarouselComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductCarouselComponent],
                    entryComponents: [ProductCarouselComponent],
                    exports: [ProductCarouselComponent],
                },] }
    ];

    var ProductReferencesComponent = /** @class */ (function () {
        function ProductReferencesComponent(component, current, referenceService) {
            var _this = this;
            this.component = component;
            this.current = current;
            this.referenceService = referenceService;
            /**
             * returns an Obervable string for the title
             */
            this.title$ = this.component.data$.pipe(operators.map(function (d) { return d === null || d === void 0 ? void 0 : d.title; }));
            this.currentProductCode$ = this.current.getProduct().pipe(operators.filter(Boolean), operators.map(function (p) { return p.code; }), operators.distinctUntilChanged(), operators.tap(function () { return _this.referenceService.cleanReferences(); }));
            /**
             * Obervable with an Array of Observables. This is done, so that
             * the component UI could consider to lazy load the UI components when they're
             * in the viewpoint.
             */
            this.items$ = rxjs.combineLatest([
                this.currentProductCode$,
                this.component.data$,
            ]).pipe(operators.switchMap(function (_a) {
                var _b = __read(_a, 2), code = _b[0], data = _b[1];
                return _this.getProductReferences(code, data === null || data === void 0 ? void 0 : data.productReferenceTypes);
            }));
        }
        ProductReferencesComponent.prototype.getProductReferences = function (code, referenceType) {
            return this.referenceService.get(code, referenceType).pipe(operators.filter(Boolean), operators.map(function (refs) { return refs.map(function (ref) { return rxjs.of(ref.target); }); }));
        };
        return ProductReferencesComponent;
    }());
    ProductReferencesComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-references',
                    template: "<cx-carousel\n  [title]=\"title$ | async\"\n  [items]=\"items$ | async\"\n  [template]=\"carouselItem\"\n>\n</cx-carousel>\n\n<ng-template #carouselItem let-item=\"item\">\n  <a tabindex=\"0\" [routerLink]=\"{ cxRoute: 'product', params: item } | cxUrl\">\n    <cx-media [container]=\"item.images?.PRIMARY\"></cx-media>\n    <h4>{{ item.name }}</h4>\n    <div class=\"price\">{{ item.price?.formattedValue }}</div>\n  </a>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductReferencesComponent.ctorParameters = function () { return [
        { type: CmsComponentData },
        { type: CurrentProductService },
        { type: i1.ProductReferenceService }
    ]; };

    var ProductReferencesModule = /** @class */ (function () {
        function ProductReferencesModule() {
        }
        return ProductReferencesModule;
    }());
    ProductReferencesModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, CarouselModule, MediaModule, i4.RouterModule, i1.UrlModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductReferencesComponent: {
                                    component: ProductReferencesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductReferencesComponent],
                    entryComponents: [ProductReferencesComponent],
                    exports: [ProductReferencesComponent],
                },] }
    ];

    var defaultScrollConfig = {
        view: {
            infiniteScroll: {
                active: false,
                productLimit: 0,
                showMoreButton: false,
            },
        },
    };

    var ProductImagesComponent = /** @class */ (function () {
        function ProductImagesComponent(currentProductService) {
            var _this = this;
            this.currentProductService = currentProductService;
            this.mainMediaContainer = new rxjs.BehaviorSubject(null);
            this.product$ = this.currentProductService.getProduct().pipe(operators.filter(Boolean), operators.distinctUntilChanged(), operators.tap(function (p) {
                var _a;
                _this.mainMediaContainer.next(((_a = p.images) === null || _a === void 0 ? void 0 : _a.PRIMARY) ? p.images.PRIMARY : {});
            }));
            this.thumbs$ = this.product$.pipe(operators.map(function (p) { return _this.createThumbs(p); }));
            this.mainImage$ = rxjs.combineLatest([this.product$, this.mainMediaContainer]).pipe(operators.map(function (_b) {
                var _c = __read(_b, 2), container = _c[1];
                return container;
            }));
        }
        ProductImagesComponent.prototype.openImage = function (item) {
            this.mainMediaContainer.next(item);
        };
        ProductImagesComponent.prototype.isActive = function (thumbnail) {
            return this.mainMediaContainer.pipe(operators.filter(Boolean), operators.map(function (container) {
                return (container.zoom &&
                    container.zoom.url &&
                    thumbnail.zoom &&
                    thumbnail.zoom.url &&
                    container.zoom.url === thumbnail.zoom.url);
            }));
        };
        /** find the index of the main media in the list of media */
        ProductImagesComponent.prototype.getActive = function (thumbs) {
            return this.mainMediaContainer.pipe(operators.filter(Boolean), operators.map(function (container) {
                var current = thumbs.find(function (t) { return t.media &&
                    container.zoom &&
                    t.media.container &&
                    t.media.container.zoom &&
                    t.media.container.zoom.url === container.zoom.url; });
                return thumbs.indexOf(current);
            }));
        };
        /**
         * Return an array of CarouselItems for the product thumbnails.
         * In case there are less then 2 thumbs, we return null.
         */
        ProductImagesComponent.prototype.createThumbs = function (product) {
            if (!product.images ||
                !product.images.GALLERY ||
                product.images.GALLERY.length < 2) {
                return [];
            }
            return product.images.GALLERY.map(function (c) { return rxjs.of({ container: c }); });
        };
        return ProductImagesComponent;
    }());
    ProductImagesComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-images',
                    template: "<ng-container *ngIf=\"mainImage$ | async as main\">\n  <cx-media [container]=\"main\"> </cx-media>\n</ng-container>\n\n<ng-container *ngIf=\"thumbs$ | async as thumbs\">\n  <cx-carousel\n    *ngIf=\"thumbs.length\"\n    class=\"thumbs\"\n    [items]=\"thumbs\"\n    itemWidth=\"120px\"\n    [hideIndicators]=\"false\"\n    [template]=\"thumb\"\n  ></cx-carousel>\n</ng-container>\n\n<ng-template #thumb let-item=\"item\">\n  <cx-media\n    [container]=\"item.container\"\n    tabindex=\"0\"\n    (focus)=\"openImage(item.container)\"\n    [class.is-active]=\"isActive(item.container) | async\"\n  >\n  </cx-media>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductImagesComponent.ctorParameters = function () { return [
        { type: CurrentProductService }
    ]; };

    var ProductImagesModule = /** @class */ (function () {
        function ProductImagesModule() {
        }
        return ProductImagesModule;
    }());
    ProductImagesModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        MediaModule,
                        OutletModule,
                        CarouselModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductImagesComponent: {
                                    component: ProductImagesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductImagesComponent],
                    entryComponents: [ProductImagesComponent],
                    exports: [ProductImagesComponent],
                },] }
    ];

    var ProductIntroComponent = /** @class */ (function () {
        function ProductIntroComponent(currentProductService, translationService, winRef) {
            this.currentProductService = currentProductService;
            this.translationService = translationService;
            this.winRef = winRef;
            this.reviewsTabAvailable = new rxjs.BehaviorSubject(false);
            this.product$ = this.currentProductService.getProduct();
        }
        ProductIntroComponent.prototype.ngAfterContentChecked = function () {
            this.reviewsTabAvailable.next(!!this.getReviewsComponent());
        };
        // Scroll to views component on page and click "Reviews" tab
        ProductIntroComponent.prototype.showReviews = function () {
            var _this = this;
            // Use translated label for Reviews tab reference
            this.translationService
                .translate('TabPanelContainer.tabs.ProductReviewsTabComponent')
                .subscribe(function (reviewsTabLabel) {
                var tabsComponent = _this.getTabsComponent();
                var reviewsTab = _this.getTabByLabel(reviewsTabLabel, tabsComponent);
                var reviewsComponent = _this.getReviewsComponent();
                if (reviewsTab && reviewsComponent) {
                    _this.clickTabIfInactive(reviewsTab);
                    setTimeout(function () { return reviewsComponent.scrollIntoView({ behavior: 'smooth' }); }, 0);
                }
            })
                .unsubscribe();
        };
        // NOTE: Does not currently exists as its own component
        // but part of tabs component. This is likely to change in refactor.
        ProductIntroComponent.prototype.getReviewsComponent = function () {
            return this.winRef.document.querySelector('cx-product-reviews');
        };
        // Get Tabs Component if exists on page
        ProductIntroComponent.prototype.getTabsComponent = function () {
            return this.winRef.document.querySelector('cx-tab-paragraph-container');
        };
        // Click to activate tab if not already active
        ProductIntroComponent.prototype.clickTabIfInactive = function (tab) {
            if (!tab.classList.contains('active') ||
                tab.classList.contains('toggled')) {
                tab.click();
            }
        };
        // Get Tab by label if exists on page
        ProductIntroComponent.prototype.getTabByLabel = function (label, tabsComponent) {
            var e_1, _a;
            if (tabsComponent) {
                // NOTE: Reads through button tags to click on correct tab
                // There may be a better way of doing this now/after refactor
                var tabElements = tabsComponent.getElementsByTagName('button');
                try {
                    // Look through button tab elements until finding tab with label
                    for (var _b = __values(Array.from(tabElements)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var buttonElement = _c.value;
                        if (buttonElement.innerHTML.includes(label)) {
                            return buttonElement;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        return ProductIntroComponent;
    }());
    ProductIntroComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-intro',
                    template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"rating\" *ngIf=\"product.averageRating\">\n    <cx-star-rating\n      [rating]=\"product?.averageRating\"\n      [disabled]=\"true\"\n    ></cx-star-rating>\n\n    <div class=\"count\">({{ product?.numberOfReviews }})</div>\n\n    <button\n      *ngIf=\"reviewsTabAvailable | async\"\n      class=\"btn btn-link cx-action-link\"\n      (click)=\"showReviews()\"\n    >\n      {{ 'productSummary.showReviews' | cxTranslate }}\n    </button>\n  </div>\n  <div class=\"rating\" *ngIf=\"!product.averageRating\">\n    {{ 'productDetails.noReviews' | cxTranslate }}\n  </div>\n  <div class=\"code\">\n    {{ 'productSummary.id' | cxTranslate }} {{ product?.code }}\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductIntroComponent.ctorParameters = function () { return [
        { type: CurrentProductService },
        { type: i1.TranslationService },
        { type: i1.WindowRef }
    ]; };

    var ProductIntroModule = /** @class */ (function () {
        function ProductIntroModule() {
        }
        return ProductIntroModule;
    }());
    ProductIntroModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule, StarRatingModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductIntroComponent: {
                                    component: ProductIntroComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductIntroComponent],
                    exports: [ProductIntroComponent],
                    entryComponents: [ProductIntroComponent],
                },] }
    ];

    /**
     * The `ProductListComponentService` is used to search products. The service is used
     * on the Product Listing Page, for listing products and the facet navigation.
     *
     * The service exposes the product search results based on the category and search
     * route parameters. The route parameters are used to query products by the help of
     * the `ProductSearchService`.
     */
    var ProductListComponentService = /** @class */ (function () {
        function ProductListComponentService(productSearchService, routing, activatedRoute, currencyService, languageService, router) {
            var _this = this;
            this.productSearchService = productSearchService;
            this.routing = routing;
            this.activatedRoute = activatedRoute;
            this.currencyService = currencyService;
            this.languageService = languageService;
            this.router = router;
            // TODO: make it configurable
            this.defaultPageSize = 10;
            this.RELEVANCE_ALLCATEGORIES = ':relevance:allCategories:';
            /**
             * Emits the search results for the current search query.
             *
             * The `searchResults$` is _not_ concerned with querying, it only observes the
             * `productSearchService.getResults()`
             */
            this.searchResults$ = this.productSearchService
                .getResults()
                .pipe(operators.filter(function (searchResult) { return Object.keys(searchResult).length > 0; }));
            /**
             * Observes the route and performs a search on each route change.
             *
             * Context changes, such as language and currencies are also taken
             * into account, so that the search is performed again.
             */
            this.searchByRouting$ = rxjs.combineLatest(__spread([
                this.routing.getRouterState().pipe(operators.distinctUntilChanged(function (x, y) {
                    // router emits new value also when the anticipated `nextState` changes
                    // but we want to perform search only when current url changes
                    return x.state.url === y.state.url;
                }))
            ], this.siteContext)).pipe(operators.map(function (_a) {
                var _b = __read(_a), routerState = _b[0], _context = _b.slice(1);
                return routerState.state;
            }), operators.tap(function (state) {
                var criteria = _this.getCriteriaFromRoute(state.params, state.queryParams);
                _this.search(criteria);
            }));
            /**
             * This stream is used for the Product Listing and Product Facets.
             *
             * It not only emits search results, but also performs a search on every change
             * of the route (i.e. route params or query params).
             *
             * When a user leaves the PLP route, the PLP component unsubscribes from this stream
             * so no longer the search is performed on route change.
             */
            this.model$ = rxjs.combineLatest([
                this.searchResults$,
                this.searchByRouting$,
            ]).pipe(operators.pluck(0), operators.shareReplay({ bufferSize: 1, refCount: true }));
        }
        /**
         * Expose the `SearchCriteria`. The search criteria are driven by the route parameters.
         *
         * This search route configuration is not yet configurable
         * (see https://github.com/SAP/spartacus/issues/7191).
         */
        ProductListComponentService.prototype.getCriteriaFromRoute = function (routeParams, queryParams) {
            return {
                query: queryParams.query || this.getQueryFromRouteParams(routeParams),
                pageSize: queryParams.pageSize || this.defaultPageSize,
                currentPage: queryParams.currentPage,
                sortCode: queryParams.sortCode,
            };
        };
        /**
         * Resolves the search query from the given `ProductListRouteParams`.
         */
        ProductListComponentService.prototype.getQueryFromRouteParams = function (_a) {
            var query = _a.query, categoryCode = _a.categoryCode, brandCode = _a.brandCode;
            if (query) {
                return query;
            }
            if (categoryCode) {
                return this.RELEVANCE_ALLCATEGORIES + categoryCode;
            }
            // TODO: drop support for brands as they should be treated
            // similarly as any category.
            if (brandCode) {
                return this.RELEVANCE_ALLCATEGORIES + brandCode;
            }
        };
        /**
         * Performs a search based on the given search criteria.
         *
         * The search is delegated to the `ProductSearchService`.
         */
        ProductListComponentService.prototype.search = function (criteria) {
            var currentPage = criteria.currentPage;
            var pageSize = criteria.pageSize;
            var sort = criteria.sortCode;
            this.productSearchService.search(criteria.query, 
            // TODO: consider dropping this complex passing of cleaned object
            Object.assign({}, currentPage && { currentPage: currentPage }, pageSize && { pageSize: pageSize }, sort && { sort: sort }));
        };
        /**
         * Get items from a given page without using navigation
         */
        ProductListComponentService.prototype.getPageItems = function (pageNumber) {
            var _this = this;
            this.routing
                .getRouterState()
                .subscribe(function (route) {
                var routeCriteria = _this.getCriteriaFromRoute(route.state.params, route.state.queryParams);
                var criteria = Object.assign(Object.assign({}, routeCriteria), { currentPage: pageNumber });
                _this.search(criteria);
            })
                .unsubscribe();
        };
        /**
         * Sort the search results by the given sort code.
         */
        ProductListComponentService.prototype.sort = function (sortCode) {
            this.route({ sortCode: sortCode });
        };
        /**
         * Routes to the next product listing page, using the given `queryParams`. The
         * `queryParams` support sorting, pagination and querying.
         *
         * The `queryParams` are delegated to the Angular router `NavigationExtras`.
         */
        ProductListComponentService.prototype.route = function (queryParams) {
            this.router.navigate([], {
                queryParams: queryParams,
                queryParamsHandling: 'merge',
                relativeTo: this.activatedRoute,
            });
        };
        Object.defineProperty(ProductListComponentService.prototype, "siteContext", {
            /**
             * The site context is used to update the search query in case of a
             * changing context. The context will typically influence the search data.
             *
             * We keep this private for now, as we're likely refactoring this in the next
             * major version.
             */
            get: function () {
                // TODO: we should refactor this so that custom context will be taken
                // into account automatically. Ideally, we drop the specific context
                // from the constructor, and query a ContextService for all contexts.
                return [this.languageService.getActive(), this.currencyService.getActive()];
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @deprecated will be dropped in version 3.0 as it's no longer in use
         */
        ProductListComponentService.prototype.setQuery = function (query) {
            this.route({ query: query, currentPage: undefined });
        };
        /**
         * @deprecated will be dropped in version 3.0 as it's no longer in use
         */
        ProductListComponentService.prototype.viewPage = function (pageNumber) {
            this.route({ currentPage: pageNumber });
        };
        return ProductListComponentService;
    }());
    ProductListComponentService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProductListComponentService_Factory() { return new ProductListComponentService(i0.ɵɵinject(i1.ProductSearchService), i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i4.ActivatedRoute), i0.ɵɵinject(i1.CurrencyService), i0.ɵɵinject(i1.LanguageService), i0.ɵɵinject(i4.Router)); }, token: ProductListComponentService, providedIn: "root" });
    ProductListComponentService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    ProductListComponentService.ctorParameters = function () { return [
        { type: i1.ProductSearchService },
        { type: i1.RoutingService },
        { type: i4.ActivatedRoute },
        { type: i1.CurrencyService },
        { type: i1.LanguageService },
        { type: i4.Router }
    ]; };

    (function (ViewModes) {
        ViewModes["Grid"] = "grid";
        ViewModes["List"] = "list";
    })(exports.ViewModes || (exports.ViewModes = {}));
    var ProductViewComponent = /** @class */ (function () {
        function ProductViewComponent() {
            this.iconTypes = exports.ICON_TYPE;
            this.modeChange = new i0.EventEmitter();
        }
        Object.defineProperty(ProductViewComponent.prototype, "buttonClass", {
            get: function () {
                var viewName = this.viewMode.toLowerCase();
                return "cx-product-" + viewName;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductViewComponent.prototype, "viewMode", {
            /**
             *   Display icons inversely to allow users
             *   to see the view they will navigate to
             */
            get: function () {
                if (this.mode === 'list') {
                    return this.iconTypes.GRID;
                }
                else if (this.mode === 'grid') {
                    return this.iconTypes.LIST;
                }
            },
            enumerable: false,
            configurable: true
        });
        ProductViewComponent.prototype.changeMode = function () {
            var newMode = this.mode === exports.ViewModes.Grid ? exports.ViewModes.List : exports.ViewModes.Grid;
            this.modeChange.emit(newMode);
        };
        return ProductViewComponent;
    }());
    ProductViewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-view',
                    template: "<button\n  class=\"btn cx-product-layout\"\n  [ngClass]=\"buttonClass\"\n  (click)=\"changeMode()\"\n>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.GRID\"\n    [type]=\"iconTypes.GRID\"\n  ></cx-icon>\n  <cx-icon\n    *ngIf=\"viewMode === iconTypes.LIST\"\n    [type]=\"iconTypes.LIST\"\n  ></cx-icon>\n</button>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductViewComponent.propDecorators = {
        mode: [{ type: i0.Input }],
        modeChange: [{ type: i0.Output }]
    };

    var ProductListComponent = /** @class */ (function () {
        function ProductListComponent(pageLayoutService, productListComponentService, scrollConfig) {
            this.pageLayoutService = pageLayoutService;
            this.productListComponentService = productListComponentService;
            this.scrollConfig = scrollConfig;
            this.subscription = new rxjs.Subscription();
            this.model$ = this.productListComponentService
                .model$;
            this.viewMode$ = new rxjs.BehaviorSubject(exports.ViewModes.Grid);
            this.ViewModes = exports.ViewModes;
        }
        ProductListComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.isInfiniteScroll = this.scrollConfig.view.infiniteScroll.active;
            this.subscription.add(this.pageLayoutService.templateName$
                .pipe(operators.take(1))
                .subscribe(function (template) {
                _this.viewMode$.next(template === 'ProductGridPageTemplate'
                    ? exports.ViewModes.Grid
                    : exports.ViewModes.List);
            }));
        };
        ProductListComponent.prototype.sortList = function (sortCode) {
            this.productListComponentService.sort(sortCode);
        };
        ProductListComponent.prototype.setViewMode = function (mode) {
            this.viewMode$.next(mode);
        };
        ProductListComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return ProductListComponent;
    }());
    ProductListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-list',
                    template: "<div class=\"cx-page\" *ngIf=\"model$ | async as model\">\n  <section class=\"cx-page-section\">\n    <div class=\"container\">\n      <div class=\"row\">\n        <div class=\"col-12 col-lg-12\" *ngIf=\"viewMode$ | async as viewMode\">\n          <div class=\"cx-sorting top\">\n            <div class=\"row\">\n              <div class=\"col-12 col-lg-4 mr-auto\">\n                <div class=\"form-group cx-sort-dropdown\">\n                  <cx-sorting\n                    [sortOptions]=\"model.sorts\"\n                    (sortListEvent)=\"sortList($event)\"\n                    [selectedOption]=\"model.pagination.sort\"\n                    placeholder=\"{{\n                      'productList.sortByRelevance' | cxTranslate\n                    }}\"\n                  ></cx-sorting>\n                </div>\n              </div>\n              <div *ngIf=\"!isInfiniteScroll\" class=\"col-auto\">\n                <div\n                  class=\"cx-pagination\"\n                  aria-label=\"product search pagination\"\n                >\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n          <div class=\"cx-product-container\">\n            <!-- Product list when using pagination -->\n            <ng-container *ngIf=\"!isInfiniteScroll; else infiniteScroll\">\n              <ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n                <div class=\"row\">\n                  <cx-product-grid-item\n                    *ngFor=\"let product of model?.products\"\n                    [product]=\"product\"\n                    class=\"col-12 col-sm-6 col-md-4\"\n                  ></cx-product-grid-item>\n                </div>\n              </ng-container>\n\n              <ng-container *ngIf=\"viewMode === ViewModes.List\">\n                <cx-product-list-item\n                  *ngFor=\"let product of model?.products\"\n                  [product]=\"product\"\n                  class=\"cx-product-search-list\"\n                ></cx-product-list-item>\n              </ng-container>\n            </ng-container>\n\n            <!-- Product list when using infinite scroll -->\n            <ng-template #infiniteScroll>\n              <cx-product-scroll\n                [scrollConfig]=\"scrollConfig\"\n                [model]=\"model\"\n                [inputViewMode]=\"viewMode\"\n              ></cx-product-scroll>\n            </ng-template>\n          </div>\n          <div class=\"cx-sorting bottom\">\n            <div class=\"row\">\n              <div class=\"col-12 col-lg-4 mr-auto\">\n                <div class=\"form-group cx-sort-dropdown\">\n                  <cx-sorting\n                    [sortOptions]=\"model.sorts\"\n                    (sortListEvent)=\"sortList($event)\"\n                    [selectedOption]=\"model.pagination.sort\"\n                    placeholder=\"{{\n                      'productList.sortByRelevance' | cxTranslate\n                    }}\"\n                  ></cx-sorting>\n                </div>\n              </div>\n              <div\n                *ngIf=\"!isInfiniteScroll\"\n                class=\"col-auto\"\n                aria-label=\"product search pagination\"\n              >\n                <div class=\"cx-pagination\">\n                  <cx-pagination\n                    [pagination]=\"model.pagination\"\n                    queryParam=\"currentPage\"\n                    [defaultPage]=\"0\"\n                  ></cx-pagination>\n                </div>\n              </div>\n              <div class=\"col-auto ml-auto ml-lg-0\">\n                <cx-product-view\n                  (modeChange)=\"setViewMode($event)\"\n                  [mode]=\"viewMode\"\n                ></cx-product-view>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </section>\n</div>\n"
                },] }
    ];
    ProductListComponent.ctorParameters = function () { return [
        { type: PageLayoutService },
        { type: ProductListComponentService },
        { type: ViewConfig }
    ]; };

    var ProductScrollComponent = /** @class */ (function () {
        function ProductScrollComponent(productListComponentService, ref) {
            this.productListComponentService = productListComponentService;
            this.ref = ref;
            this.subscription = new rxjs.Subscription();
            this.ViewModes = exports.ViewModes;
            this.appendProducts = false;
            this.resetList = false;
            this.isMaxProducts = false;
            this.isLastPage = false;
            this.isEmpty = false;
        }
        Object.defineProperty(ProductScrollComponent.prototype, "setConfig", {
            set: function (inputConfig) {
                this.setComponentConfigurations(inputConfig);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductScrollComponent.prototype, "setModel", {
            set: function (inputModel) {
                this.infiniteScrollOperations(inputModel);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ProductScrollComponent.prototype, "setViewMode", {
            set: function (inputViewMode) {
                this.inputViewMode = inputViewMode;
                //If viewMode is already set (meaning it is not the first load)
                //Reset the product list
                if (this.viewMode) {
                    this.resetListOnViewModeChange();
                }
                else {
                    //If viewMode is not set (meaning it is the first load)
                    //Set the viewMode
                    this.viewMode = inputViewMode;
                }
            },
            enumerable: false,
            configurable: true
        });
        ProductScrollComponent.prototype.scrollPage = function (pageNumber) {
            this.appendProducts = true;
            this.ref.markForCheck();
            this.productListComponentService.getPageItems(pageNumber);
        };
        ProductScrollComponent.prototype.loadNextPage = function (pageNumber) {
            this.isMaxProducts = false;
            this.scrollPage(pageNumber);
        };
        ProductScrollComponent.prototype.scrollToTop = function () {
            window.scroll(0, 0);
        };
        ProductScrollComponent.prototype.setComponentConfigurations = function (scrollConfig) {
            var isButton = scrollConfig.view.infiniteScroll.showMoreButton;
            var configProductLimit = scrollConfig.view.infiniteScroll.productLimit;
            //Display "show more" button every time when button configuration is true
            //Otherwise, only display "show more" when the configuration product limit is reached
            this.productLimit = isButton ? 1 : configProductLimit;
        };
        ProductScrollComponent.prototype.infiniteScrollOperations = function (inputModel) {
            if (this.appendProducts) {
                this.model = Object.assign(Object.assign({}, inputModel), { products: this.model.products.concat(inputModel.products) });
            }
            else {
                this.model = inputModel;
                this.maxProducts = this.productLimit;
            }
            this.setConditions();
            this.ref.markForCheck();
        };
        ProductScrollComponent.prototype.resetListOnViewModeChange = function () {
            this.scrollToTop();
            this.resetList = true;
            this.productListComponentService.getPageItems(0);
        };
        //Set booleans after model has been retrieved
        ProductScrollComponent.prototype.setConditions = function () {
            this.isEmpty = !this.model.products || this.model.products.length === 0;
            this.isLastPage =
                this.model.pagination.currentPage ===
                    this.model.pagination.totalPages - 1;
            this.isMaxProducts =
                this.productLimit &&
                    this.productLimit !== 0 &&
                    this.model.products.length >= this.maxProducts;
            //Add the productLimit to the current number of products to determine the next max number of products
            if (this.isMaxProducts) {
                this.maxProducts = this.model.products.length + this.productLimit;
            }
            //Only change viewMode once the new model is set
            //This prevents flickering issues
            if (this.viewMode !== this.inputViewMode) {
                this.viewMode = this.inputViewMode;
            }
            this.resetList = false;
            this.appendProducts = false;
        };
        ProductScrollComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return ProductScrollComponent;
    }());
    ProductScrollComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-scroll',
                    template: "<ng-container *ngIf=\"viewMode === ViewModes.Grid\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"5\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <div class=\"row\">\n      <cx-product-grid-item\n        *ngFor=\"let product of model?.products\"\n        [product]=\"product\"\n        class=\"col-12 col-sm-6 col-md-4\"\n      ></cx-product-grid-item>\n    </div>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container grid-btn-padding'\n          : 'cx-single-btn-container grid-btn-padding'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"viewMode === ViewModes.List\">\n  <div\n    infiniteScroll\n    [infiniteScrollDistance]=\"3\"\n    [infiniteScrollThrottle]=\"50\"\n    [infiniteScrollDisabled]=\"isMaxProducts || isLastPage || isEmpty\"\n    (scrolled)=\"scrollPage(model?.pagination?.currentPage + 1)\"\n  >\n    <cx-product-list-item\n      *ngFor=\"let product of model?.products\"\n      [product]=\"product\"\n      class=\"cx-product-search-list\"\n    ></cx-product-list-item>\n    <div\n      [className]=\"\n        !isLastPage && model?.pagination?.currentPage > 0\n          ? 'cx-double-btn-container'\n          : 'cx-single-btn-container'\n      \"\n    >\n      <div\n        *ngIf=\"\n          (isMaxProducts || isLastPage) && model?.pagination?.currentPage > 0\n        \"\n        (click)=\"scrollToTop()\"\n        class=\"btn btn-block btn-action\"\n      >\n        {{ 'productList.backToTopBtn' | cxTranslate }}\n      </div>\n      <div\n        *ngIf=\"isMaxProducts && !isLastPage\"\n        (click)=\"loadNextPage(model?.pagination?.currentPage + 1)\"\n        class=\"btn btn-block btn-action align-btn\"\n      >\n        {{ 'productList.showMoreBtn' | cxTranslate }}\n      </div>\n    </div>\n    <div *ngIf=\"appendProducts\" class=\"cx-spinner\">\n      <cx-spinner></cx-spinner>\n    </div>\n  </div>\n</ng-container>\n"
                },] }
    ];
    ProductScrollComponent.ctorParameters = function () { return [
        { type: ProductListComponentService },
        { type: i0.ChangeDetectorRef }
    ]; };
    ProductScrollComponent.propDecorators = {
        setConfig: [{ type: i0.Input, args: ['scrollConfig',] }],
        setModel: [{ type: i0.Input, args: ['model',] }],
        setViewMode: [{ type: i0.Input, args: ['inputViewMode',] }]
    };

    (function (FacetGroupCollapsedState) {
        FacetGroupCollapsedState["EXPANDED"] = "EXPANDED";
        FacetGroupCollapsedState["COLLAPSED"] = "COLLAPSED";
    })(exports.FacetGroupCollapsedState || (exports.FacetGroupCollapsedState = {}));

    /**
     * Provides access to all the facets and active facets for the Product Listing Page.
     */
    var ProductFacetService = /** @class */ (function () {
        function ProductFacetService(routing, productListComponentService) {
            var _this = this;
            this.routing = routing;
            this.productListComponentService = productListComponentService;
            this.routeState$ = this.routing
                .getRouterState()
                .pipe(operators.pluck('state'));
            this.searchResult$ = this.routeState$.pipe(operators.switchMap(function (state) { return _this.productListComponentService.model$.pipe(operators.filter(function (page) { return _this.filterForPage(state, page); }), operators.map(function (page) { return _this.mapResults(state, page); })); }));
            /**
             * Observes the facets and active facets for the given page. The facet data
             * is provided in a `FacetList`.
             */
            this.facetList$ = this.searchResult$.pipe(operators.map(function (result) { return ({
                facets: result.facets,
                activeFacets: result.breadcrumbs,
            }); }));
        }
        /**
         * Filters the current result by verifying if the result is related to the page.
         * This is done to avoid a combination of the next page and the current search results.
         */
        ProductFacetService.prototype.filterForPage = function (state, page) {
            var _a, _b, _c;
            if (state.context.type === i1.PageType.CATEGORY_PAGE) {
                return (((_c = (_b = (_a = page.currentQuery) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.indexOf("allCategories:" + state.context.id)) > -1);
            }
            if (state.context.type === i1.PageType.CONTENT_PAGE &&
                state.context.id === 'search') {
                return page.currentQuery.query.value.startsWith(state.params.query + ":");
            }
            return false;
        };
        ProductFacetService.prototype.mapResults = function (state, page) {
            return Object.assign(Object.assign({}, page), { breadcrumbs: this.filterBreadcrumbs(page.breadcrumbs, state.params) });
        };
        /**
         * filter breadcrumbs which are not actively selected
         * but coming from the route navigation
         */
        ProductFacetService.prototype.filterBreadcrumbs = function (breadcrumbs, params) {
            var _this = this;
            return breadcrumbs
                ? breadcrumbs.filter(function (breadcrumb) { return !_this.hasBreadcrumb(breadcrumb, params); })
                : [];
        };
        /**
         * Indicates whether the breadcrumb is related to navigation parameters,
         * since either the category or brand code should match those codes.
         */
        ProductFacetService.prototype.hasBreadcrumb = function (breadcrumb, params) {
            return (breadcrumb.facetCode === 'allCategories' &&
                (breadcrumb.facetValueCode === params.categoryCode ||
                    breadcrumb.facetValueCode === params.brandCode));
        };
        return ProductFacetService;
    }());
    ProductFacetService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProductFacetService_Factory() { return new ProductFacetService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(ProductListComponentService)); }, token: ProductFacetService, providedIn: "root" });
    ProductFacetService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ProductFacetService.ctorParameters = function () { return [
        { type: i1.RoutingService },
        { type: ProductListComponentService }
    ]; };

    /**
     * Provides access to the facets as well as their UI state. The UI state
     * represents user related changes on the facets, such as expanding or
     * collapsing a facet group or expanding the number of _visible_ facet values.
     */
    var FacetService = /** @class */ (function () {
        function FacetService(productFacetService) {
            var _this = this;
            this.productFacetService = productFacetService;
            /**
             * An internal map where we keep the UI state of the facets.
             */
            this.facetState = new Map();
            /**
             * Observes the facets for the given page and configures the initial UI state.
             *
             * Facets are configured on each emission so that we keep the facet UI state.
             * This is mainly done to keep the state during usage of the facet, but also
             * benefitial when the facets are rebuild while using them.
             */
            this.facetList$ = this.productFacetService.facetList$.pipe(operators.tap(function (facetList) {
                facetList.facets.forEach(function (facet) { return _this.initialize(facet); });
            }));
        }
        /**
         * Returns the observed UI state for the facet.
         *
         * The state is initialized using the `initialize` method.
         */
        FacetService.prototype.getState = function (facet) {
            this.initialize(facet);
            return this.facetState.get(facet.name);
        };
        /**
         * Returns the UI state for the facet.
         *
         * The state is initialized using the `initialize` method.
         */
        FacetService.prototype.getStateSnapshot = function (facet) {
            return this.getState(facet).value;
        };
        /**
         * Toggles the facet expanded state. If the expanded state becomes false,
         * the visible values will decrease to the top values only.
         *
         * If the optional value argument is provided the expanded state will be set
         * to this value, regardless of the current `expanded` state.
         */
        FacetService.prototype.toggle = function (facet, isExpanded) {
            var state = this.getStateSnapshot(facet);
            var toggledState = {
                toggled: isExpanded
                    ? exports.FacetGroupCollapsedState.COLLAPSED
                    : exports.FacetGroupCollapsedState.EXPANDED,
            };
            if (toggledState.toggled === exports.FacetGroupCollapsedState.COLLAPSED) {
                toggledState.maxVisible = state.topVisible;
            }
            this.updateState(facet, toggledState);
        };
        /**
         * Increases the visible values to the maximum values of the facet.
         */
        FacetService.prototype.increaseVisibleValues = function (facet) {
            this.updateState(facet, { maxVisible: facet.values.length });
        };
        /**
         * Decreases the visible values to the topValueCount.
         *
         * The topValueCount defaults to 6, but can be controlled in
         * the backend as well.
         */
        FacetService.prototype.decreaseVisibleValues = function (facet) {
            this.updateState(facet, { maxVisible: facet.topValueCount });
        };
        /**
         * Persists the facet state and initializes the default values for the top
         * and max visible values.
         */
        FacetService.prototype.initialize = function (facet) {
            var _a;
            var topFacets = facet.topValueCount > 0 ? facet.topValueCount : ((_a = facet.values) === null || _a === void 0 ? void 0 : _a.length) || 0;
            if (!this.hasState(facet)) {
                this.facetState.set(facet.name, new rxjs.BehaviorSubject({
                    topVisible: topFacets,
                    maxVisible: topFacets,
                }));
            }
        };
        /**
         * Updates the state of the facet in the local facet map.
         */
        FacetService.prototype.updateState = function (facet, property) {
            var state = Object.assign(Object.assign({}, this.getStateSnapshot(facet)), property);
            this.facetState.get(facet.name).next(state);
        };
        FacetService.prototype.hasState = function (facet) {
            return this.facetState.has(facet.name);
        };
        FacetService.prototype.getLinkParams = function (query) {
            return {
                // to avoid encoding issues with facets that have space (' ') in their name,
                // we replace the decoded '+' back to empty space ' '.
                // For more, see https://github.com/SAP/spartacus/issues/7348
                query: new http.HttpUrlEncodingCodec().decodeValue(query).replace(/\+/g, ' '),
            };
        };
        return FacetService;
    }());
    FacetService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FacetService_Factory() { return new FacetService(i0.ɵɵinject(ProductFacetService)); }, token: FacetService, providedIn: "root" });
    FacetService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    FacetService.ctorParameters = function () { return [
        { type: ProductFacetService }
    ]; };

    /**
     * Active facets render the applied facet values as a list of focusable buttons
     * which can be used to remove the applied facet value.
     */
    var ActiveFacetsComponent = /** @class */ (function () {
        function ActiveFacetsComponent(facetService) {
            this.facetService = facetService;
            /** Active facets which are applied to the product results. */
            this.facetList$ = this.facetService.facetList$;
            /** Configurable icon which is used for the active facet close button */
            this.closeIcon = exports.ICON_TYPE.CLOSE;
        }
        ActiveFacetsComponent.prototype.getLinkParams = function (facet) {
            var _a, _b;
            return this.facetService.getLinkParams((_b = (_a = facet.removeQuery) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.value);
        };
        /**
         * The focus key is used to persist the focus on the facet when the DOM is being
         * recreated. We only apply the focus key for the given _active_ facet when there
         * the original facets is not available. This happens for non multi-valued facets.
         *
         * With this approach, the we keep the focus, either at the facet list or on the
         * active facets.
         */
        ActiveFacetsComponent.prototype.getFocusKey = function (facetList, facet) {
            var _a;
            return ((_a = facetList.facets) === null || _a === void 0 ? void 0 : _a.find(function (f) { var _a; return (_a = f.values) === null || _a === void 0 ? void 0 : _a.find(function (val) { return val.name === facet.facetValueName; }); })) ? ''
                : facet.facetValueName;
        };
        return ActiveFacetsComponent;
    }());
    ActiveFacetsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-active-facets',
                    template: "<ng-container *ngIf=\"facetList$ | async as facetList\">\n  <h4 *ngIf=\"facetList?.activeFacets?.length > 0\">\n    {{ 'productList.appliedFilter' | cxTranslate }}\n  </h4>\n\n  <a\n    *ngFor=\"let facet of facetList?.activeFacets\"\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(facet)\"\n    [cxFocus]=\"getFocusKey(facetList, facet)\"\n  >\n    <span>{{ facet.facetValueName }}</span>\n    <cx-icon aria-hidden=\"true\" [type]=\"closeIcon\"></cx-icon>\n  </a>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.Default
                },] }
    ];
    ActiveFacetsComponent.ctorParameters = function () { return [
        { type: FacetService }
    ]; };
    ActiveFacetsComponent.propDecorators = {
        closeIcon: [{ type: i0.Input }]
    };

    var ActiveFacetsModule = /** @class */ (function () {
        function ActiveFacetsModule() {
        }
        return ActiveFacetsModule;
    }());
    ActiveFacetsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        i1.I18nModule,
                        IconModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [ActiveFacetsComponent],
                    exports: [ActiveFacetsComponent],
                },] }
    ];

    var FacetListComponent = /** @class */ (function () {
        function FacetListComponent(facetService, elementRef, renderer) {
            this.facetService = facetService;
            this.elementRef = elementRef;
            this.renderer = renderer;
            /** Emits when the list must close */
            this.closeList = new i0.EventEmitter();
            /** The list of all facet and values related to the products in the list */
            this.facetList$ = this.facetService.facetList$;
            this.iconTypes = exports.ICON_TYPE;
            this.dialogFocusConfig = {
                trap: true,
                block: true,
                focusOnEscape: true,
                autofocus: 'cx-facet',
            };
        }
        Object.defineProperty(FacetListComponent.prototype, "isDialog", {
            get: function () {
                return this._isDialog;
            },
            /**
             * Indicates that the facet navigation is rendered in dialog.
             */
            set: function (value) {
                this._isDialog = value;
                if (value) {
                    this.renderer.addClass(document.body, 'modal-open');
                }
            },
            enumerable: false,
            configurable: true
        });
        FacetListComponent.prototype.handleClick = function () {
            this.close();
        };
        /**
         * Toggles the facet group in case it is not expanded.
         */
        FacetListComponent.prototype.expandFacetGroup = function (facet, ref) {
            if (!ref.isExpanded) {
                this.facetService.toggle(facet, ref.isExpanded);
            }
        };
        /**
         * Indicates that the facet group has been expanded.
         */
        FacetListComponent.prototype.isExpanded = function (facet) {
            return this.facetService
                .getState(facet)
                .pipe(operators.map(function (value) { return value.toggled === exports.FacetGroupCollapsedState.EXPANDED; }));
        };
        /**
         * Indicates that the facet group has been collapsed.
         */
        FacetListComponent.prototype.isCollapsed = function (facet) {
            return this.facetService
                .getState(facet)
                .pipe(operators.map(function (value) { return value.toggled === exports.FacetGroupCollapsedState.COLLAPSED; }));
        };
        FacetListComponent.prototype.close = function (event) {
            this.renderer.removeClass(document.body, 'modal-open');
            this.closeList.emit(event);
        };
        FacetListComponent.prototype.block = function (event) {
            event.stopPropagation();
        };
        return FacetListComponent;
    }());
    FacetListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-facet-list',
                    template: "<div\n  class=\"inner\"\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\n  (esc)=\"close($event)\"\n  (click)=\"block($event)\"\n>\n  <h4>\n    {{ 'productList.filterBy.label' | cxTranslate }}\n    <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"close()\">\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\n    </button>\n  </h4>\n\n  <!-- \n      Here we'd like to introduce configurable facet components, \n      either by using specific configuration or generic sproutlets \n  -->\n  <cx-facet\n    *ngFor=\"let facet of facets\"\n    #facetRef\n    [facet]=\"facet\"\n    [cxFocus]=\"{ lock: true, trap: true, autofocus: 'a' }\"\n    (unlock)=\"expandFacetGroup(facet, facetRef)\"\n    [class.expanded]=\"isExpanded(facet) | async\"\n    [class.collapsed]=\"isCollapsed(facet) | async\"\n  ></cx-facet>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    FacetListComponent.ctorParameters = function () { return [
        { type: FacetService },
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    FacetListComponent.propDecorators = {
        isDialog: [{ type: i0.Input }],
        closeList: [{ type: i0.Output }],
        handleClick: [{ type: i0.HostListener, args: ['click',] }]
    };

    var FacetComponent = /** @class */ (function () {
        function FacetComponent(facetService, elementRef, cd) {
            this.facetService = facetService;
            this.elementRef = elementRef;
            this.cd = cd;
            /** configurable icon that is used to collapse the facet group  */
            this.expandIcon = exports.ICON_TYPE.EXPAND;
            this.collapseIcon = exports.ICON_TYPE.COLLAPSE;
        }
        Object.defineProperty(FacetComponent.prototype, "facet", {
            get: function () {
                return this._facet;
            },
            set: function (value) {
                this._facet = value;
                this.isMultiSelect = !!value.multiSelect;
                this.state$ = this.facetService.getState(value);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Handles clicking the heading of the facet group, which means toggling
         * the visibility of the group (collapse / expand) and optionally focusing
         * the group.
         */
        FacetComponent.prototype.toggleGroup = function (event) {
            var _a;
            var host = this.elementRef.nativeElement;
            var isLocked = (_a = this.keyboardFocus) === null || _a === void 0 ? void 0 : _a.isLocked;
            this.facetService.toggle(this.facet, this.isExpanded);
            if (!isLocked || this.isExpanded) {
                host.focus();
                // we stop propagating the event as otherwise the focus on the host will trigger
                // an unlock event from the LockFocus directive.
                event.stopPropagation();
            }
        };
        Object.defineProperty(FacetComponent.prototype, "isExpanded", {
            get: function () {
                return this.values.first.nativeElement.offsetParent !== null;
            },
            enumerable: false,
            configurable: true
        });
        FacetComponent.prototype.openLink = function (event) {
            event.target.click();
            event.preventDefault();
        };
        /**
         * Increases the number of visible values for the facet. This is delegated
         * to `facetService.increaseVisibleValues`.
         */
        FacetComponent.prototype.increaseVisibleValues = function () {
            this.facetService.increaseVisibleValues(this.facet);
        };
        /**
         * Decreases the number of visible values for the facet. This is delegated
         * to `facetService.decreaseVisibleValues`.
         */
        FacetComponent.prototype.decreaseVisibleValues = function () {
            this.facetService.decreaseVisibleValues(this.facet);
        };
        FacetComponent.prototype.getLinkParams = function (value) {
            var _a;
            return this.facetService.getLinkParams((_a = value.query) === null || _a === void 0 ? void 0 : _a.query.value);
        };
        return FacetComponent;
    }());
    FacetComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-facet',
                    template: "<ng-container *ngIf=\"state$ | async as state\">\n  <button class=\"heading\" (click)=\"toggleGroup($event)\">\n    {{ facet.name }}\n    <cx-icon class=\"collapse-icon\" [type]=\"collapseIcon\"></cx-icon>\n    <cx-icon class=\"expand-icon\" [type]=\"expandIcon\"></cx-icon>\n  </button>\n\n  <a\n    *ngFor=\"let value of facet.values | slice: 0:state.topVisible\"\n    #facetValue\n    routerLink=\"./\"\n    [queryParams]=\"getLinkParams(value)\"\n    class=\"value\"\n    [class.selected]=\"value.selected\"\n    [cxFocus]=\"value.name\"\n    (keydown.space)=\"openLink($event)\"\n  >\n    <span>\n      <span class=\"label\">{{ value.name }}</span>\n      <span class=\"count\">{{ value.count }}</span>\n    </span>\n  </a>\n\n  <div class=\"more\">\n    <a\n      *ngFor=\"\n        let value of facet.values | slice: state.topVisible:state.maxVisible\n      \"\n      #facetValue\n      routerLink=\"./\"\n      [queryParams]=\"getLinkParams(value)\"\n      class=\"value\"\n      [class.selected]=\"value.selected\"\n      [cxFocus]=\"value.name\"\n      (keydown.space)=\"openLink($event)\"\n    >\n      <span\n        >{{ value.name }}<span class=\"count\">{{ value.count }}</span></span\n      >\n    </a>\n\n    <button\n      *ngIf=\"state.maxVisible > state.topVisible\"\n      (click)=\"decreaseVisibleValues()\"\n      class=\"cx-action-link\"\n      cxFocus=\"moreorless\"\n    >\n      {{ 'productList.showLess' | cxTranslate }}\n    </button>\n\n    <button\n      *ngIf=\"state.maxVisible > 0 && state.maxVisible < facet.values.length\"\n      (click)=\"increaseVisibleValues()\"\n      class=\"cx-action-link\"\n      cxFocus=\"moreorless\"\n    >\n      {{ 'productList.showMore' | cxTranslate }}\n    </button>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    FacetComponent.ctorParameters = function () { return [
        { type: FacetService },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    FacetComponent.propDecorators = {
        expandIcon: [{ type: i0.Input }],
        collapseIcon: [{ type: i0.Input }],
        isMultiSelect: [{ type: i0.HostBinding, args: ['class.multi-select',] }],
        values: [{ type: i0.ViewChildren, args: ['facetValue',] }],
        keyboardFocus: [{ type: i0.ViewChild, args: [FocusDirective,] }],
        facet: [{ type: i0.Input }]
    };

    var FacetModule = /** @class */ (function () {
        function FacetModule() {
        }
        return FacetModule;
    }());
    FacetModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        IconModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [FacetComponent],
                    exports: [FacetComponent],
                },] }
    ];

    var FacetListModule = /** @class */ (function () {
        function FacetListModule() {
        }
        return FacetListModule;
    }());
    FacetListModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        IconModule,
                        FacetModule,
                        KeyboardFocusModule,
                    ],
                    declarations: [FacetListComponent],
                    exports: [FacetListComponent],
                },] }
    ];

    var ProductFacetNavigationComponent = /** @class */ (function () {
        function ProductFacetNavigationComponent(breakpointService) {
            var _this = this;
            this.breakpointService = breakpointService;
            this.iconTypes = exports.ICON_TYPE;
            /**
             * We delay the removal of DOM so that animations can finish playing before the
             * DOM is removed. Removing the DOM, as hidding is not enough to stop elements
             * to be focused.
             */
            this.CLOSE_DELAY = 300;
            this.open$ = new rxjs.BehaviorSubject(false);
            /**
             * Emits the open state that indicates whether the facet list should be rendered.
             * This is either done instantly, or after the user triggers this by using the trigger
             * button. This driven by the visiibility of the trigger, so that the CSS drives
             * the behaviour. This can differ per breakpoint.
             *
             * There's a configurable delay for the closed state, so that the DOM is not removed
             * before some CSS animations are done.
             */
            this.isOpen$ = this.breakpointService.breakpoint$.pipe(
            // deffer emitting a new value to the next micro-task to ensure that the `hasTrigger`
            // method represents the actual UI state.
            operators.observeOn(rxjs.asapScheduler), operators.switchMap(function () { return (_this.hasTrigger ? _this.open$ : rxjs.of(true)); }), operators.delayWhen(function (launched) { return rxjs.interval(launched ? 0 : _this.CLOSE_DELAY); }));
            /**
             * Emits the active state that indicates whether the facet list is activated. Activation
             * is related to the css, so that a animation or transition can visualize opening/closing
             * the list (i.e. dialog).
             */
            this.isActive$ = this.open$.pipe(
            // deffer emitting a new value to the next micro-task to ensure the active class is
            //  applied after the DOM is created
            operators.observeOn(rxjs.asapScheduler));
        }
        ProductFacetNavigationComponent.prototype.launch = function () {
            this.open$.next(true);
        };
        ProductFacetNavigationComponent.prototype.close = function () {
            this.open$.next(false);
            this.trigger.nativeElement.focus();
        };
        Object.defineProperty(ProductFacetNavigationComponent.prototype, "hasTrigger", {
            /**
             * Indicates that the facet navigation should be open explicitely by a trigger.
             * This is fully controlled by CSS, where the trigger button can be hidden
             * (display:none) for certain screen sizes.
             */
            get: function () {
                return this.trigger.nativeElement.offsetParent !== null;
            },
            enumerable: false,
            configurable: true
        });
        return ProductFacetNavigationComponent;
    }());
    ProductFacetNavigationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-facet-navigation',
                    template: "<button\n  #trigger\n  class=\"btn btn-action btn-block dialog-trigger\"\n  (click)=\"launch()\"\n>\n  <cx-icon [type]=\"iconTypes.FILTER\"></cx-icon>\n  {{ 'productList.filterBy.label' | cxTranslate }}\n</button>\n\n<cx-active-facets></cx-active-facets>\n\n<cx-facet-list\n  *ngIf=\"isOpen$ | async\"\n  [isDialog]=\"hasTrigger\"\n  (closeList)=\"close()\"\n  [class.active]=\"isActive$ | async\"\n  [class.dialog]=\"hasTrigger\"\n></cx-facet-list>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductFacetNavigationComponent.ctorParameters = function () { return [
        { type: BreakpointService }
    ]; };
    ProductFacetNavigationComponent.propDecorators = {
        trigger: [{ type: i0.ViewChild, args: ['trigger',] }]
    };

    var ProductFacetNavigationModule = /** @class */ (function () {
        function ProductFacetNavigationModule() {
        }
        return ProductFacetNavigationModule;
    }());
    ProductFacetNavigationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        FacetListModule,
                        ActiveFacetsModule,
                        IconModule,
                        i1.I18nModule,
                        i1.ConfigModule.withConfig({
                            cmsComponents: {
                                ProductRefinementComponent: {
                                    component: ProductFacetNavigationComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductFacetNavigationComponent],
                    exports: [ProductFacetNavigationComponent],
                },] }
    ];

    var ProductGridItemComponent = /** @class */ (function () {
        function ProductGridItemComponent() {
        }
        return ProductGridItemComponent;
    }());
    ProductGridItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-grid-item',
                    template: "<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-image-container\"\n  tabindex=\"-1\"\n>\n  <cx-media\n    class=\"cx-product-image\"\n    [container]=\"product.images?.PRIMARY\"\n    [alt]=\"product.summary\"\n  ></cx-media>\n</a>\n<a\n  [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n  class=\"cx-product-name\"\n  [innerHTML]=\"product.nameHtml\"\n></a>\n\n<div class=\"cx-product-rating\">\n  <cx-star-rating\n    *ngIf=\"product.averageRating\"\n    [rating]=\"product?.averageRating\"\n    [disabled]=\"true\"\n  ></cx-star-rating>\n  <div *ngIf=\"!product.averageRating\">\n    {{ 'productDetails.noReviews' | cxTranslate }}\n  </div>\n</div>\n<div class=\"cx-product-price-container\">\n  <div class=\"cx-product-price\" aria-label=\"Product price\">\n    {{ product.price?.formattedValue }}\n  </div>\n</div>\n\n<div class=\"cx-variant-style-icons\" *ngIf=\"product.variantOptions\">\n  <cx-variant-style-icons\n    [variants]=\"product.variantOptions\"\n  ></cx-variant-style-icons>\n</div>\n\n<cx-add-to-cart\n  *ngIf=\"product.stock?.stockLevelStatus !== 'outOfStock'\"\n  [showQuantity]=\"false\"\n  [product]=\"product\"\n></cx-add-to-cart>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductGridItemComponent.propDecorators = {
        product: [{ type: i0.Input }]
    };

    var ProductListItemComponent = /** @class */ (function () {
        function ProductListItemComponent() {
        }
        return ProductListItemComponent;
    }());
    ProductListItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-list-item',
                    template: "<div class=\"row\">\n  <div class=\"col-12 col-md-4\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-image-container\"\n      tabindex=\"-1\"\n    >\n      <cx-media\n        class=\"cx-product-image\"\n        [container]=\"product.images?.PRIMARY\"\n        [alt]=\"product.summary\"\n      ></cx-media>\n    </a>\n  </div>\n  <div class=\"col-12 col-md-8\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: product } | cxUrl\"\n      class=\"cx-product-name\"\n      [innerHtml]=\"product.nameHtml\"\n    ></a>\n    <cx-star-rating\n      *ngIf=\"product.averageRating\"\n      [rating]=\"product?.averageRating\"\n      [disabled]=\"true\"\n    ></cx-star-rating>\n    <div *ngIf=\"!product.averageRating\" class=\"cx-product-no-review\">\n      {{ 'productDetails.noReviews' | cxTranslate }}\n    </div>\n    <div class=\"cx-product-price\" aria-label=\"Product price\">\n      {{ product.price?.formattedValue }}\n    </div>\n\n    <cx-variant-style-icons\n      *ngIf=\"product.variantOptions\"\n      [variants]=\"product.variantOptions\"\n    ></cx-variant-style-icons>\n\n    <div class=\"row\">\n      <div class=\"col-12 col-md-8\">\n        <p class=\"cx-product-summary\" [innerHtml]=\"product.summary\">\n          {{ product.summary }}\n        </p>\n      </div>\n      <div class=\"col-12 col-md-4\">\n        <cx-add-to-cart\n          *ngIf=\"product.stock?.stockLevelStatus !== 'outOfStock'\"\n          [showQuantity]=\"false\"\n          [product]=\"product\"\n        ></cx-add-to-cart>\n      </div>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductListItemComponent.propDecorators = {
        product: [{ type: i0.Input }]
    };

    var ProductVariantsComponent = /** @class */ (function () {
        function ProductVariantsComponent(currentProductService) {
            this.currentProductService = currentProductService;
            this.variants = [];
            this.variantType = i1.VariantType;
        }
        ProductVariantsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.product$ = this.currentProductService.getProduct().pipe(operators.filter(function (product) { return !!(product && product.baseOptions); }), operators.distinctUntilChanged(), operators.tap(function (product) {
                product.baseOptions.forEach(function (option) {
                    if (option && option.variantType) {
                        _this.variants[option.variantType] = option;
                    }
                });
            }));
        };
        return ProductVariantsComponent;
    }());
    ProductVariantsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-variants',
                    template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"variant-section\" *ngIf=\"product.baseOptions?.length\">\n    <cx-variant-style-selector\n      *ngIf=\"variants[variantType.STYLE]\"\n      [variants]=\"variants[variantType.STYLE]\"\n    ></cx-variant-style-selector>\n    <cx-variant-size-selector\n      *ngIf=\"variants[variantType.SIZE]\"\n      [product]=\"product\"\n      [variants]=\"variants[variantType.SIZE]\"\n    ></cx-variant-size-selector>\n    <cx-variant-color-selector\n      *ngIf=\"variants[variantType.COLOR]\"\n      [product]=\"product\"\n      [variants]=\"variants[variantType.COLOR]\"\n    ></cx-variant-color-selector>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductVariantsComponent.ctorParameters = function () { return [
        { type: CurrentProductService }
    ]; };

    var VariantStyleSelectorComponent = /** @class */ (function () {
        function VariantStyleSelectorComponent(config, productService, routingService) {
            this.config = config;
            this.productService = productService;
            this.routingService = routingService;
            this.variantQualifier = i1.VariantQualifier;
        }
        VariantStyleSelectorComponent.prototype.getVariantOptionValue = function (qualifiers) {
            var obj = qualifiers.find(function (q) { return q.qualifier === i1.VariantQualifier.STYLE; });
            return obj ? obj.value : '';
        };
        VariantStyleSelectorComponent.prototype.getVariantThumbnailUrl = function (variantOptionQualifiers) {
            var qualifier = variantOptionQualifiers.find(function (item) { return item.image; });
            return qualifier
                ? "" + this.config.backend.occ.baseUrl + qualifier.image.url
                : '';
        };
        VariantStyleSelectorComponent.prototype.changeStyle = function (code) {
            var _this = this;
            if (code) {
                this.productService
                    .get(code, i1.ProductScope.LIST)
                    .pipe(
                // below call might looks redundant but in fact this data is going to be loaded anyways
                // we're just calling it earlier and storing
                operators.filter(Boolean), operators.take(1))
                    .subscribe(function (product) {
                    _this.routingService.go({
                        cxRoute: 'product',
                        params: product,
                    });
                });
            }
            return null;
        };
        return VariantStyleSelectorComponent;
    }());
    VariantStyleSelectorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-variant-style-selector',
                    template: "<ng-container>\n  <div class=\"variant-selector\">\n    <div *ngIf=\"variants.selected\" class=\"variant-name\">\n      {{ 'variant.style' | cxTranslate }}:\n      <span class=\"style-name\">{{\n        getVariantOptionValue(variants?.selected.variantOptionQualifiers)\n      }}</span>\n    </div>\n    <ul class=\"variant-list\">\n      <li\n        *ngFor=\"let v of variants?.options\"\n        [ngClass]=\"{\n          'selected-variant': v.code === variants?.selected.code\n        }\"\n      >\n        <button class=\"variant-button\" (click)=\"changeStyle(v.code)\">\n          <img\n            src=\"{{ getVariantThumbnailUrl(v.variantOptionQualifiers) }}\"\n            title=\"{{ getVariantOptionValue(v.variantOptionQualifiers) }}\"\n            alt=\"{{ getVariantOptionValue(v.variantOptionQualifiers) }}\"\n          />\n        </button>\n      </li>\n    </ul>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    VariantStyleSelectorComponent.ctorParameters = function () { return [
        { type: i1.OccConfig },
        { type: i1.ProductService },
        { type: i1.RoutingService }
    ]; };
    VariantStyleSelectorComponent.propDecorators = {
        variants: [{ type: i0.Input }]
    };

    var VariantStyleSelectorModule = /** @class */ (function () {
        function VariantStyleSelectorModule() {
        }
        return VariantStyleSelectorModule;
    }());
    VariantStyleSelectorModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.UrlModule, i1.I18nModule],
                    declarations: [VariantStyleSelectorComponent],
                    entryComponents: [VariantStyleSelectorComponent],
                    exports: [VariantStyleSelectorComponent],
                },] }
    ];

    var VariantSizeSelectorComponent = /** @class */ (function () {
        function VariantSizeSelectorComponent(productService, routingService) {
            this.productService = productService;
            this.routingService = routingService;
        }
        VariantSizeSelectorComponent.prototype.changeSize = function (code) {
            var _this = this;
            if (code) {
                this.productService
                    .get(code, i1.ProductScope.LIST)
                    .pipe(
                // below call might looks redundant but in fact this data is going to be loaded anyways
                // we're just calling it earlier and storing
                operators.filter(Boolean), operators.take(1))
                    .subscribe(function (product) {
                    _this.routingService.go({
                        cxRoute: 'product',
                        params: product,
                    });
                });
            }
            return null;
        };
        VariantSizeSelectorComponent.prototype.getVariantOptionValue = function (qualifiers) {
            var obj = qualifiers.find(function (q) { return q.qualifier === i1.VariantQualifier.SIZE; });
            return obj ? obj.value : '';
        };
        return VariantSizeSelectorComponent;
    }());
    VariantSizeSelectorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-variant-size-selector',
                    template: "<ng-container>\n  <div class=\"variant-selector\">\n    <div class=\"variant-name\">{{ 'variant.size' | cxTranslate }}:</div>\n    <select\n      (change)=\"changeSize($event.target.value)\"\n      class=\"form-control variant-select\"\n    >\n      <option\n        *ngFor=\"let v of variants?.options\"\n        value=\"{{ v.code }}\"\n        [selected]=\"v.code === product?.code\"\n      >\n        {{ getVariantOptionValue(v.variantOptionQualifiers) }}\n      </option>\n    </select>\n    <a\n      href=\"#\"\n      class=\"size-guide\"\n      title=\"{{ 'variant.sizeGuideLabel' | cxTranslate }}\"\n    >\n      {{ 'variant.sizeGuideLabel' | cxTranslate }}\n    </a>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    VariantSizeSelectorComponent.ctorParameters = function () { return [
        { type: i1.ProductService },
        { type: i1.RoutingService }
    ]; };
    VariantSizeSelectorComponent.propDecorators = {
        product: [{ type: i0.Input }],
        variants: [{ type: i0.Input }]
    };

    var VariantSizeSelectorModule = /** @class */ (function () {
        function VariantSizeSelectorModule() {
        }
        return VariantSizeSelectorModule;
    }());
    VariantSizeSelectorModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.UrlModule, i1.I18nModule],
                    declarations: [VariantSizeSelectorComponent],
                    entryComponents: [VariantSizeSelectorComponent],
                    exports: [VariantSizeSelectorComponent],
                },] }
    ];

    var VariantColorSelectorComponent = /** @class */ (function () {
        function VariantColorSelectorComponent(routingService) {
            this.routingService = routingService;
        }
        VariantColorSelectorComponent.prototype.changeColor = function (code, name) {
            if (code) {
                this.routingService.go({
                    cxRoute: 'product',
                    params: { code: code, name: name },
                });
            }
            return null;
        };
        VariantColorSelectorComponent.prototype.getVariantOptionValue = function (qualifiers) {
            var obj = qualifiers.find(function (q) { return q.qualifier === i1.VariantQualifier.COLOR; });
            return obj ? obj.value : '';
        };
        return VariantColorSelectorComponent;
    }());
    VariantColorSelectorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-variant-color-selector',
                    template: "<ng-container>\n  <div class=\"variant-selector\">\n    <div class=\"variant-name\">{{ 'variant.color' | cxTranslate }}:</div>\n\n    <select\n      (change)=\"changeColor($event.target.value, product?.name)\"\n      class=\"form-control variant-select\"\n    >\n      <option\n        *ngFor=\"let v of variants?.options\"\n        value=\"{{ v.code }}\"\n        [selected]=\"v.code === product?.code\"\n      >\n        {{ getVariantOptionValue(v.variantOptionQualifiers) }}\n      </option>\n    </select>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    VariantColorSelectorComponent.ctorParameters = function () { return [
        { type: i1.RoutingService }
    ]; };
    VariantColorSelectorComponent.propDecorators = {
        product: [{ type: i0.Input }],
        variants: [{ type: i0.Input }]
    };

    var VariantColorSelectorModule = /** @class */ (function () {
        function VariantColorSelectorModule() {
        }
        return VariantColorSelectorModule;
    }());
    VariantColorSelectorModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.UrlModule, i1.I18nModule],
                    declarations: [VariantColorSelectorComponent],
                    entryComponents: [VariantColorSelectorComponent],
                    exports: [VariantColorSelectorComponent],
                },] }
    ];

    var VariantStyleIconsComponent = /** @class */ (function () {
        function VariantStyleIconsComponent(config) {
            this.config = config;
            this.variantNames = {};
        }
        VariantStyleIconsComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.variants.forEach(function (variant) {
                _this.variantNames[variant.code] = _this.getVariantName(variant.variantOptionQualifiers);
            });
        };
        VariantStyleIconsComponent.prototype.getVariantThumbnailUrl = function (variantOptionQualifiers) {
            var thumbnail = variantOptionQualifiers.find(function (item) { return item.qualifier === i1.VariantQualifier.THUMBNAIL; });
            return thumbnail
                ? "" + this.config.backend.occ.baseUrl + thumbnail.image.url
                : '';
        };
        VariantStyleIconsComponent.prototype.getVariantName = function (variantOptionQualifiers) {
            var rollupProperty = variantOptionQualifiers.find(function (item) { return item.qualifier === i1.VariantQualifier.ROLLUP_PROPERTY; });
            var property = rollupProperty
                ? variantOptionQualifiers.find(function (item) { return item.qualifier === rollupProperty.value; })
                : null;
            return property ? property.value : '';
        };
        return VariantStyleIconsComponent;
    }());
    VariantStyleIconsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-variant-style-icons',
                    template: "<ul class=\"variant-list\">\n  <li *ngFor=\"let v of variants\">\n    <img\n      [attr.src]=\"getVariantThumbnailUrl(v.variantOptionQualifiers)\"\n      [attr.title]=\"variantNames[v.code]\"\n      [attr.alt]=\"variantNames[v.code]\"\n    />\n  </li>\n</ul>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    styles: ["ul{overflow:hidden;padding:0;white-space:nowrap}ul li{display:inline}ul li img{width:50px}"]
                },] }
    ];
    VariantStyleIconsComponent.ctorParameters = function () { return [
        { type: i1.OccConfig }
    ]; };
    VariantStyleIconsComponent.propDecorators = {
        variants: [{ type: i0.Input }]
    };

    var VariantStyleIconsModule = /** @class */ (function () {
        function VariantStyleIconsModule() {
        }
        return VariantStyleIconsModule;
    }());
    VariantStyleIconsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.UrlModule, i1.I18nModule],
                    declarations: [VariantStyleIconsComponent],
                    entryComponents: [VariantStyleIconsComponent],
                    exports: [VariantStyleIconsComponent],
                },] }
    ];

    var ProductVariantGuard = /** @class */ (function () {
        function ProductVariantGuard(productService, routingService) {
            this.productService = productService;
            this.routingService = routingService;
        }
        ProductVariantGuard.prototype.canActivate = function () {
            var _this = this;
            return this.routingService.getRouterState().pipe(operators.map(function (state) { return state.nextState.params.productCode; }), operators.switchMap(function (productCode) {
                // if open pdp from smartedit
                if (!productCode) {
                    return rxjs.of(true);
                }
                return _this.productService.get(productCode, i1.ProductScope.VARIANTS).pipe(operators.filter(Boolean), operators.map(function (product) {
                    if (!product.purchasable) {
                        var variant = _this.findVariant(product.variantOptions);
                        // below call might looks redundant but in fact this data is going to be loaded anyways
                        // we're just calling it earlier and storing
                        _this.productService
                            .get(variant.code, i1.ProductScope.LIST)
                            .pipe(operators.filter(Boolean), operators.take(1))
                            .subscribe(function (_product) {
                            _this.routingService.go({
                                cxRoute: 'product',
                                params: _product,
                            });
                        });
                        return false;
                    }
                    else {
                        return true;
                    }
                }));
            }));
        };
        ProductVariantGuard.prototype.findVariant = function (variants) {
            var results = variants.filter(function (variant) {
                return variant.stock && variant.stock.stockLevel ? variant : false;
            });
            return !results.length && variants.length ? variants[0] : results[0];
        };
        return ProductVariantGuard;
    }());
    ProductVariantGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProductVariantGuard_Factory() { return new ProductVariantGuard(i0.ɵɵinject(i1.ProductService), i0.ɵɵinject(i1.RoutingService)); }, token: ProductVariantGuard, providedIn: "root" });
    ProductVariantGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ProductVariantGuard.ctorParameters = function () { return [
        { type: i1.ProductService },
        { type: i1.RoutingService }
    ]; };

    var ProductVariantsModule = /** @class */ (function () {
        function ProductVariantsModule() {
        }
        return ProductVariantsModule;
    }());
    ProductVariantsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        VariantStyleSelectorModule,
                        VariantSizeSelectorModule,
                        VariantColorSelectorModule,
                        VariantStyleIconsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductVariantSelectorComponent: {
                                    component: ProductVariantsComponent,
                                    guards: [ProductVariantGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [ProductVariantsComponent],
                    entryComponents: [ProductVariantsComponent],
                    exports: [VariantStyleIconsComponent],
                },] }
    ];

    var ProductListModule = /** @class */ (function () {
        function ProductListModule() {
        }
        return ProductListModule;
    }());
    ProductListModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        MediaModule,
                        AddToCartModule,
                        ItemCounterModule,
                        ListNavigationModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        StarRatingModule,
                        IconModule,
                        SpinnerModule,
                        ngxInfiniteScroll.InfiniteScrollModule,
                        ViewConfigModule,
                        ProductVariantsModule,
                        i1.FeaturesConfigModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig(defaultScrollConfig),
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                CMSProductListComponent: {
                                    component: ProductListComponent,
                                },
                                ProductGridComponent: {
                                    component: ProductListComponent,
                                },
                                SearchResultsListComponent: {
                                    component: ProductListComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [
                        ProductListComponent,
                        ProductListItemComponent,
                        ProductGridItemComponent,
                        ProductViewComponent,
                        ProductScrollComponent,
                    ],
                    exports: [
                        ProductListComponent,
                        ProductListItemComponent,
                        ProductGridItemComponent,
                        ProductViewComponent,
                        ProductScrollComponent,
                    ],
                    entryComponents: [ProductListComponent, ProductFacetNavigationComponent],
                },] }
    ];

    (function (ProductDetailOutlets) {
        ProductDetailOutlets["INTRO"] = "PDP.INTRO";
        ProductDetailOutlets["PRICE"] = "PDP.PRICE";
        ProductDetailOutlets["SHARE"] = "PDP.SHARE";
        ProductDetailOutlets["SUMMARY"] = "PDP.SUMMARY";
    })(exports.ProductDetailOutlets || (exports.ProductDetailOutlets = {}));

    var ProductSummaryComponent = /** @class */ (function () {
        function ProductSummaryComponent(currentProductService) {
            this.currentProductService = currentProductService;
            this.outlets = exports.ProductDetailOutlets;
            this.product$ = this.currentProductService.getProduct();
        }
        return ProductSummaryComponent;
    }());
    ProductSummaryComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-summary',
                    template: "<ng-container *ngIf=\"product$ | async as product\">\n  <ng-template\n    [cxOutlet]=\"outlets.PRICE\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <div class=\"price\" aria-label=\"new item price\">\n      {{ product?.price?.formattedValue }}\n    </div>\n  </ng-template>\n\n  <ng-template\n    [cxOutlet]=\"outlets.SUMMARY\"\n    [cxOutletContext]=\"{ product: product }\"\n  >\n    <p [innerHTML]=\"product?.summary\" class=\"summary\"></p>\n  </ng-template>\n\n  <!-- @TODO: Temp. Comment out share link while not in use by CMS -->\n  <!-- <ng-container *cxOutlet=\"outlets.SHARE\">\n        <div>\n          <a href=\"#\" class=\"share btn-link\">\n            {{ 'productSummary.share' | cxTranslate }}\n          </a>\n        </div>\n      </ng-container> -->\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductSummaryComponent.ctorParameters = function () { return [
        { type: CurrentProductService }
    ]; };

    var ProductSummaryModule = /** @class */ (function () {
        function ProductSummaryModule() {
        }
        return ProductSummaryModule;
    }());
    ProductSummaryModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, OutletModule, i1.I18nModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductSummaryComponent: {
                                    component: ProductSummaryComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductSummaryComponent],
                    entryComponents: [ProductSummaryComponent],
                    exports: [ProductSummaryComponent],
                },] }
    ];

    var ProductAttributesComponent = /** @class */ (function () {
        function ProductAttributesComponent(currentProductService) {
            this.currentProductService = currentProductService;
            this.product$ = this.currentProductService.getProduct(i1.ProductScope.ATTRIBUTES);
        }
        return ProductAttributesComponent;
    }());
    ProductAttributesComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-attributes',
                    template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\">\n    <h2>{{ 'productDetails.specification' | cxTranslate }}</h2>\n    <table *ngFor=\"let class of product?.classifications\">\n      <th>\n        <h3>{{ class.name }}</h3>\n      </th>\n      <tr *ngFor=\"let feature of class.features\">\n        <td>{{ feature.name }}</td>\n        <td>\n          <ul>\n            <li *ngFor=\"let featureValue of feature?.featureValues\">\n              {{ featureValue?.value }}\n            </li>\n          </ul>\n        </td>\n      </tr>\n    </table>\n  </div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductAttributesComponent.ctorParameters = function () { return [
        { type: CurrentProductService }
    ]; };

    var ProductAttributesModule = /** @class */ (function () {
        function ProductAttributesModule() {
        }
        return ProductAttributesModule;
    }());
    ProductAttributesModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i1.I18nModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductSpecsTabComponent: {
                                    component: ProductAttributesComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductAttributesComponent],
                    entryComponents: [ProductAttributesComponent],
                    exports: [ProductAttributesComponent],
                },] }
    ];

    var ProductDetailsTabComponent = /** @class */ (function () {
        function ProductDetailsTabComponent(currentProductService) {
            this.currentProductService = currentProductService;
        }
        ProductDetailsTabComponent.prototype.ngOnInit = function () {
            this.product$ = this.currentProductService.getProduct();
        };
        return ProductDetailsTabComponent;
    }());
    ProductDetailsTabComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-details-tab',
                    template: "<ng-container *ngIf=\"product$ | async as product\">\n  <div class=\"container\" [innerHTML]=\"product?.description\"></div>\n</ng-container>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductDetailsTabComponent.ctorParameters = function () { return [
        { type: CurrentProductService }
    ]; };

    var ProductDetailsTabModule = /** @class */ (function () {
        function ProductDetailsTabModule() {
        }
        return ProductDetailsTabModule;
    }());
    ProductDetailsTabModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductDetailsTabComponent: {
                                    component: ProductDetailsTabComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductDetailsTabComponent],
                    entryComponents: [ProductDetailsTabComponent],
                    exports: [ProductDetailsTabComponent],
                },] }
    ];

    var ProductReviewsComponent = /** @class */ (function () {
        function ProductReviewsComponent(reviewService, currentProductService, fb, cd) {
            var _this = this;
            this.reviewService = reviewService;
            this.currentProductService = currentProductService;
            this.fb = fb;
            this.cd = cd;
            this.isWritingReview = false;
            // TODO: configurable
            this.initialMaxListItems = 5;
            this.product$ = this.currentProductService.getProduct();
            this.reviews$ = this.product$.pipe(operators.filter(function (p) { return !!p; }), operators.map(function (p) { return p.code; }), operators.distinctUntilChanged(), operators.switchMap(function (productCode) { return _this.reviewService.getByProductCode(productCode); }), operators.tap(function () {
                _this.resetReviewForm();
                _this.maxListItems = _this.initialMaxListItems;
            }));
        }
        ProductReviewsComponent.prototype.initiateWriteReview = function () {
            this.isWritingReview = true;
            this.cd.detectChanges();
            if (this.titleInput && this.titleInput.nativeElement) {
                this.titleInput.nativeElement.focus();
            }
        };
        ProductReviewsComponent.prototype.cancelWriteReview = function () {
            this.isWritingReview = false;
            this.resetReviewForm();
            this.cd.detectChanges();
            if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
                this.writeReviewButton.nativeElement.focus();
            }
        };
        ProductReviewsComponent.prototype.setRating = function (rating) {
            this.reviewForm.controls.rating.setValue(rating);
        };
        ProductReviewsComponent.prototype.submitReview = function (product) {
            if (this.reviewForm.valid) {
                this.addReview(product);
            }
            else {
                this.reviewForm.markAllAsTouched();
            }
        };
        ProductReviewsComponent.prototype.addReview = function (product) {
            var reviewFormControls = this.reviewForm.controls;
            var review = {
                headline: reviewFormControls.title.value,
                comment: reviewFormControls.comment.value,
                rating: reviewFormControls.rating.value,
                alias: reviewFormControls.reviewerName.value,
            };
            this.reviewService.add(product.code, review);
            this.isWritingReview = false;
            this.resetReviewForm();
            this.cd.detectChanges();
            if (this.writeReviewButton && this.writeReviewButton.nativeElement) {
                this.writeReviewButton.nativeElement.focus();
            }
        };
        ProductReviewsComponent.prototype.resetReviewForm = function () {
            this.reviewForm = this.fb.group({
                title: ['', forms.Validators.required],
                comment: ['', forms.Validators.required],
                rating: [null, CustomFormValidators.starRatingEmpty],
                reviewerName: '',
            });
        };
        return ProductReviewsComponent;
    }());
    ProductReviewsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-product-reviews',
                    template: "<div class=\"container\" *ngIf=\"product$ | async as product\">\n  <h2>\n    {{ 'productDetails.reviews' | cxTranslate }} ({{ product.numberOfReviews }})\n  </h2>\n  <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n    <div class=\"header\">\n      <h3>{{ 'productReview.overallRating' | cxTranslate }}</h3>\n      <button\n        #writeReviewButton\n        class=\"btn btn-primary\"\n        (click)=\"initiateWriteReview()\"\n      >\n        {{ 'productReview.writeReview' | cxTranslate }}\n      </button>\n      <cx-star-rating\n        *ngIf=\"product.averageRating\"\n        class=\"rating\"\n        [rating]=\"product.averageRating\"\n        [disabled]=\"true\"\n      ></cx-star-rating>\n      <div class=\"rating\" *ngIf=\"!product.averageRating\">\n        {{ 'productDetails.noReviews' | cxTranslate }}\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"!isWritingReview; else writeReview\">\n      <ng-container *ngIf=\"reviews$ | async as reviews\">\n        <div\n          class=\"review\"\n          tabindex=\"0\"\n          *ngFor=\"let review of reviews | slice: 0:maxListItems\"\n        >\n          <div class=\"title\">{{ review.headline }}</div>\n          <cx-star-rating\n            [rating]=\"review.rating\"\n            [disabled]=\"true\"\n          ></cx-star-rating>\n          <div class=\"name\">\n            {{ review.alias ? review.alias : review.principal?.name }}\n          </div>\n          <div class=\"date\">{{ review.date | cxDate }}</div>\n          <div class=\"text\">{{ review.comment }}</div>\n        </div>\n        <div *ngIf=\"reviews.length > initialMaxListItems\">\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = reviews.length\"\n            *ngIf=\"maxListItems === initialMaxListItems\"\n          >\n            {{ 'productReview.more' | cxTranslate }}\n          </button>\n          <button\n            class=\"btn btn-primary\"\n            (click)=\"maxListItems = initialMaxListItems\"\n            *ngIf=\"maxListItems !== initialMaxListItems\"\n          >\n            {{ 'productReview.less' | cxTranslate }}\n          </button>\n        </div>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #writeReview>\n    <form (ngSubmit)=\"submitReview(product)\" [formGroup]=\"reviewForm\">\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewTitle' | cxTranslate\n          }}</span>\n          <input\n            #titleInput\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"title\"\n          />\n          <cx-form-errors [control]=\"reviewForm.get('title')\"></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.writeYourComments' | cxTranslate\n          }}</span>\n          <textarea\n            class=\"form-control\"\n            rows=\"3\"\n            formControlName=\"comment\"\n          ></textarea>\n          <cx-form-errors\n            [control]=\"reviewForm.get('comment')\"\n          ></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.rating' | cxTranslate\n          }}</span>\n          <input type=\"number\" formControlName=\"rating\" class=\"rating-input\" />\n          <cx-star-rating (change)=\"setRating($event)\"></cx-star-rating>\n          <cx-form-errors [control]=\"reviewForm.get('rating')\"></cx-form-errors>\n        </label>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <span class=\"label-content\">{{\n            'productReview.reviewerName' | cxTranslate\n          }}</span>\n          <input\n            type=\"text\"\n            class=\"form-control\"\n            formControlName=\"reviewerName\"\n          />\n        </label>\n      </div>\n      <div class=\"form-group row\">\n        <div class=\"col-12 col-md-4\">\n          <button\n            type=\"button\"\n            class=\"btn btn-block btn-secondary\"\n            (click)=\"cancelWriteReview()\"\n          >\n            {{ 'common.cancel' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-12 col-md-4\">\n          <button type=\"submit\" class=\"btn btn-block btn-primary\">\n            {{ 'common.submit' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </form>\n  </ng-template>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    ProductReviewsComponent.ctorParameters = function () { return [
        { type: i1.ProductReviewService },
        { type: CurrentProductService },
        { type: forms.FormBuilder },
        { type: i0.ChangeDetectorRef }
    ]; };
    ProductReviewsComponent.propDecorators = {
        titleInput: [{ type: i0.ViewChild, args: ['titleInput', { static: false },] }],
        writeReviewButton: [{ type: i0.ViewChild, args: ['writeReviewButton', { static: false },] }]
    };

    var ProductReviewsModule = /** @class */ (function () {
        function ProductReviewsModule() {
        }
        return ProductReviewsModule;
    }());
    ProductReviewsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        forms.FormsModule,
                        i1.I18nModule,
                        StarRatingModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ProductReviewsTabComponent: {
                                    component: ProductReviewsComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [ProductReviewsComponent],
                    entryComponents: [ProductReviewsComponent],
                    exports: [ProductReviewsComponent],
                },] }
    ];

    var ProductTabsModule = /** @class */ (function () {
        function ProductTabsModule() {
        }
        return ProductTabsModule;
    }());
    ProductTabsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        ProductAttributesModule,
                        ProductDetailsTabModule,
                        ProductReviewsModule,
                    ],
                },] }
    ];

    var StockNotificationDialogComponent = /** @class */ (function () {
        function StockNotificationDialogComponent(modalService, interestsService) {
            this.modalService = modalService;
            this.interestsService = interestsService;
            this.enabledPrefs = [];
        }
        StockNotificationDialogComponent.prototype.close = function () {
            this.modalService.dismissActiveModal();
        };
        StockNotificationDialogComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            if (this.subscribeSuccess$) {
                this.subscribeSuccess$
                    .subscribe(function (success) {
                    if (success) {
                        _this.interestsService.resetAddInterestState();
                    }
                })
                    .unsubscribe();
            }
        };
        return StockNotificationDialogComponent;
    }());
    StockNotificationDialogComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-stock-notification-dialog',
                    template: "<div class=\"cx-dialog-header modal-header\">\n  <div class=\"cx-dialog-title modal-title\">\n    {{ 'stockNotification.subscriptionDialog.header' | cxTranslate }}\n  </div>\n  <button\n    type=\"button\"\n    class=\"close\"\n    aria-label=\"Close\"\n    tabindex=\"-1\"\n    (click)=\"close()\"\n  >\n    <span aria-hidden=\"true\">&times;</span>\n  </button>\n</div>\n\n<ng-container *ngIf=\"subscribeSuccess$ | async; else loading\">\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"container\">\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.notifiedPrefix' | cxTranslate\n        }}\n      </p>\n      <p *ngFor=\"let preference of enabledPrefs\" class=\"channels\">\n        <span>{{ preference.channel }}</span\n        ><span *ngIf=\"preference.value\">{{ ': ' + preference.value }}</span>\n      </p>\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.notifiedSuffix' | cxTranslate\n        }}\n      </p>\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.manageChannelsPrefix'\n            | cxTranslate\n        }}\n        <a\n          (click)=\"close()\"\n          [routerLink]=\"['/my-account/notification-preference']\"\n          class=\"link-prefs\"\n        >\n          {{\n            'stockNotification.subscriptionDialog.manageChannelsLink'\n              | cxTranslate\n          }}</a\n        >\n        {{\n          'stockNotification.subscriptionDialog.manageChannelsSuffix'\n            | cxTranslate\n        }}\n      </p>\n\n      <p>\n        {{\n          'stockNotification.subscriptionDialog.manageSubscriptionsPrefix'\n            | cxTranslate\n        }}\n        <a\n          (click)=\"close()\"\n          [routerLink]=\"['/my-account/my-interests']\"\n          class=\"link-interests\"\n        >\n          {{\n            'stockNotification.subscriptionDialog.manageSubscriptionsLink'\n              | cxTranslate\n          }}</a\n        >\n        {{\n          'stockNotification.subscriptionDialog.manageSubscriptionsSuffix'\n            | cxTranslate\n        }}\n      </p>\n      <div class=\"row\">\n        <div class=\"cx-dialog-actions col-sm-12 col-md-3 offset-md-9\">\n          <button\n            class=\"btn btn-primary btn-block btn-ok\"\n            type=\"button\"\n            (click)=\"close()\"\n          >\n            {{ 'stockNotification.subscriptionDialog.okBtn' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <p>\n      {{ 'stockNotification.subscriptionDialog.subscribing' | cxTranslate }}\n    </p>\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n"
                },] }
    ];
    StockNotificationDialogComponent.ctorParameters = function () { return [
        { type: ModalService },
        { type: i1.UserInterestsService }
    ]; };

    var StockNotificationComponent = /** @class */ (function () {
        function StockNotificationComponent(authService, currentProductService, globalMessageService, translationService, interestsService, modalService, notificationPrefService) {
            this.authService = authService;
            this.currentProductService = currentProductService;
            this.globalMessageService = globalMessageService;
            this.translationService = translationService;
            this.interestsService = interestsService;
            this.modalService = modalService;
            this.notificationPrefService = notificationPrefService;
            this.anonymous = true;
            this.enabledPrefs = [];
            this.subscriptions = new rxjs.Subscription();
        }
        StockNotificationComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.outOfStock$ = rxjs.combineLatest([
                this.currentProductService.getProduct().pipe(operators.filter(Boolean)),
                this.authService.getOccUserId(),
            ]).pipe(operators.tap(function (_a) {
                var _b = __read(_a, 2), product = _b[0], userId = _b[1];
                _this.productCode = product.code;
                if (userId !== i1.OCC_USER_ID_ANONYMOUS) {
                    _this.anonymous = false;
                    _this.notificationPrefService.loadPreferences();
                    _this.interestsService.loadProductInterests(null, null, null, product.code, i1.NotificationType.BACK_IN_STOCK);
                }
            }), operators.map(function (_a) {
                var _b = __read(_a, 1), product = _b[0];
                return !!product.stock && product.stock.stockLevelStatus === 'outOfStock';
            }));
            this.hasProductInterests$ = this.interestsService
                .getProductInterests()
                .pipe(operators.map(function (interests) { return !!interests.results && interests.results.length === 1; }));
            this.subscribeSuccess$ = this.interestsService.getAddProductInterestSuccess();
            this.isRemoveInterestLoading$ = this.interestsService.getRemoveProdutInterestLoading();
            this.prefsEnabled$ = this.notificationPrefService
                .getEnabledPreferences()
                .pipe(operators.tap(function (prefs) { return (_this.enabledPrefs = prefs); }), operators.map(function (prefs) { return prefs.length > 0; }));
            this.subscriptions.add(this.interestsService.getAddProductInterestError().subscribe(function (error) {
                if (error) {
                    _this.onInterestAddingError();
                }
            }));
            this.subscriptions.add(this.interestsService
                .getRemoveProdutInterestSuccess()
                .subscribe(function (success) {
                if (success) {
                    _this.onInterestRemovingSuccess();
                }
            }));
        };
        StockNotificationComponent.prototype.subscribe = function () {
            this.openDialog();
            this.interestsService.addProductInterest(this.productCode, i1.NotificationType.BACK_IN_STOCK);
        };
        StockNotificationComponent.prototype.unsubscribe = function () {
            this.interestsService.removeProdutInterest({
                product: {
                    code: this.productCode,
                },
                productInterestEntry: [
                    {
                        interestType: i1.NotificationType.BACK_IN_STOCK,
                    },
                ],
            }, true);
        };
        StockNotificationComponent.prototype.onInterestRemovingSuccess = function () {
            var _this = this;
            this.subscriptions.add(this.translationService
                .translate('stockNotification.unsubscribeSuccess')
                .pipe(operators.first())
                .subscribe(function (text) { return _this.globalMessageService.add(text, i1.GlobalMessageType.MSG_TYPE_INFO); }));
            this.interestsService.resetRemoveInterestState();
        };
        StockNotificationComponent.prototype.onInterestAddingError = function () {
            this.modalService.dismissActiveModal();
            this.interestsService.resetAddInterestState();
        };
        StockNotificationComponent.prototype.openDialog = function () {
            var modalInstance = this.modalService.open(StockNotificationDialogComponent, {
                centered: true,
                size: 'lg',
            }).componentInstance;
            modalInstance.subscribeSuccess$ = this.subscribeSuccess$;
            modalInstance.enabledPrefs = this.enabledPrefs;
        };
        StockNotificationComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.unsubscribe();
            this.interestsService.clearProductInterests();
            this.notificationPrefService.clearPreferences();
        };
        return StockNotificationComponent;
    }());
    StockNotificationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-stock-notification',
                    template: "<ng-container *ngIf=\"outOfStock$ | async\">\n  <ng-container *ngIf=\"!(hasProductInterests$ | async); else stopNotify\">\n    <ng-container *ngIf=\"prefsEnabled$ | async; else disableNotify\">\n      <div class=\"stock-notification-notes\">\n        <p>{{ 'stockNotification.getNotified' | cxTranslate }}</p>\n      </div>\n      <button\n        class=\"btn btn-primary btn-block btn-notify\"\n        type=\"button\"\n        (click)=\"subscribe()\"\n      >\n        {{ 'stockNotification.notifyMe' | cxTranslate }}\n      </button>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n<ng-template #disableNotify>\n  <div class=\"stock-notification-notes\">\n    <p>\n      <ng-container *ngIf=\"anonymous; else loggedIn\">\n        <a [routerLink]=\"{ cxRoute: 'login' } | cxUrl\">\n          {{ 'miniLogin.signInRegister' | cxTranslate }}</a\n        >\n        {{ 'stockNotification.getNotifySuffix' | cxTranslate }}<br />\n      </ng-container>\n      <ng-template #loggedIn>\n        {{ 'stockNotification.getNotify' | cxTranslate }}<br />\n        {{ 'stockNotification.activateChannelsPrefix' | cxTranslate\n        }}<a [routerLink]=\"['/my-account/notification-preference']\">{{\n          'stockNotification.channelsLink' | cxTranslate\n        }}</a\n        >{{ 'stockNotification.activateChannelsSuffix' | cxTranslate }}\n      </ng-template>\n    </p>\n  </div>\n  <button\n    class=\"btn btn-primary btn-block btn-notify\"\n    type=\"button\"\n    disabled=\"true\"\n  >\n    {{ 'stockNotification.notifyMe' | cxTranslate }}\n  </button>\n</ng-template>\n\n<ng-template #stopNotify>\n  <ng-container *ngIf=\"!(isRemoveInterestLoading$ | async); else loading\">\n    <div class=\"stock-notification-notes\">\n      <p>{{ 'stockNotification.notified' | cxTranslate }}</p>\n    </div>\n    <button\n      class=\"btn btn-primary btn-block btn-stop-notify\"\n      type=\"button\"\n      (click)=\"unsubscribe()\"\n    >\n      {{ 'stockNotification.stopNotify' | cxTranslate }}\n    </button>\n  </ng-container>\n</ng-template>\n\n<ng-template #loading>\n  <div class=\"cx-dialog-body modal-body\">\n    <div class=\"cx-dialog-row\">\n      <div class=\"col-sm-12\">\n        <cx-spinner></cx-spinner>\n      </div>\n    </div>\n  </div>\n</ng-template>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    StockNotificationComponent.ctorParameters = function () { return [
        { type: i1.AuthService },
        { type: CurrentProductService },
        { type: i1.GlobalMessageService },
        { type: i1.TranslationService },
        { type: i1.UserInterestsService },
        { type: ModalService },
        { type: i1.UserNotificationPreferenceService }
    ]; };

    var StockNotificationModule = /** @class */ (function () {
        function StockNotificationModule() {
        }
        return StockNotificationModule;
    }());
    StockNotificationModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [StockNotificationComponent, StockNotificationDialogComponent],
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.I18nModule, SpinnerModule, i1.UrlModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                StockNotificationComponent: {
                                    component: StockNotificationComponent,
                                },
                            },
                        }),
                    ],
                    entryComponents: [
                        StockNotificationComponent,
                        StockNotificationDialogComponent,
                    ],
                    exports: [StockNotificationComponent, StockNotificationDialogComponent],
                },] }
    ];

    var WEEK_DAYS_NUMBER = 7;
    var ScheduleComponent = /** @class */ (function () {
        function ScheduleComponent(storeDataService) {
            this.storeDataService = storeDataService;
            this.displayDays = null;
        }
        ScheduleComponent.prototype.ngOnChanges = function (changes) {
            if (changes.location && this.location) {
                var initialDate = this.getInitialDate();
                this.displayDays = [];
                for (var i = 0; i < WEEK_DAYS_NUMBER; i++) {
                    var date = new Date(initialDate.valueOf());
                    date.setDate(date.getDate() + i);
                    this.displayDays.push(date);
                }
            }
        };
        /**
         * Returns the store's opening time for the given date
         * @param date date
         */
        ScheduleComponent.prototype.getStoreOpeningTime = function (date) {
            return this.storeDataService.getStoreOpeningTime(this.location, date);
        };
        /**
         * Returns the store's closing time for the given date
         * @param date date
         */
        ScheduleComponent.prototype.getStoreClosingTime = function (date) {
            return this.storeDataService.getStoreClosingTime(this.location, date);
        };
        /**
         * return initial (first) date to be displayed in the schedule
         */
        ScheduleComponent.prototype.getInitialDate = function () {
            var currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - currentDate.getDay());
            return currentDate;
        };
        return ScheduleComponent;
    }());
    ScheduleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-schedule',
                    template: "<ng-content></ng-content>\n<div class=\"container cx-store-hours\" *ngIf=\"location.openingHours\">\n  <div *ngFor=\"let day of displayDays\" class=\"row\">\n    <div class=\"cx-days col-4\">{{ day | cxDate: 'EEE' }}</div>\n    <div *ngIf=\"getStoreOpeningTime(day) !== 'closed'\" class=\"cx-hours col-8\">\n      {{ getStoreOpeningTime(day) }} -\n      {{ getStoreClosingTime(day) }}\n    </div>\n    <div\n      *ngIf=\"getStoreOpeningTime(day) === 'closed'\"\n      class=\"cx-hours col-8 closed\"\n    >\n      {{ 'storeFinder.closed' | cxTranslate }}\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    ScheduleComponent.ctorParameters = function () { return [
        { type: i1.StoreDataService }
    ]; };
    ScheduleComponent.propDecorators = {
        location: [{ type: i0.Input }]
    };

    var StoreFinderGridComponent = /** @class */ (function () {
        function StoreFinderGridComponent(storeFinderService, route) {
            this.storeFinderService = storeFinderService;
            this.route = route;
        }
        StoreFinderGridComponent.prototype.ngOnInit = function () {
            this.isLoading$ = this.storeFinderService.getViewAllStoresLoading();
            this.locations$ = this.storeFinderService.getViewAllStoresEntities();
            this.defaultLocation = {};
            if (this.route.snapshot.params.country) {
                this.storeFinderService.findStoresAction('', {
                    pageSize: -1,
                }, undefined, this.route.snapshot.params.country);
            }
        };
        StoreFinderGridComponent.prototype.ngOnDestroy = function () { };
        return StoreFinderGridComponent;
    }());
    StoreFinderGridComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-grid',
                    template: "<ng-container\n  *ngIf=\"\n    !(isLoading$ | async) && (locations$ | async) as locations;\n    else loading\n  \"\n>\n  <div class=\"container\">\n    <div class=\"row\">\n      <div\n        class=\"col-sm-4 col-md-4 col-lg-3 item\"\n        *ngFor=\"let location of locations?.stores\"\n      >\n        <cx-store-finder-list-item\n          [location]=\"location\"\n        ></cx-store-finder-list-item>\n      </div>\n    </div>\n  </div>\n</ng-container>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\"><cx-spinner></cx-spinner></div>\n</ng-template>\n"
                },] }
    ];
    StoreFinderGridComponent.ctorParameters = function () { return [
        { type: i1.StoreFinderService },
        { type: i4.ActivatedRoute }
    ]; };

    var StoreFinderHeaderComponent = /** @class */ (function () {
        function StoreFinderHeaderComponent() {
        }
        return StoreFinderHeaderComponent;
    }());
    StoreFinderHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-header',
                    template: "<ng-container>\n  <cx-store-finder-search></cx-store-finder-search>\n</ng-container>\n"
                },] }
    ];

    // tslint:disable:directive-class-suffix
    var AbstractStoreItemComponent = /** @class */ (function () {
        function AbstractStoreItemComponent(storeDataService) {
            this.storeDataService = storeDataService;
        }
        AbstractStoreItemComponent.prototype.getDirections = function (location) {
            var google_map_url = 'https://www.google.com/maps/dir/Current+Location/';
            var latitude = this.storeDataService.getStoreLatitude(location);
            var longitude = this.storeDataService.getStoreLongitude(location);
            return google_map_url + latitude + ',' + longitude;
        };
        AbstractStoreItemComponent.prototype.getFormattedStoreAddress = function (addressParts) {
            return addressParts.filter(Boolean).join(', ');
        };
        return AbstractStoreItemComponent;
    }());
    AbstractStoreItemComponent.decorators = [
        { type: i0.Directive }
    ];
    AbstractStoreItemComponent.ctorParameters = function () { return [
        { type: i1.StoreDataService }
    ]; };
    AbstractStoreItemComponent.propDecorators = {
        location: [{ type: i0.Input }]
    };

    var StoreFinderListItemComponent = /** @class */ (function (_super) {
        __extends(StoreFinderListItemComponent, _super);
        function StoreFinderListItemComponent(storeDataService) {
            var _this = _super.call(this, storeDataService) || this;
            _this.storeDataService = storeDataService;
            _this.locationIndex = null;
            _this.storeItemClick = new i0.EventEmitter();
            return _this;
        }
        StoreFinderListItemComponent.prototype.handleStoreItemClick = function () {
            if (this.locationIndex !== null) {
                this.storeItemClick.emit(this.locationIndex);
            }
        };
        StoreFinderListItemComponent.prototype.onKey = function (event) {
            if (event.key === 'Enter') {
                this.handleStoreItemClick();
            }
        };
        return StoreFinderListItemComponent;
    }(AbstractStoreItemComponent));
    StoreFinderListItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-list-item',
                    template: "<ng-container>\n  <div>\n    <div class=\"cx-store-list-order\">\n      {{ listOrderLabel }}\n    </div>\n    <div class=\"cx-store-name\">\n      <button\n        *ngIf=\"useClickEvent\"\n        (click)=\"handleStoreItemClick()\"\n        (keyup)=\"onKey($event)\"\n      >\n        {{ location.displayName || location.name }}\n      </button>\n      <a *ngIf=\"!useClickEvent\" [routerLink]=\"[location.name]\">{{\n        location.displayName || location.name\n      }}</a>\n    </div>\n    <div class=\"cx-store-address\" *ngIf=\"location.address\">\n      <div class=\"cx-store-address-street\">\n        {{ location.address.line1 }} {{ location.address.line2 }}\n      </div>\n      {{\n        getFormattedStoreAddress([\n          location.address.town,\n          location.address.postalCode,\n          location.address.country.isocode\n        ])\n      }}\n      <div\n        class=\"cx-store-distance\"\n        *ngIf=\"location.formattedDistance && displayDistance\"\n      >\n        {{ location.formattedDistance }}\n      </div>\n    </div>\n    <a\n      href=\"{{ getDirections(location) }}\"\n      target=\"_blank\"\n      class=\"btn btn-sm btn-action btn-block cx-button\"\n      (click)=\"$event.stopPropagation()\"\n      >{{ 'storeFinder.getDirections' | cxTranslate }}</a\n    >\n  </div>\n</ng-container>\n"
                },] }
    ];
    StoreFinderListItemComponent.ctorParameters = function () { return [
        { type: i1.StoreDataService }
    ]; };
    StoreFinderListItemComponent.propDecorators = {
        locationIndex: [{ type: i0.Input }],
        listOrderLabel: [{ type: i0.Input }],
        displayDistance: [{ type: i0.Input }],
        useClickEvent: [{ type: i0.Input }],
        storeItemClick: [{ type: i0.Output }]
    };

    var StoreFinderMapComponent = /** @class */ (function () {
        function StoreFinderMapComponent(googleMapRendererService) {
            this.googleMapRendererService = googleMapRendererService;
            this.selectedStoreItem = new i0.EventEmitter();
        }
        StoreFinderMapComponent.prototype.ngOnChanges = function (changes) {
            if (changes.locations && this.locations) {
                this.renderMap();
            }
        };
        /**
         * Sets the center of the map to the given location
         * @param latitude latitude of the new center
         * @param longitude longitude of the new center
         */
        StoreFinderMapComponent.prototype.centerMap = function (latitude, longitude) {
            this.googleMapRendererService.centerMap(latitude, longitude);
        };
        StoreFinderMapComponent.prototype.renderMap = function () {
            var _this = this;
            this.googleMapRendererService.renderMap(this.mapElement.nativeElement, this.locations, function (markerIndex) {
                _this.selectStoreItemClickHandle(markerIndex);
            });
        };
        StoreFinderMapComponent.prototype.selectStoreItemClickHandle = function (markerIndex) {
            this.selectedStoreItem.emit(markerIndex);
        };
        return StoreFinderMapComponent;
    }());
    StoreFinderMapComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-map',
                    template: "<div #mapElement class=\"cx-store-map\"></div>\n"
                },] }
    ];
    StoreFinderMapComponent.ctorParameters = function () { return [
        { type: i1.GoogleMapRendererService }
    ]; };
    StoreFinderMapComponent.propDecorators = {
        mapElement: [{ type: i0.ViewChild, args: ['mapElement', { static: true },] }],
        locations: [{ type: i0.Input }],
        selectedStoreItem: [{ type: i0.Output }]
    };

    var StoreFinderPaginationDetailsComponent = /** @class */ (function () {
        function StoreFinderPaginationDetailsComponent() {
        }
        StoreFinderPaginationDetailsComponent.prototype.getResultsPerPage = function () {
            if (this.pagination.totalResults > this.pagination.pageSize) {
                var firstItem = this.pagination.currentPage * this.pagination.pageSize + 1;
                var resultsPerPage = (this.pagination.currentPage + 1) * this.pagination.pageSize;
                if (resultsPerPage > this.pagination.totalResults) {
                    resultsPerPage = this.pagination.totalResults;
                }
                return firstItem + " - " + resultsPerPage;
            }
            else {
                return "1 - " + this.pagination.totalResults;
            }
        };
        return StoreFinderPaginationDetailsComponent;
    }());
    StoreFinderPaginationDetailsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-pagination-details',
                    template: "<span class=\"cx-pagination-details\">\n  {{ getResultsPerPage() }}\n  {{\n    'storeFinder.fromStoresFound'\n      | cxTranslate: { count: pagination.totalResults }\n  }}\n</span>\n"
                },] }
    ];
    StoreFinderPaginationDetailsComponent.ctorParameters = function () { return []; };
    StoreFinderPaginationDetailsComponent.propDecorators = {
        pagination: [{ type: i0.Input }]
    };

    var StoreFinderListComponent = /** @class */ (function () {
        function StoreFinderListComponent(storeDataService, document) {
            this.storeDataService = storeDataService;
            this.document = document;
            this.iconTypes = exports.ICON_TYPE;
            this.isDetailsModeVisible = false;
        }
        StoreFinderListComponent.prototype.centerStoreOnMapByIndex = function (index, location) {
            this.showStoreDetails(location);
            this.selectedStoreIndex = index;
            this.selectedStore = location;
            this.storeMap.centerMap(this.storeDataService.getStoreLatitude(this.locations.stores[index]), this.storeDataService.getStoreLongitude(this.locations.stores[index]));
        };
        StoreFinderListComponent.prototype.selectStoreItemList = function (index) {
            this.selectedStoreIndex = index;
            var storeListItem = this.document.getElementById('item-' + index);
            storeListItem.scrollIntoView({
                behavior: 'smooth',
                block: 'center',
            });
        };
        StoreFinderListComponent.prototype.showStoreDetails = function (location) {
            this.isDetailsModeVisible = true;
            this.storeDetails = location;
        };
        StoreFinderListComponent.prototype.hideStoreDetails = function () {
            this.isDetailsModeVisible = false;
            this.selectedStoreIndex = undefined;
            this.selectedStore = undefined;
            this.storeMap.renderMap();
        };
        return StoreFinderListComponent;
    }());
    StoreFinderListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-list',
                    template: "<ng-container *ngIf=\"locations\">\n  <div class=\"container mb-2\">\n    <div class=\"row\" *ngIf=\"locations?.pagination\">\n      <div class=\"col-md-12\">\n        <cx-store-finder-pagination-details\n          [pagination]=\"locations.pagination\"\n        ></cx-store-finder-pagination-details>\n      </div>\n      <div class=\"col-md-2 text-left cx-back-wrapper\">\n        <button\n          class=\"btn btn-block btn-action\"\n          *ngIf=\"isDetailsModeVisible\"\n          (click)=\"hideStoreDetails()\"\n        >\n          <cx-icon [type]=\"iconTypes.CARET_LEFT\"></cx-icon>\n          {{ 'storeFinder.clickBack' | cxTranslate }}\n        </button>\n      </div>\n    </div>\n    <div *ngIf=\"locations?.stores\" class=\"row cx-columns\">\n      <div class=\"col-md-4 cx-address-col\">\n        <div class=\"cx-store-details\" *ngIf=\"isDetailsModeVisible\">\n          <cx-store-finder-store-description\n            [location]=\"storeDetails\"\n            [disableMap]=\"true\"\n          ></cx-store-finder-store-description>\n        </div>\n        <ol class=\"cx-list\" *ngIf=\"!isDetailsModeVisible\">\n          <li\n            *ngFor=\"let location of locations?.stores; let i = index\"\n            id=\"{{ 'item-' + i }}\"\n            [ngClass]=\"{\n              'cx-selected-item': selectedStoreIndex === i\n            }\"\n            class=\"cx-list-items\"\n          >\n            <cx-store-finder-list-item\n              [location]=\"location\"\n              [locationIndex]=\"i\"\n              [displayDistance]=\"useMylocation\"\n              [useClickEvent]=\"true\"\n              (storeItemClick)=\"centerStoreOnMapByIndex($event, location)\"\n              [listOrderLabel]=\"\n                i +\n                locations.pagination.currentPage *\n                  locations.pagination.pageSize +\n                1\n              \"\n            ></cx-store-finder-list-item>\n          </li>\n        </ol>\n      </div>\n      <div class=\"col-md-8 cx-map-col\">\n        <cx-store-finder-map\n          #storeMap\n          [locations]=\"locations.stores\"\n          (selectedStoreItem)=\"selectStoreItemList($event)\"\n        ></cx-store-finder-map>\n      </div>\n    </div>\n\n    <!-- mobile tabs for column set only -->\n\n    <div *ngIf=\"locations?.stores\" class=\"cx-columns-mobile\">\n      <ngb-tabset justify=\"center\">\n        <ngb-tab>\n          <ng-template ngbTabTitle>\n            {{ 'storeFinder.listView' | cxTranslate }}\n          </ng-template>\n          <ng-template ngbTabContent>\n            <div class=\"cx-address-col\">\n              <div class=\"cx-store-details\" *ngIf=\"isDetailsModeVisible\">\n                <cx-store-finder-store-description\n                  [location]=\"storeDetails\"\n                  [disableMap]=\"true\"\n                ></cx-store-finder-store-description>\n              </div>\n              <ol class=\"cx-list\" *ngIf=\"!isDetailsModeVisible\">\n                <li\n                  *ngFor=\"let location of locations?.stores; let i = index\"\n                  id=\"{{ 'item-' + i }}\"\n                  [ngClass]=\"{\n                    'cx-selected-item': selectedStoreIndex === i\n                  }\"\n                  class=\"cx-list-items\"\n                >\n                  <cx-store-finder-list-item\n                    [location]=\"location\"\n                    [locationIndex]=\"i\"\n                    [displayDistance]=\"useMylocation\"\n                    [useClickEvent]=\"true\"\n                    (storeItemClick)=\"centerStoreOnMapByIndex($event, location)\"\n                    [listOrderLabel]=\"\n                      i +\n                      locations.pagination.currentPage *\n                        locations.pagination.pageSize +\n                      1\n                    \"\n                  ></cx-store-finder-list-item>\n                </li>\n              </ol>\n            </div>\n          </ng-template>\n        </ngb-tab>\n        <ngb-tab>\n          <ng-template ngbTabTitle>\n            {{ 'storeFinder.mapView' | cxTranslate }}\n          </ng-template>\n          <ng-template ngbTabContent>\n            <div class=\"cx-map-col\">\n              <cx-store-finder-map\n                #storeMap\n                [locations]=\"selectedStore ? [selectedStore] : locations.stores\"\n                (selectedStoreItem)=\"selectStoreItemList($event)\"\n              ></cx-store-finder-map>\n            </div>\n          </ng-template>\n        </ngb-tab>\n      </ngb-tabset>\n    </div>\n\n    <!-- mobile tabs end -->\n\n    <div *ngIf=\"!locations?.stores\" class=\"row\">\n      <div class=\"col-md-12 cx-not-found\">\n        {{ 'storeFinder.noStoreFound' | cxTranslate }}\n      </div>\n    </div>\n  </div>\n</ng-container>\n"
                },] }
    ];
    StoreFinderListComponent.ctorParameters = function () { return [
        { type: i1.StoreDataService },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1$1.DOCUMENT,] }] }
    ]; };
    StoreFinderListComponent.propDecorators = {
        locations: [{ type: i0.Input }],
        useMylocation: [{ type: i0.Input }],
        storeMap: [{ type: i0.ViewChild, args: ['storeMap',] }]
    };

    var StoreFinderSearchResultComponent = /** @class */ (function () {
        function StoreFinderSearchResultComponent(storeFinderService, route, config) {
            this.storeFinderService = storeFinderService;
            this.route = route;
            this.config = config;
            this.countryCode = null;
            this.searchConfig = {
                currentPage: 0,
            };
        }
        StoreFinderSearchResultComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.route.queryParams.subscribe(function (params) { return _this.initialize(params); });
        };
        StoreFinderSearchResultComponent.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        StoreFinderSearchResultComponent.prototype.viewPage = function (pageNumber) {
            this.searchConfig = Object.assign(Object.assign({}, this.searchConfig), { currentPage: pageNumber });
            this.storeFinderService.findStoresAction(this.searchQuery.queryText, this.searchConfig, this.geolocation, this.countryCode, this.useMyLocation, this.radius);
        };
        StoreFinderSearchResultComponent.prototype.initialize = function (params) {
            this.searchQuery = this.parseParameters(params);
            this.useMyLocation = params && params.useMyLocation ? true : false;
            this.searchConfig = Object.assign(Object.assign({}, this.searchConfig), { currentPage: 0 });
            this.radius = this.config.googleMaps.radius;
            this.storeFinderService.findStoresAction(this.searchQuery.queryText, this.searchConfig, this.geolocation, this.countryCode, this.useMyLocation, this.radius);
            this.isLoading$ = this.storeFinderService.getStoresLoading();
            this.locations$ = this.storeFinderService.getFindStoresEntities();
        };
        StoreFinderSearchResultComponent.prototype.parseParameters = function (queryParams) {
            var searchQuery;
            if (queryParams.query) {
                searchQuery = { queryText: queryParams.query };
            }
            else {
                searchQuery = { queryText: '' };
            }
            searchQuery.useMyLocation =
                queryParams.useMyLocation != null &&
                    queryParams.useMyLocation.toUpperCase() === 'TRUE';
            return searchQuery;
        };
        return StoreFinderSearchResultComponent;
    }());
    StoreFinderSearchResultComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-search-result',
                    template: "<div\n  *ngIf=\"\n    !(isLoading$ | async) && (locations$ | async) as locations;\n    else loading\n  \"\n>\n  <div *ngIf=\"locations?.stores.length\">\n    <div class=\"cx-pagination\">\n      <cx-pagination\n        [pagination]=\"locations.pagination\"\n        (viewPageEvent)=\"viewPage($event)\"\n      ></cx-pagination>\n    </div>\n  </div>\n  <cx-store-finder-list\n    *ngIf=\"locations?.stores.length\"\n    [locations]=\"locations\"\n    [useMylocation]=\"useMyLocation\"\n  ></cx-store-finder-list>\n  <div class=\"container\" *ngIf=\"!locations?.stores.length\">\n    <div class=\"row\">\n      <span class=\"cx-no-stores\">{{\n        'storeFinder.noStoresMessage' | cxTranslate\n      }}</span>\n    </div>\n  </div>\n</div>\n<ng-template #loading>\n  <div class=\"cx-spinner\">\n    <cx-spinner></cx-spinner>\n  </div>\n</ng-template>\n"
                },] }
    ];
    StoreFinderSearchResultComponent.ctorParameters = function () { return [
        { type: i1.StoreFinderService },
        { type: i4.ActivatedRoute },
        { type: i1.StoreFinderConfig }
    ]; };

    var StoreFinderSearchComponent = /** @class */ (function () {
        function StoreFinderSearchComponent(routingService) {
            this.routingService = routingService;
            this.searchBox = new forms.FormControl();
            this.iconTypes = exports.ICON_TYPE;
        }
        StoreFinderSearchComponent.prototype.findStores = function (address) {
            this.routingService.go(['store-finder/find'], { query: address });
        };
        StoreFinderSearchComponent.prototype.viewStoresWithMyLoc = function () {
            this.routingService.go(['store-finder/find'], { useMyLocation: true });
        };
        StoreFinderSearchComponent.prototype.onKey = function (event) {
            if (this.searchBox.value &&
                this.searchBox.value.length &&
                event.key === 'Enter') {
                this.findStores(this.searchBox.value);
            }
        };
        return StoreFinderSearchComponent;
    }());
    StoreFinderSearchComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-search',
                    template: "<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-md-12 col-lg-7\">\n      <div class=\"form-group search-wrapper\">\n        <input\n          #queryInput\n          [formControl]=\"searchBox\"\n          (keyup)=\"onKey($event)\"\n          type=\"text\"\n          class=\"form-control\"\n          placeholder=\"{{ 'storeFinder.searchBox' | cxTranslate }}\"\n        />\n        <cx-icon\n          [type]=\"iconTypes.SEARCH\"\n          aria-label=\"search\"\n          class=\"search\"\n          (keyup)=\"onKey($event)\"\n          [routerLink]=\"['/store-finder/find']\"\n          [queryParams]=\"{ query: queryInput.value }\"\n          [ngClass]=\"{\n            'disabled-action': !(queryInput.value && queryInput.value.length)\n          }\"\n        ></cx-icon>\n      </div>\n    </div>\n    <div class=\"col-md-12 col-lg-5\">\n      <div class=\"row cx-search-links mb-3\">\n        <div class=\"col-6\">\n          <button\n            (click)=\"viewStoresWithMyLoc()\"\n            class=\"btn btn-primary btn-block\"\n          >\n            {{ 'storeFinder.useMyLocation' | cxTranslate }}\n          </button>\n        </div>\n        <div class=\"col-6\">\n          <button\n            [routerLink]=\"['/store-finder/view-all']\"\n            class=\"btn btn-primary btn-block\"\n          >\n            {{ 'storeFinder.viewAllStores' | cxTranslate }}\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"
                },] }
    ];
    StoreFinderSearchComponent.ctorParameters = function () { return [
        { type: i1.RoutingService }
    ]; };

    var StoreFinderStoreDescriptionComponent = /** @class */ (function (_super) {
        __extends(StoreFinderStoreDescriptionComponent, _super);
        function StoreFinderStoreDescriptionComponent(storeDataService) {
            var _this = _super.call(this, storeDataService) || this;
            _this.storeDataService = storeDataService;
            return _this;
        }
        return StoreFinderStoreDescriptionComponent;
    }(AbstractStoreItemComponent));
    StoreFinderStoreDescriptionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-store-description',
                    template: "<ng-container *ngIf=\"location\">\n  <div class=\"container\">\n    <div class=\"row\">\n      <article class=\"cx-store col-md-4\">\n        <h2>{{ location.displayName || location.name }}</h2>\n\n        <p *ngIf=\"location.address\" class=\"cx-store-description-address\">\n          {{ location.address.line1 }} {{ location.address.line2 }} <br />\n          {{\n            getFormattedStoreAddress([\n              location.address.town,\n              location.address.postalCode,\n              location.address.country.isocode\n            ])\n          }}\n        </p>\n\n        <section class=\"cx-contact\">\n          <ul class=\"cx-list\">\n            <li class=\"cx-item\">\n              <a\n                class=\"cx-link\"\n                [href]=\"getDirections(location)\"\n                target=\"_blank\"\n                >{{ 'storeFinder.getDirections' | cxTranslate }}</a\n              >\n            </li>\n            <li class=\"cx-item\" *ngIf=\"location.address?.phone\">\n              {{ 'storeFinder.call' | cxTranslate }}\n              {{ location.address?.phone }}\n            </li>\n          </ul>\n        </section>\n        <div class=\"cx-schedule\" *ngIf=\"location.openingHours\">\n          <cx-schedule [location]=\"location\">\n            <h3>{{ 'storeFinder.storeHours' | cxTranslate }}</h3>\n          </cx-schedule>\n        </div>\n\n        <div *ngIf=\"(location.features | json) != '{}'\" class=\"cx-features\">\n          <div class=\"row\">\n            <div class=\"col-lg-12\">\n              <h3 class=\"cx-features-header\">\n                {{ 'storeFinder.storeFeatures' | cxTranslate }}\n              </h3>\n            </div>\n          </div>\n\n          <article class=\"row\">\n            <div\n              class=\"col-lg-12 cx-feature-item\"\n              *ngFor=\"let feature of location.features?.entry\"\n            >\n              <div class=\"cx-feature-value\">{{ feature.value }}</div>\n            </div>\n          </article>\n        </div>\n      </article>\n      <article class=\"cx-storeMap col-lg-8\" *ngIf=\"!disableMap\">\n        <cx-store-finder-map [locations]=\"[location]\"></cx-store-finder-map>\n      </article>\n    </div>\n  </div>\n</ng-container>\n"
                },] }
    ];
    StoreFinderStoreDescriptionComponent.ctorParameters = function () { return [
        { type: i1.StoreDataService }
    ]; };
    StoreFinderStoreDescriptionComponent.propDecorators = {
        location: [{ type: i0.Input }],
        disableMap: [{ type: i0.Input }]
    };

    var StoreFinderStoresCountComponent = /** @class */ (function () {
        function StoreFinderStoresCountComponent(storeFinderService) {
            this.storeFinderService = storeFinderService;
        }
        StoreFinderStoresCountComponent.prototype.ngOnInit = function () {
            this.storeFinderService.viewAllStores();
            this.locations$ = this.storeFinderService.getViewAllStoresEntities();
            this.isLoading$ = this.storeFinderService.getViewAllStoresLoading();
        };
        return StoreFinderStoresCountComponent;
    }());
    StoreFinderStoresCountComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-stores-count',
                    template: "<ng-container\n  *ngIf=\"\n    !(isLoading$ | async) && (locations$ | async) as locations;\n    else loading\n  \"\n>\n  <div class=\"cx-count container\">\n    <div class=\"row\" *ngIf=\"locations?.length\">\n      <div\n        *ngFor=\"let country of locations\"\n        class=\"cx-set col-sm-6 col-md-4 col-lg-4 col-xl-3\"\n      >\n        <a [routerLink]=\"['../country', country.isoCode]\" class=\"btn-link\">\n          <div class=\"cx-title\">\n            <span\n              [ngClass]=\"\n                country?.storeCountDataList\n                  ? 'country-header'\n                  : 'country-header-link'\n              \"\n              class=\"cx-name\"\n              >{{ country.name }}</span\n            >\n            <span\n              [ngClass]=\"\n                country?.storeCountDataList\n                  ? 'country-header'\n                  : 'country-header-link'\n              \"\n              *ngIf=\"!country?.storeCountDataList\"\n              class=\"cx-country-count\"\n              >({{ country.count }})</span\n            >\n          </div>\n        </a>\n      </div>\n    </div>\n    <div class=\"row\" *ngIf=\"!locations?.length\">\n      <span class=\"cx-no-stores\">{{\n        'storeFinder.noStoresMessage' | cxTranslate\n      }}</span>\n    </div>\n  </div>\n</ng-container>\n<ng-template #loading>\n  <div class=\"cx-count-spinner\"><cx-spinner></cx-spinner></div>\n</ng-template>\n"
                },] }
    ];
    StoreFinderStoresCountComponent.ctorParameters = function () { return [
        { type: i1.StoreFinderService }
    ]; };

    var StoreFinderComponent = /** @class */ (function () {
        function StoreFinderComponent() {
        }
        return StoreFinderComponent;
    }());
    StoreFinderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder',
                    template: "<ng-container>\n  <div class=\"cx-store-finder-wrapper\">\n    <cx-store-finder-header></cx-store-finder-header>\n    <router-outlet></router-outlet>\n  </div>\n</ng-container>\n"
                },] }
    ];

    var StoreFinderStoreComponent = /** @class */ (function () {
        function StoreFinderStoreComponent(storeFinderService, route, routingService) {
            this.storeFinderService = storeFinderService;
            this.route = route;
            this.routingService = routingService;
            this.iconTypes = exports.ICON_TYPE;
        }
        StoreFinderStoreComponent.prototype.ngOnInit = function () {
            if (!this.location) {
                this.requestStoresData();
                this.location$ = this.storeFinderService.getFindStoresEntities();
                this.isLoading$ = this.storeFinderService.getStoresLoading();
            }
        };
        StoreFinderStoreComponent.prototype.requestStoresData = function () {
            this.storeFinderService.viewStoreById(this.route.snapshot.params.store);
        };
        StoreFinderStoreComponent.prototype.goBack = function () {
            this.routingService.go([
                "store-finder/country/" + this.route.snapshot.params.country,
            ]);
        };
        return StoreFinderStoreComponent;
    }());
    StoreFinderStoreComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-store-finder-store',
                    template: "<div\n  class=\"container\"\n  *ngIf=\"\n    location || (!(isLoading$ | async) && (location$ | async)) as location;\n    else loading\n  \"\n>\n  <div class=\"row cx-store-actions\">\n    <div class=\"col-md-4 col-sm-6 col-lg-2\">\n      <button class=\"btn btn-block btn-action\" (click)=\"goBack()\">\n        <cx-icon [type]=\"iconTypes.CARET_LEFT\"></cx-icon>\n        {{ 'storeFinder.backToList' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n  <div class=\"row\">\n    <div class=\"col-12 p-0\">\n      <cx-store-finder-store-description\n        [disableMap]=\"disableMap\"\n        [location]=\"location\"\n      ></cx-store-finder-store-description>\n    </div>\n  </div>\n</div>\n<ng-template #loading>\n  <div class=\"cx-spinner\"><cx-spinner></cx-spinner></div>\n</ng-template>\n"
                },] }
    ];
    StoreFinderStoreComponent.ctorParameters = function () { return [
        { type: i1.StoreFinderService },
        { type: i4.ActivatedRoute },
        { type: i1.RoutingService }
    ]; };
    StoreFinderStoreComponent.propDecorators = {
        location: [{ type: i0.Input }],
        disableMap: [{ type: i0.Input }]
    };

    var StoreFinderModule = /** @class */ (function () {
        function StoreFinderModule() {
        }
        return StoreFinderModule;
    }());
    StoreFinderModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.ReactiveFormsModule,
                        i4.RouterModule,
                        ListNavigationModule,
                        i1$3.NgbTabsetModule,
                        SpinnerModule,
                        i1.UrlModule,
                        i1.StoreFinderCoreModule,
                        i1.I18nModule,
                        IconModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                StoreFinderComponent: {
                                    component: StoreFinderComponent,
                                    childRoutes: [
                                        {
                                            path: 'find',
                                            component: StoreFinderSearchResultComponent,
                                        },
                                        {
                                            path: 'view-all',
                                            component: StoreFinderStoresCountComponent,
                                        },
                                        {
                                            path: 'country/:country',
                                            component: StoreFinderGridComponent,
                                        },
                                        {
                                            path: 'country/:country/region/:region',
                                            component: StoreFinderGridComponent,
                                        },
                                        {
                                            path: 'country/:country/region/:region/:store',
                                            component: StoreFinderStoreComponent,
                                        },
                                        {
                                            path: 'country/:country/:store',
                                            component: StoreFinderStoreComponent,
                                        },
                                    ],
                                },
                            },
                            layoutSlots: {
                                StoreFinderPageTemplate: {
                                    slots: ['MiddleContent', 'SideContent'],
                                },
                            },
                        }),
                    ],
                    declarations: [
                        StoreFinderSearchComponent,
                        StoreFinderListComponent,
                        StoreFinderMapComponent,
                        StoreFinderListItemComponent,
                        StoreFinderStoresCountComponent,
                        StoreFinderGridComponent,
                        StoreFinderStoreDescriptionComponent,
                        ScheduleComponent,
                        StoreFinderHeaderComponent,
                        StoreFinderSearchResultComponent,
                        StoreFinderComponent,
                        StoreFinderPaginationDetailsComponent,
                        StoreFinderStoreComponent,
                    ],
                    exports: [
                        ScheduleComponent,
                        StoreFinderComponent,
                        StoreFinderGridComponent,
                        StoreFinderHeaderComponent,
                        StoreFinderListItemComponent,
                        StoreFinderMapComponent,
                        StoreFinderPaginationDetailsComponent,
                        StoreFinderSearchComponent,
                        StoreFinderSearchResultComponent,
                        StoreFinderListComponent,
                        StoreFinderStoreDescriptionComponent,
                        StoreFinderStoresCountComponent,
                        StoreFinderStoreComponent,
                    ],
                    entryComponents: [
                        StoreFinderComponent,
                        StoreFinderSearchResultComponent,
                        StoreFinderStoresCountComponent,
                        StoreFinderGridComponent,
                        StoreFinderStoreComponent,
                    ],
                },] }
    ];

    var CheckoutLoginComponent = /** @class */ (function () {
        function CheckoutLoginComponent(formBuilder, authRedirectService, activeCartService) {
            this.formBuilder = formBuilder;
            this.authRedirectService = authRedirectService;
            this.activeCartService = activeCartService;
            this.checkoutLoginForm = this.formBuilder.group({
                email: ['', [forms.Validators.required, CustomFormValidators.emailValidator]],
                emailConfirmation: ['', [forms.Validators.required]],
            }, {
                validators: CustomFormValidators.emailsMustMatch('email', 'emailConfirmation'),
            });
        }
        CheckoutLoginComponent.prototype.onSubmit = function () {
            var _this = this;
            if (this.checkoutLoginForm.valid) {
                var email = this.checkoutLoginForm.get('email').value;
                this.activeCartService.addEmail(email);
                if (!this.sub) {
                    this.sub = this.activeCartService.getAssignedUser().subscribe(function () {
                        if (_this.activeCartService.isGuestCart()) {
                            _this.authRedirectService.redirect();
                        }
                    });
                }
            }
            else {
                this.checkoutLoginForm.markAllAsTouched();
            }
        };
        CheckoutLoginComponent.prototype.ngOnDestroy = function () {
            if (this.sub) {
                this.sub.unsubscribe();
            }
        };
        return CheckoutLoginComponent;
    }());
    CheckoutLoginComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-checkout-login',
                    template: "<form (ngSubmit)=\"onSubmit()\" [formGroup]=\"checkoutLoginForm\">\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'checkoutLogin.emailAddress.label' | cxTranslate\n      }}</span>\n      <input\n        type=\"email\"\n        name=\"email\"\n        class=\"form-control\"\n        formControlName=\"email\"\n        placeholder=\"{{\n          'checkoutLogin.emailAddress.placeholder' | cxTranslate\n        }}\"\n      />\n      <cx-form-errors\n        [control]=\"checkoutLoginForm.get('email')\"\n      ></cx-form-errors>\n    </label>\n  </div>\n\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'checkoutLogin.confirmEmail.label' | cxTranslate\n      }}</span>\n      <input\n        type=\"email\"\n        name=\"emailConfirmation\"\n        class=\"form-control\"\n        formControlName=\"emailConfirmation\"\n        placeholder=\"{{\n          'checkoutLogin.confirmEmail.placeholder' | cxTranslate\n        }}\"\n      />\n      <cx-form-errors\n        [control]=\"checkoutLoginForm.get('emailConfirmation')\"\n      ></cx-form-errors>\n    </label>\n  </div>\n\n  <button type=\"submit\" class=\"btn btn-block btn-primary\">\n    {{ 'checkoutLogin.continue' | cxTranslate }}\n  </button>\n</form>\n"
                },] }
    ];
    CheckoutLoginComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder },
        { type: i1.AuthRedirectService },
        { type: i1.ActiveCartService }
    ]; };

    var CheckoutLoginModule = /** @class */ (function () {
        function CheckoutLoginModule() {
        }
        return CheckoutLoginModule;
    }());
    CheckoutLoginModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i1.I18nModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                GuestCheckoutLoginComponent: {
                                    component: CheckoutLoginComponent,
                                    guards: [NotCheckoutAuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [CheckoutLoginComponent],
                    exports: [CheckoutLoginComponent],
                    entryComponents: [CheckoutLoginComponent],
                },] }
    ];

    var LoginFormComponent = /** @class */ (function () {
        function LoginFormComponent(auth, globalMessageService, fb, authRedirectService, winRef) {
            this.auth = auth;
            this.globalMessageService = globalMessageService;
            this.fb = fb;
            this.authRedirectService = authRedirectService;
            this.winRef = winRef;
        }
        LoginFormComponent.prototype.ngOnInit = function () {
            var _a, _b;
            var routeState = (_b = (_a = this.winRef.nativeWindow) === null || _a === void 0 ? void 0 : _a.history) === null || _b === void 0 ? void 0 : _b.state;
            var prefilledEmail = routeState === null || routeState === void 0 ? void 0 : routeState['newUid'];
            this.loginForm = this.fb.group({
                userId: [
                    (prefilledEmail === null || prefilledEmail === void 0 ? void 0 : prefilledEmail.length) ? prefilledEmail : '',
                    [forms.Validators.required, CustomFormValidators.emailValidator],
                ],
                password: ['', forms.Validators.required],
            });
        };
        LoginFormComponent.prototype.submitForm = function () {
            if (this.loginForm.valid) {
                this.loginUser();
            }
            else {
                this.loginForm.markAllAsTouched();
            }
        };
        LoginFormComponent.prototype.ngOnDestroy = function () {
            if (this.sub) {
                this.sub.unsubscribe();
            }
        };
        LoginFormComponent.prototype.loginUser = function () {
            var _this = this;
            var _c = this.loginForm.controls, userId = _c.userId, password = _c.password;
            this.auth.authorize(userId.value.toLowerCase(), // backend accepts lowercase emails only
            password.value);
            if (!this.sub) {
                this.sub = this.auth.getUserToken().subscribe(function (data) {
                    if (data && data.access_token) {
                        _this.globalMessageService.remove(i1.GlobalMessageType.MSG_TYPE_ERROR);
                        _this.authRedirectService.redirect();
                    }
                });
            }
        };
        return LoginFormComponent;
    }());
    LoginFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-login-form',
                    template: "<form (ngSubmit)=\"submitForm()\" [formGroup]=\"loginForm\">\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'loginForm.emailAddress.label' | cxTranslate\n      }}</span>\n      <input\n        type=\"email\"\n        class=\"form-control\"\n        formControlName=\"userId\"\n        placeholder=\"{{ 'loginForm.emailAddress.placeholder' | cxTranslate }}\"\n      />\n      <cx-form-errors [control]=\"loginForm.get('userId')\"></cx-form-errors>\n    </label>\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <span class=\"label-content\">{{\n        'loginForm.password.label' | cxTranslate\n      }}</span>\n      <input\n        type=\"password\"\n        class=\"form-control\"\n        placeholder=\"{{ 'loginForm.password.placeholder' | cxTranslate }}\"\n        formControlName=\"password\"\n      />\n      <cx-form-errors [control]=\"loginForm.get('password')\"></cx-form-errors>\n    </label>\n  </div>\n  <p>\n    <a\n      [routerLink]=\"{ cxRoute: 'forgotPassword' } | cxUrl\"\n      aria-controls=\"reset-password\"\n      class=\"btn-link\"\n      >{{ 'loginForm.forgotPassword' | cxTranslate }}</a\n    >\n  </p>\n\n  <button type=\"submit\" class=\"btn btn-block btn-primary\">\n    {{ 'loginForm.signIn' | cxTranslate }}\n  </button>\n</form>\n"
                },] }
    ];
    LoginFormComponent.ctorParameters = function () { return [
        { type: i1.AuthService },
        { type: i1.GlobalMessageService },
        { type: forms.FormBuilder },
        { type: i1.AuthRedirectService },
        { type: i1.WindowRef }
    ]; };

    var LoginFormModule = /** @class */ (function () {
        function LoginFormModule() {
        }
        return LoginFormModule;
    }());
    LoginFormModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ReturningCustomerLoginComponent: {
                                    component: LoginFormComponent,
                                    guards: [i1.NotAuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [LoginFormComponent],
                    exports: [LoginFormComponent],
                    entryComponents: [LoginFormComponent],
                },] }
    ];

    var LoginComponent = /** @class */ (function () {
        function LoginComponent(auth, userService) {
            this.auth = auth;
            this.userService = userService;
        }
        LoginComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.user$ = this.auth.isUserLoggedIn().pipe(operators.switchMap(function (isUserLoggedIn) {
                if (isUserLoggedIn) {
                    return _this.userService.get();
                }
                else {
                    return rxjs.of(undefined);
                }
            }));
        };
        return LoginComponent;
    }());
    LoginComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-login',
                    template: "<ng-container *ngIf=\"user$ | async as user; else login\">\n  <div class=\"cx-login-greet\">\n    {{ 'miniLogin.userGreeting' | cxTranslate: { name: user.name } }}\n  </div>\n  <cx-page-slot position=\"HeaderLinks\"></cx-page-slot>\n</ng-container>\n\n<ng-template #login>\n  <a role=\"link\" [routerLink]=\"{ cxRoute: 'login' } | cxUrl\">{{\n    'miniLogin.signInRegister' | cxTranslate\n  }}</a>\n</ng-template>\n"
                },] }
    ];
    LoginComponent.ctorParameters = function () { return [
        { type: i1.AuthService },
        { type: i1.UserService }
    ]; };

    var LoginModule = /** @class */ (function () {
        function LoginModule() {
        }
        return LoginModule;
    }());
    LoginModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i1$1.CommonModule, i4.RouterModule, i1.UrlModule, PageSlotModule, i1.I18nModule],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                LoginComponent: {
                                    component: LoginComponent,
                                },
                            },
                        }),
                    ],
                    declarations: [LoginComponent],
                    entryComponents: [LoginComponent],
                    exports: [LoginComponent],
                },] }
    ];

    /**
     * Guards the _logout_ route.
     *
     * Takes care of routing the user to a logout page (if available) or redirects to
     * the homepage. If the homepage is protected, the user is redirected
     * to the login route instead.
     */
    var LogoutGuard = /** @class */ (function () {
        function LogoutGuard(auth, cms, routing, semanticPathService, protectedRoutes) {
            this.auth = auth;
            this.cms = cms;
            this.routing = routing;
            this.semanticPathService = semanticPathService;
            this.protectedRoutes = protectedRoutes;
        }
        LogoutGuard.prototype.canActivate = function () {
            var _this = this;
            this.logout();
            return this.cms
                .hasPage({
                id: this.semanticPathService.get('logout'),
                type: i1.PageType.CONTENT_PAGE,
            })
                .pipe(operators.tap(function (hasPage) {
                if (!hasPage) {
                    _this.redirect();
                }
            }));
        };
        /**
         * Whenever there is no specific "logout" page configured in the CMS,
         * we redirect after the user is logged out.
         *
         * The user gets redirected to the homepage, unless the homepage is protected
         * (in case of a closed shop). We'll redirect to the login page instead.
         */
        LogoutGuard.prototype.redirect = function () {
            var cxRoute = this.protectedRoutes.shouldProtect ? 'login' : 'home';
            this.routing.go({ cxRoute: cxRoute });
        };
        /**
         * Log user out.
         *
         * This is delegated to the `AuthService`.
         */
        LogoutGuard.prototype.logout = function () {
            this.auth.logout();
        };
        return LogoutGuard;
    }());
    LogoutGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function LogoutGuard_Factory() { return new LogoutGuard(i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i1.CmsService), i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.SemanticPathService), i0.ɵɵinject(i1.ProtectedRoutesService)); }, token: LogoutGuard, providedIn: "root" });
    LogoutGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    LogoutGuard.ctorParameters = function () { return [
        { type: i1.AuthService },
        { type: i1.CmsService },
        { type: i1.RoutingService },
        { type: i1.SemanticPathService },
        { type: i1.ProtectedRoutesService }
    ]; };

    var ɵ0$b = { cxRoute: 'logout' };
    var LogoutModule = /** @class */ (function () {
        function LogoutModule() {
        }
        return LogoutModule;
    }());
    LogoutModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        PageLayoutModule,
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [LogoutGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$b,
                            },
                        ]),
                    ],
                },] }
    ];

    var RegisterComponent = /** @class */ (function () {
        function RegisterComponent(userService, globalMessageService, fb, router, anonymousConsentsService, anonymousConsentsConfig) {
            this.userService = userService;
            this.globalMessageService = globalMessageService;
            this.fb = fb;
            this.router = router;
            this.anonymousConsentsService = anonymousConsentsService;
            this.anonymousConsentsConfig = anonymousConsentsConfig;
            this.subscription = new rxjs.Subscription();
            this.registerForm = this.fb.group({
                titleCode: [''],
                firstName: ['', forms.Validators.required],
                lastName: ['', forms.Validators.required],
                email: ['', [forms.Validators.required, CustomFormValidators.emailValidator]],
                password: [
                    '',
                    [forms.Validators.required, CustomFormValidators.passwordValidator],
                ],
                passwordconf: ['', forms.Validators.required],
                newsletter: new forms.FormControl({
                    value: false,
                    disabled: this.isConsentRequired(),
                }),
                termsandconditions: [false, forms.Validators.requiredTrue],
            }, {
                validators: CustomFormValidators.passwordsMustMatch('password', 'passwordconf'),
            });
        }
        RegisterComponent.prototype.ngOnInit = function () {
            var _this = this;
            var _a;
            this.titles$ = this.userService.getTitles().pipe(operators.map(function (titles) {
                return titles.sort(sortTitles);
            }));
            this.loading$ = this.userService.getRegisterUserResultLoading();
            this.registerUserProcessInit();
            // TODO: Workaround: allow server for decide is titleCode mandatory (if yes, provide personalized message)
            this.subscription.add(this.globalMessageService
                .get()
                .pipe(operators.filter(function (messages) { return !!Object.keys(messages).length; }))
                .subscribe(function (globalMessageEntities) {
                var messages = globalMessageEntities &&
                    globalMessageEntities[i1.GlobalMessageType.MSG_TYPE_ERROR];
                if (messages &&
                    messages.some(function (message) { return message === 'This field is required.'; })) {
                    _this.globalMessageService.remove(i1.GlobalMessageType.MSG_TYPE_ERROR);
                    _this.globalMessageService.add({ key: 'register.titleRequired' }, i1.GlobalMessageType.MSG_TYPE_ERROR);
                }
            }));
            var registerConsent = ((_a = this.anonymousConsentsConfig) === null || _a === void 0 ? void 0 : _a.anonymousConsents).registerConsent;
            this.anonymousConsent$ = rxjs.combineLatest([
                this.anonymousConsentsService.getConsent(registerConsent),
                this.anonymousConsentsService.getTemplate(registerConsent),
            ]).pipe(operators.map(function (_b) {
                var _c = __read(_b, 2), consent = _c[0], template = _c[1];
                return {
                    consent: consent,
                    template: template ? template.description : '',
                };
            }));
            this.subscription.add(this.registerForm.get('newsletter').valueChanges.subscribe(function () {
                _this.toggleAnonymousConsent();
            }));
        };
        RegisterComponent.prototype.submitForm = function () {
            if (this.registerForm.valid) {
                this.registerUser();
            }
            else {
                this.registerForm.markAllAsTouched();
            }
        };
        RegisterComponent.prototype.registerUser = function () {
            this.userService.register(this.collectDataFromRegisterForm(this.registerForm.value));
        };
        RegisterComponent.prototype.titleSelected = function (title) {
            this.registerForm['controls'].titleCode.setValue(title.code);
        };
        RegisterComponent.prototype.collectDataFromRegisterForm = function (formData) {
            var firstName = formData.firstName, lastName = formData.lastName, email = formData.email, password = formData.password, titleCode = formData.titleCode;
            return {
                firstName: firstName,
                lastName: lastName,
                uid: email.toLowerCase(),
                password: password,
                titleCode: titleCode,
            };
        };
        RegisterComponent.prototype.isConsentGiven = function (consent) {
            return this.anonymousConsentsService.isConsentGiven(consent);
        };
        RegisterComponent.prototype.isConsentRequired = function () {
            var _a;
            var _b = (_a = this.anonymousConsentsConfig) === null || _a === void 0 ? void 0 : _a.anonymousConsents, requiredConsents = _b.requiredConsents, registerConsent = _b.registerConsent;
            if (requiredConsents && registerConsent) {
                return requiredConsents.includes(registerConsent);
            }
            return false;
        };
        RegisterComponent.prototype.onRegisterUserSuccess = function (success) {
            if (success) {
                this.router.go('login');
                this.globalMessageService.add({ key: 'register.postRegisterMessage' }, i1.GlobalMessageType.MSG_TYPE_CONFIRMATION);
            }
        };
        RegisterComponent.prototype.toggleAnonymousConsent = function () {
            var registerConsent = this.anonymousConsentsConfig.anonymousConsents.registerConsent;
            if (Boolean(this.registerForm.get('newsletter').value)) {
                this.anonymousConsentsService.giveConsent(registerConsent);
            }
            else {
                this.anonymousConsentsService.withdrawConsent(registerConsent);
            }
        };
        RegisterComponent.prototype.registerUserProcessInit = function () {
            var _this = this;
            this.userService.resetRegisterUserProcessState();
            this.subscription.add(this.userService.getRegisterUserResultSuccess().subscribe(function (success) {
                _this.onRegisterUserSuccess(success);
            }));
        };
        RegisterComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
            this.userService.resetRegisterUserProcessState();
        };
        return RegisterComponent;
    }());
    RegisterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-register',
                    template: "<section\n  class=\"cx-page-section container\"\n  *ngIf=\"!(loading$ | async); else loading\"\n>\n  <div class=\"row justify-content-center\">\n    <div class=\"col-md-6\">\n      <div class=\"cx-section\">\n        <form (ngSubmit)=\"submitForm()\" [formGroup]=\"registerForm\">\n          <div class=\"form-group\">\n            <label>\n              <span class=\"label-content\">{{\n                'register.title' | cxTranslate\n              }}</span>\n              <select formControlName=\"titleCode\" class=\"form-control\">\n                <option selected value=\"\" disabled>\n                  {{ 'register.selectTitle' | cxTranslate }}\n                </option>\n                <option\n                  *ngFor=\"let title of titles$ | async\"\n                  [value]=\"title.code\"\n                >\n                  {{ title.name }}\n                </option>\n              </select>\n            </label>\n          </div>\n\n          <div class=\"form-group\">\n            <label>\n              <span class=\"label-content\">{{\n                'register.firstName.label' | cxTranslate\n              }}</span>\n              <input\n                class=\"form-control\"\n                type=\"text\"\n                name=\"firstname\"\n                placeholder=\"{{\n                  'register.firstName.placeholder' | cxTranslate\n                }}\"\n                formControlName=\"firstName\"\n              />\n              <cx-form-errors\n                [control]=\"registerForm.get('firstName')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n\n          <div class=\"form-group\">\n            <label>\n              <span class=\"label-content\">{{\n                'register.lastName.label' | cxTranslate\n              }}</span>\n              <input\n                class=\"form-control\"\n                type=\"text\"\n                name=\"lastname\"\n                placeholder=\"{{\n                  'register.lastName.placeholder' | cxTranslate\n                }}\"\n                formControlName=\"lastName\"\n              />\n              <cx-form-errors\n                [control]=\"registerForm.get('lastName')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n\n          <div class=\"form-group\">\n            <label>\n              <span class=\"label-content\">{{\n                'register.emailAddress.label' | cxTranslate\n              }}</span>\n              <input\n                class=\"form-control\"\n                type=\"email\"\n                name=\"email\"\n                placeholder=\"{{\n                  'register.emailAddress.placeholder' | cxTranslate\n                }}\"\n                formControlName=\"email\"\n              />\n              <cx-form-errors\n                [control]=\"registerForm.get('email')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n\n          <div class=\"form-group\">\n            <label>\n              <span class=\"label-content\">{{\n                'register.password.label' | cxTranslate\n              }}</span>\n              <input\n                class=\"form-control\"\n                type=\"password\"\n                name=\"password\"\n                placeholder=\"{{\n                  'register.password.placeholder' | cxTranslate\n                }}\"\n                formControlName=\"password\"\n              />\n              <cx-form-errors\n                [control]=\"registerForm.get('password')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n\n          <div class=\"form-group\">\n            <label>\n              <span class=\"label-content\">{{\n                'register.confirmPassword.label' | cxTranslate\n              }}</span>\n              <input\n                class=\"form-control\"\n                type=\"password\"\n                name=\"confirmpassword\"\n                placeholder=\"{{\n                  'register.confirmPassword.placeholder' | cxTranslate\n                }}\"\n                formControlName=\"passwordconf\"\n              />\n              <cx-form-errors\n                [control]=\"registerForm.get('passwordconf')\"\n              ></cx-form-errors>\n            </label>\n          </div>\n\n          <div class=\"form-group\">\n            <div class=\"form-check\">\n              <label *ngIf=\"anonymousConsent$ | async as anonymousConsent\">\n                <input\n                  type=\"checkbox\"\n                  name=\"newsletter\"\n                  class=\"form-check-input\"\n                  formControlName=\"newsletter\"\n                  [checked]=\"isConsentGiven(anonymousConsent.consent)\"\n                />\n                <span class=\"form-check-label\">\n                  {{ anonymousConsent.template }}\n                </span>\n              </label>\n            </div>\n          </div>\n\n          <div class=\"form-group\">\n            <div class=\"form-check\">\n              <label>\n                <input\n                  type=\"checkbox\"\n                  name=\"termsandconditions\"\n                  formControlName=\"termsandconditions\"\n                />\n                <span class=\"form-check-label\">\n                  {{ 'register.confirmThatRead' | cxTranslate }}\n                  <a\n                    [routerLink]=\"{ cxRoute: 'termsAndConditions' } | cxUrl\"\n                    target=\"_blank\"\n                  >\n                    {{ 'register.termsAndConditions' | cxTranslate }}\n                  </a>\n                </span>\n                <cx-form-errors\n                  [control]=\"registerForm.get('termsandconditions')\"\n                ></cx-form-errors>\n              </label>\n            </div>\n          </div>\n          <button type=\"submit\" class=\"btn btn-block btn-primary\">\n            {{ 'register.register' | cxTranslate }}\n          </button>\n          <a\n            class=\"cx-login-link btn-link\"\n            [routerLink]=\"{ cxRoute: 'login' } | cxUrl\"\n            >{{ 'register.signIn' | cxTranslate }}</a\n          >\n        </form>\n      </div>\n    </div>\n  </div>\n</section>\n\n<ng-template #loading>\n  <div class=\"cx-spinner\"><cx-spinner></cx-spinner></div>\n</ng-template>\n"
                },] }
    ];
    RegisterComponent.ctorParameters = function () { return [
        { type: i1.UserService },
        { type: i1.GlobalMessageService },
        { type: forms.FormBuilder },
        { type: i1.RoutingService },
        { type: i1.AnonymousConsentsService },
        { type: i1.AnonymousConsentsConfig }
    ]; };

    var RegisterComponentModule = /** @class */ (function () {
        function RegisterComponentModule() {
        }
        return RegisterComponentModule;
    }());
    RegisterComponentModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        LoginModule,
                        forms.ReactiveFormsModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        i1.I18nModule,
                        SpinnerModule,
                        FormErrorsModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                RegisterCustomerComponent: {
                                    component: RegisterComponent,
                                    guards: [i1.NotAuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [RegisterComponent],
                    exports: [RegisterComponent],
                    entryComponents: [RegisterComponent],
                },] }
    ];

    var LoginRegisterComponent = /** @class */ (function () {
        function LoginRegisterComponent(checkoutConfigService, activatedRoute) {
            this.checkoutConfigService = checkoutConfigService;
            this.activatedRoute = activatedRoute;
            this.loginAsGuest = false;
        }
        LoginRegisterComponent.prototype.ngOnInit = function () {
            var _a, _b, _c;
            if (this.checkoutConfigService.isGuestCheckout()) {
                this.loginAsGuest = (_c = (_b = (_a = this.activatedRoute) === null || _a === void 0 ? void 0 : _a.snapshot) === null || _b === void 0 ? void 0 : _b.queryParams) === null || _c === void 0 ? void 0 : _c['forced'];
            }
        };
        return LoginRegisterComponent;
    }());
    LoginRegisterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-login-register',
                    template: "<div class=\"register\">\n  <p class=\"cx-section-title\">\n    {{ 'loginForm.dontHaveAccount' | cxTranslate }}\n  </p>\n\n  <ng-container *ngIf=\"!loginAsGuest\">\n    <a\n      [routerLink]=\"{ cxRoute: 'register' } | cxUrl\"\n      class=\"btn btn-block btn-secondary btn-register\"\n      >{{ 'loginForm.register' | cxTranslate }}</a\n    >\n  </ng-container>\n\n  <ng-container *ngIf=\"loginAsGuest\">\n    <a\n      [routerLink]=\"{ cxRoute: 'checkoutLogin' } | cxUrl\"\n      class=\"btn btn-block btn-secondary btn-guest\"\n      >{{ 'loginForm.guestCheckout' | cxTranslate }}</a\n    >\n  </ng-container>\n</div>\n"
                },] }
    ];
    LoginRegisterComponent.ctorParameters = function () { return [
        { type: CheckoutConfigService },
        { type: i4.ActivatedRoute }
    ]; };

    var LoginRegisterModule = /** @class */ (function () {
        function LoginRegisterModule() {
        }
        return LoginRegisterModule;
    }());
    LoginRegisterModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        PageSlotModule,
                        i1.I18nModule,
                        i1.CheckoutModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                ReturningCustomerRegisterComponent: {
                                    component: LoginRegisterComponent,
                                    guards: [i1.NotAuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [LoginRegisterComponent],
                    entryComponents: [LoginRegisterComponent],
                    exports: [LoginRegisterComponent],
                },] }
    ];

    var UserComponentModule = /** @class */ (function () {
        function UserComponentModule() {
        }
        return UserComponentModule;
    }());
    UserComponentModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1$1.CommonModule,
                        LoginModule,
                        LoginFormModule,
                        LoginRegisterModule,
                        LogoutModule,
                        CheckoutLoginModule,
                        forms.ReactiveFormsModule,
                        i4.RouterModule,
                        i1.UrlModule,
                        RegisterComponentModule,
                    ],
                },] }
    ];

    var WishListItemComponent = /** @class */ (function () {
        function WishListItemComponent() {
            this.isLoading = false;
            this.remove = new i0.EventEmitter();
        }
        WishListItemComponent.prototype.removeEntry = function (item) {
            this.remove.emit(item);
        };
        return WishListItemComponent;
    }());
    WishListItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-wish-list-item',
                    template: "<div class=\"row\">\n  <!-- Item Image -->\n  <div class=\"cx-image-container col-2\">\n    <a\n      [routerLink]=\"{ cxRoute: 'product', params: cartEntry.product } | cxUrl\"\n      tabindex=\"-1\"\n    >\n      <cx-media [container]=\"cartEntry.product.images?.PRIMARY\"></cx-media>\n    </a>\n  </div>\n  <!-- Item Information -->\n  <div class=\"cx-info col-10\">\n    <div class=\"cx-info-container row\">\n      <!-- Item Description -->\n      <div class=\"col-md-5 col-lg-5 col-xl-5\">\n        <div *ngIf=\"cartEntry.product.name\" class=\"cx-name\">\n          <a\n            class=\"cx-link\"\n            [routerLink]=\"\n              { cxRoute: 'product', params: cartEntry.product } | cxUrl\n            \"\n            >{{ cartEntry.product.name }}</a\n          >\n        </div>\n        <div *ngIf=\"cartEntry.product.code\" class=\"cx-code\">\n          {{ 'cartItems.id' | cxTranslate }} {{ cartEntry.product.code }}\n        </div>\n        <!-- Variants -->\n        <ng-container *ngIf=\"cartEntry.product.baseOptions?.length\">\n          <div\n            *ngFor=\"\n              let variant of cartEntry.product.baseOptions[0]?.selected\n                ?.variantOptionQualifiers\n            \"\n            class=\"cx-property\"\n          >\n            <div class=\"cx-label\" *ngIf=\"variant.name && variant.value\">\n              {{ variant.name }}: {{ variant.value }}\n            </div>\n          </div>\n        </ng-container>\n      </div>\n      <!-- Item Price -->\n      <div\n        *ngIf=\"cartEntry.basePrice\"\n        class=\"cx-price col-md-3 col-lg-4 col-xl-4\"\n      >\n        <div class=\"cx-label d-block d-md-none d-lg-none d-xl-none\">\n          {{ 'cartItems.itemPrice' | cxTranslate }}\n        </div>\n        <div *ngIf=\"cartEntry.basePrice\" class=\"cx-value\">\n          {{ cartEntry.basePrice?.formattedValue }}\n        </div>\n      </div>\n      <!-- Total -->\n      <div class=\"col-sm-8 col-md-4 col-lg-3 col-xl-3 cx-add-to-cart\">\n        <cx-add-to-cart\n          *ngIf=\"\n            cartEntry.product.stock.stockLevelStatus !== 'outOfStock';\n            else outOfStock\n          \"\n          [showQuantity]=\"false\"\n          [product]=\"cartEntry.product\"\n        ></cx-add-to-cart>\n        <ng-template #outOfStock>\n          <span class=\"cx-out-of-stock\">\n            {{ 'addToCart.outOfStock' | cxTranslate }}\n          </span>\n        </ng-template>\n      </div>\n    </div>\n    <div class=\"cx-return-button col-12\">\n      <button\n        class=\"btn cx-action-link\"\n        (click)=\"removeEntry(cartEntry)\"\n        [disabled]=\"isLoading\"\n      >\n        {{ 'common.remove' | cxTranslate }}\n      </button>\n    </div>\n  </div>\n</div>\n",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    WishListItemComponent.propDecorators = {
        isLoading: [{ type: i0.Input }],
        cartEntry: [{ type: i0.Input }],
        remove: [{ type: i0.Output }]
    };

    var WishListComponent = /** @class */ (function () {
        function WishListComponent(wishListService) {
            this.wishListService = wishListService;
            this.wishList$ = this.wishListService.getWishList();
            this.loading$ = this.wishListService.getWishListLoading();
        }
        WishListComponent.prototype.removeEntry = function (item) {
            this.wishListService.removeEntry(item);
        };
        return WishListComponent;
    }());
    WishListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'cx-wish-list',
                    template: "<ng-container *ngIf=\"wishList$ | async as wishList\">\n  <ng-container *ngIf=\"wishList?.entries?.length > 0; else emptyWishList\">\n    <div class=\"d-none d-md-block d-lg-block d-xl-block\">\n      <div class=\"cx-item-list-header row\">\n        <div class=\"cx-item-list-desc col-md-7 col-lg-6 col-xl-6\">\n          {{ 'cartItems.description' | cxTranslate }}\n        </div>\n        <div class=\"cx-item-list-price col-md-3 col-lg-4 col-xl-4\">\n          {{ 'cartItems.itemPrice' | cxTranslate }}\n        </div>\n        <div class=\"cx-item-list-total col-md-2 col-lg-2 col-xl-2\">\n          {{ 'cartItems.total' | cxTranslate }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"cx-item-list-row\" *ngFor=\"let entry of wishList?.entries\">\n      <cx-wish-list-item\n        [cartEntry]=\"entry\"\n        [isLoading]=\"loading$ | async\"\n        class=\"cx-wish-list-items\"\n        (remove)=\"removeEntry($event)\"\n      ></cx-wish-list-item>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template #emptyWishList>\n  <h2>{{ 'wishlist.empty' | cxTranslate }}</h2>\n</ng-template>\n"
                },] }
    ];
    WishListComponent.ctorParameters = function () { return [
        { type: i1.WishListService }
    ]; };

    var WishListModule = /** @class */ (function () {
        function WishListModule() {
        }
        return WishListModule;
    }());
    WishListModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        AddToCartModule,
                        i1$1.CommonModule,
                        i1.I18nModule,
                        MediaModule,
                        i4.RouterModule,
                        StarRatingModule,
                        i1.UrlModule,
                        ItemCounterModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            cmsComponents: {
                                WishListComponent: {
                                    component: WishListComponent,
                                    guards: [i1.AuthGuard],
                                },
                            },
                        }),
                    ],
                    declarations: [WishListComponent, WishListItemComponent],
                    entryComponents: [WishListComponent],
                    exports: [WishListComponent, WishListItemComponent],
                },] }
    ];

    var CmsLibModule = /** @class */ (function () {
        function CmsLibModule() {
        }
        return CmsLibModule;
    }());
    CmsLibModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        AnonymousConsentManagementBannerModule,
                        AsmModule,
                        HamburgerMenuModule,
                        CmsParagraphModule,
                        LinkModule,
                        BannerModule,
                        CategoryNavigationModule,
                        NavigationModule,
                        FooterNavigationModule,
                        BreadcrumbModule,
                        SearchBoxModule,
                        SiteContextSelectorModule,
                        QualtricsModule,
                        AddressBookModule,
                        OrderHistoryModule,
                        OrderCancellationModule,
                        OrderReturnModule,
                        ReturnRequestListModule,
                        ReturnRequestDetailModule,
                        ProductListModule,
                        ProductFacetNavigationModule,
                        ProductTabsModule,
                        ProductCarouselModule,
                        ProductReferencesModule,
                        OrderDetailsModule,
                        PaymentMethodsModule,
                        UpdateEmailModule,
                        UpdatePasswordModule,
                        UpdateProfileModule,
                        ConsentManagementModule,
                        CloseAccountModule,
                        CartComponentModule,
                        TabParagraphContainerModule,
                        OrderConfirmationModule,
                        StoreFinderModule,
                        ProductImagesModule,
                        ProductSummaryModule,
                        ProductVariantsModule,
                        ProductIntroModule,
                        CheckoutComponentModule,
                        ForgotPasswordModule,
                        ResetPasswordModule,
                        BannerCarouselModule,
                        UserComponentModule,
                        MyCouponsModule,
                        WishListModule,
                        NotificationPreferenceModule,
                        MyInterestsModule,
                        StockNotificationModule,
                        ReplenishmentOrderHistoryModule,
                        ReplenishmentOrderConfirmationModule,
                        ReplenishmentOrderDetailsModule,
                    ],
                },] }
    ];

    function getProductDetailsUrlMatcherFactory(service, defaultMatcherFactory) {
        var factory = function (route) {
            var defaultMatcher = defaultMatcherFactory(route);
            var suffixPDPMatcher = getSuffixUrlMatcher({
                marker: 'p',
                paramName: 'productCode',
            });
            return service.getCombined([defaultMatcher, suffixPDPMatcher]);
        };
        return factory;
    }
    /**
     * Injection token with url matcher factory for PDP.
     * The provided url matcher matches both:
     * - the configured `paths` from routing config and
     * - custom pattern  `** / p / :productCode`
     *
     * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
     * or additional matchers can be added for a specific route.
     *
     * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
     */
    var PRODUCT_DETAILS_URL_MATCHER = new i0.InjectionToken('PRODUCT_DETAILS_URL_MATCHER', {
        providedIn: 'root',
        factory: function () { return getProductDetailsUrlMatcherFactory(i0.inject(i1.UrlMatcherService), i0.inject(i1.DEFAULT_URL_MATCHER)); },
    });

    var ɵ0$c = { cxRoute: 'product' };
    var ProductDetailsPageModule = /** @class */ (function () {
        function ProductDetailsPageModule() {
        }
        return ProductDetailsPageModule;
    }());
    ProductDetailsPageModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$c,
                            },
                        ]),
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            routing: {
                                routes: {
                                    product: {
                                        matchers: [PRODUCT_DETAILS_URL_MATCHER],
                                    },
                                },
                            },
                        }),
                    ],
                },] }
    ];

    function getProductListingUrlMatcherFactory(service, defaultMatcherFactory) {
        var factory = function (route) {
            var defaultMatcher = defaultMatcherFactory(route);
            var suffixPLPMatcher = getSuffixUrlMatcher({
                marker: 'c',
                paramName: 'categoryCode',
            });
            return service.getCombined([defaultMatcher, suffixPLPMatcher]);
        };
        return factory;
    }
    /**
     * Injection token with url matcher factory for PLP.
     * The provided url matcher matches both:
     * - the configured `paths` from routing config and
     * - custom pattern  `** / c / :categoryCode`
     *
     * If the this matcher doesn't fit the requirements, it can be replaced with the DEFAULT_URL_MATCHER
     * or additional matchers can be added for a specific route.
     *
     * Note: Matchers will "match" a route, but do not contribute to the creation of the route, nor do they guard routes.
     */
    var PRODUCT_LISTING_URL_MATCHER = new i0.InjectionToken('PRODUCT_LISTING_URL_MATCHER', {
        providedIn: 'root',
        factory: function () { return getProductListingUrlMatcherFactory(i0.inject(i1.UrlMatcherService), i0.inject(i1.DEFAULT_URL_MATCHER)); },
    });

    var ɵ0$d = { pageLabel: 'search', cxRoute: 'search' }, ɵ1$1 = { cxRoute: 'brand' }, ɵ2 = { cxRoute: 'category' };
    var ProductListingPageModule = /** @class */ (function () {
        function ProductListingPageModule() {
        }
        return ProductListingPageModule;
    }());
    ProductListingPageModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i4.RouterModule.forChild([
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ0$d,
                            },
                            {
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ1$1,
                            },
                            {
                                // The 'category' route  may include a greedy suffix url matcher '**/c/:categoryCode'
                                // So not to shadow the specific 'brand' route, the 'category' is the last route in the sequence.
                                path: null,
                                canActivate: [CmsPageGuard],
                                component: PageLayoutComponent,
                                data: ɵ2,
                            },
                        ]),
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            routing: {
                                routes: {
                                    category: {
                                        matchers: [PRODUCT_LISTING_URL_MATCHER],
                                    },
                                },
                            },
                        }),
                    ],
                },] }
    ];

    /**
     * Indicates that a user visited an arbitrary page.
     */
    var PageEvent = /** @class */ (function () {
        function PageEvent() {
        }
        return PageEvent;
    }());
    /**
     * Indicates that a user visited the home page.
     */
    var HomePageEvent = /** @class */ (function (_super) {
        __extends(HomePageEvent, _super);
        function HomePageEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return HomePageEvent;
    }(PageEvent));

    /**
     * Indicates that a user visited a cart page.
     */
    var CartPageEvent = /** @class */ (function (_super) {
        __extends(CartPageEvent, _super);
        function CartPageEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CartPageEvent;
    }(PageEvent));

    var CartPageEventBuilder = /** @class */ (function () {
        function CartPageEventBuilder(actions, eventService) {
            this.actions = actions;
            this.eventService = eventService;
            this.register();
        }
        CartPageEventBuilder.prototype.register = function () {
            this.eventService.register(CartPageEvent, this.buildCartPageEvent());
        };
        CartPageEventBuilder.prototype.buildCartPageEvent = function () {
            return this.eventService.get(PageEvent).pipe(operators.filter(function (pageEvent) { return pageEvent.semanticRoute === 'cart'; }), operators.map(function (pageEvent) { return i1.createFrom(CartPageEvent, pageEvent); }));
        };
        return CartPageEventBuilder;
    }());
    CartPageEventBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function CartPageEventBuilder_Factory() { return new CartPageEventBuilder(i0.ɵɵinject(i1$4.ActionsSubject), i0.ɵɵinject(i1.EventService)); }, token: CartPageEventBuilder, providedIn: "root" });
    CartPageEventBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    CartPageEventBuilder.ctorParameters = function () { return [
        { type: i1$4.ActionsSubject },
        { type: i1.EventService }
    ]; };

    var CartPageEventModule = /** @class */ (function () {
        function CartPageEventModule(_cartPageEventBuilder) {
        }
        return CartPageEventModule;
    }());
    CartPageEventModule.decorators = [
        { type: i0.NgModule, args: [{},] }
    ];
    CartPageEventModule.ctorParameters = function () { return [
        { type: CartPageEventBuilder }
    ]; };

    var PageEventBuilder = /** @class */ (function () {
        function PageEventBuilder(actions, eventService) {
            this.actions = actions;
            this.eventService = eventService;
            this.register();
        }
        PageEventBuilder.prototype.register = function () {
            this.eventService.register(PageEvent, this.buildPageEvent());
            this.eventService.register(HomePageEvent, this.buildHomePageEvent());
        };
        PageEventBuilder.prototype.buildPageEvent = function () {
            return this.getNavigatedEvent().pipe(operators.map(function (state) { return i1.createFrom(PageEvent, {
                context: state.context,
                semanticRoute: state.semanticRoute,
                url: state.url,
                params: state.params,
            }); }));
        };
        PageEventBuilder.prototype.buildHomePageEvent = function () {
            return this.buildPageEvent().pipe(operators.filter(function (pageEvent) { return pageEvent.semanticRoute === 'home'; }), operators.map(function (pageEvent) { return i1.createFrom(HomePageEvent, pageEvent); }));
        };
        PageEventBuilder.prototype.getNavigatedEvent = function () {
            return this.actions.pipe(effects.ofType(routerStore.ROUTER_NAVIGATED), operators.map(function (event) { return event.payload.routerState; }));
        };
        return PageEventBuilder;
    }());
    PageEventBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function PageEventBuilder_Factory() { return new PageEventBuilder(i0.ɵɵinject(i1$4.ActionsSubject), i0.ɵɵinject(i1.EventService)); }, token: PageEventBuilder, providedIn: "root" });
    PageEventBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    PageEventBuilder.ctorParameters = function () { return [
        { type: i1$4.ActionsSubject },
        { type: i1.EventService }
    ]; };

    var PageEventModule = /** @class */ (function () {
        function PageEventModule(_pageEventBuilder) {
        }
        return PageEventModule;
    }());
    PageEventModule.decorators = [
        { type: i0.NgModule, args: [{},] }
    ];
    PageEventModule.ctorParameters = function () { return [
        { type: PageEventBuilder }
    ]; };

    /**
     * Indicates that a user visited a product details page.
     */
    var ProductDetailsPageEvent = /** @class */ (function (_super) {
        __extends(ProductDetailsPageEvent, _super);
        function ProductDetailsPageEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ProductDetailsPageEvent;
    }(PageEvent));
    /**
     * Indicates that a user visited a category page.
     */
    var CategoryPageResultsEvent = /** @class */ (function (_super) {
        __extends(CategoryPageResultsEvent, _super);
        function CategoryPageResultsEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CategoryPageResultsEvent;
    }(PageEvent));
    /**
     * Indicates that the a user visited the search results page,
     * and that the search results have been retrieved.
     */
    var SearchPageResultsEvent = /** @class */ (function (_super) {
        __extends(SearchPageResultsEvent, _super);
        function SearchPageResultsEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SearchPageResultsEvent;
    }(PageEvent));

    var ProductPageEventBuilder = /** @class */ (function () {
        function ProductPageEventBuilder(eventService, productService, productSearchService) {
            this.eventService = eventService;
            this.productService = productService;
            this.productSearchService = productSearchService;
            this.register();
        }
        ProductPageEventBuilder.prototype.register = function () {
            this.eventService.register(SearchPageResultsEvent, this.buildSearchPageResultsEvent());
            this.eventService.register(ProductDetailsPageEvent, this.buildProductDetailsPageEvent());
            this.eventService.register(CategoryPageResultsEvent, this.buildCategoryResultsPageEvent());
        };
        ProductPageEventBuilder.prototype.buildProductDetailsPageEvent = function () {
            var _this = this;
            return this.eventService.get(PageEvent).pipe(operators.filter(function (pageEvent) { return pageEvent.semanticRoute === 'product'; }), operators.switchMap(function (pageEvent) { return _this.productService.get(pageEvent.context.id).pipe(operators.filter(function (product) { return Boolean(product); }), operators.take(1), operators.map(function (product) { return i1.createFrom(ProductDetailsPageEvent, Object.assign(Object.assign({}, pageEvent), { categories: product.categories, code: product.code, name: product.name, price: product.price })); })); }));
        };
        ProductPageEventBuilder.prototype.buildCategoryResultsPageEvent = function () {
            var searchResults$ = this.productSearchService.getResults().pipe(
            // skipping the initial value, and preventing emission of the previous search state
            operators.skip(1));
            return this.eventService.get(PageEvent).pipe(operators.switchMap(function (pageEvent) {
                if ((pageEvent === null || pageEvent === void 0 ? void 0 : pageEvent.semanticRoute) !== 'category') {
                    return rxjs.EMPTY;
                }
                return searchResults$.pipe(operators.map(function (searchResults) {
                    var _a, _b, _c;
                    return (Object.assign(Object.assign({}, pageEvent), {
                        categoryCode: (_a = pageEvent === null || pageEvent === void 0 ? void 0 : pageEvent.context) === null || _a === void 0 ? void 0 : _a.id,
                        numberOfResults: (_b = searchResults === null || searchResults === void 0 ? void 0 : searchResults.pagination) === null || _b === void 0 ? void 0 : _b.totalResults,
                        categoryName: (_c = searchResults.breadcrumbs) === null || _c === void 0 ? void 0 : _c[0].facetValueName,
                    }));
                }), operators.map(function (categoryPage) { return i1.createFrom(CategoryPageResultsEvent, categoryPage); }));
            }));
        };
        ProductPageEventBuilder.prototype.buildSearchPageResultsEvent = function () {
            var searchResults$ = this.productSearchService.getResults().pipe(
            // skipping the initial value, and preventing emission of the previous search state
            operators.skip(1));
            return this.eventService.get(PageEvent).pipe(operators.switchMap(function (pageEvent) {
                if ((pageEvent === null || pageEvent === void 0 ? void 0 : pageEvent.semanticRoute) !== 'search') {
                    return rxjs.EMPTY;
                }
                return searchResults$.pipe(operators.map(function (searchResults) {
                    var _a;
                    return (Object.assign(Object.assign({}, pageEvent), {
                        searchTerm: searchResults === null || searchResults === void 0 ? void 0 : searchResults.freeTextSearch,
                        numberOfResults: (_a = searchResults === null || searchResults === void 0 ? void 0 : searchResults.pagination) === null || _a === void 0 ? void 0 : _a.totalResults,
                    }));
                }), operators.map(function (searchPage) { return i1.createFrom(SearchPageResultsEvent, searchPage); }));
            }));
        };
        return ProductPageEventBuilder;
    }());
    ProductPageEventBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProductPageEventBuilder_Factory() { return new ProductPageEventBuilder(i0.ɵɵinject(i1.EventService), i0.ɵɵinject(i1.ProductService), i0.ɵɵinject(i1.ProductSearchService)); }, token: ProductPageEventBuilder, providedIn: "root" });
    ProductPageEventBuilder.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ProductPageEventBuilder.ctorParameters = function () { return [
        { type: i1.EventService },
        { type: i1.ProductService },
        { type: i1.ProductSearchService }
    ]; };

    var ProductPageEventModule = /** @class */ (function () {
        function ProductPageEventModule(_productPageEventBuilder) {
        }
        return ProductPageEventModule;
    }());
    ProductPageEventModule.decorators = [
        { type: i0.NgModule, args: [{},] }
    ];
    ProductPageEventModule.ctorParameters = function () { return [
        { type: ProductPageEventBuilder }
    ]; };

    var mediaConfig = {
        mediaFormats: {
            mobile: {
                width: 400,
            },
            tablet: {
                width: 770,
            },
            desktop: {
                width: 1140,
            },
            widescreen: {
                width: 1400,
            },
            // product media
            cartIcon: {
                width: 65,
            },
            thumbnail: {
                width: 96,
            },
            product: {
                width: 284,
            },
            zoom: {
                width: 515,
            },
        },
    };

    /**
     * The layout configuration is used to define the overall layout of the storefront.
     * The configuration includes the following aspects:
     * - breakpoint layout (AKA screen layout)
     * - Page sections slot configuration (i.e. header vs footer)
     * - page template slot configuration (i.e. landing page template vs PDP page template)
     * - deferred loading configuration
     *
     * The page slot configurations is directly related to the data in the backend. If you use the
     * Spartacus sample-data, you will have an aligned setup. However, if you introduce custom page
     * templates and/or slots, you most likely need to further adjust or replace this configuration.
     */
    var layoutConfig = {
        // deferredLoading: {
        //   strategy: DeferLoadingStrategy.DEFER,
        //   intersectionMargin: '50px',
        // },
        layoutSlots: {
            header: {
                lg: {
                    slots: [
                        'PreHeader',
                        'SiteContext',
                        'SiteLinks',
                        'SiteLogo',
                        'SearchBox',
                        'SiteLogin',
                        'MiniCart',
                        'NavigationBar',
                    ],
                },
                slots: ['PreHeader', 'SiteLogo', 'SearchBox', 'MiniCart'],
            },
            navigation: {
                lg: { slots: [] },
                slots: ['SiteLogin', 'NavigationBar', 'SiteContext', 'SiteLinks'],
            },
            footer: {
                slots: ['Footer'],
            },
            LandingPage2Template: {
                pageFold: 'Section2B',
                slots: [
                    'Section1',
                    'Section2A',
                    'Section2B',
                    'Section2C',
                    'Section3',
                    'Section4',
                    'Section5',
                ],
            },
            ContentPage1Template: {
                slots: ['Section2A', 'Section2B'],
            },
            CategoryPageTemplate: {
                pageFold: 'Section2',
                slots: ['Section1', 'Section2', 'Section3'],
            },
            ProductListPageTemplate: {
                slots: ['ProductLeftRefinements', 'ProductListSlot'],
            },
            ProductGridPageTemplate: {
                slots: ['ProductLeftRefinements', 'ProductGridSlot'],
            },
            SearchResultsListPageTemplate: {
                slots: [
                    'Section2',
                    'ProductLeftRefinements',
                    'SearchResultsListSlot',
                    'Section4',
                ],
            },
            SearchResultsGridPageTemplate: {
                slots: [
                    'Section2',
                    'ProductLeftRefinements',
                    'SearchResultsGridSlot',
                    'Section4',
                ],
            },
            ProductDetailsPageTemplate: {
                lg: {
                    pageFold: 'UpSelling',
                },
                pageFold: 'Summary',
                slots: [
                    'Summary',
                    'UpSelling',
                    'CrossSelling',
                    'Tabs',
                    'PlaceholderContentSlot',
                ],
            },
            CartPageTemplate: {
                slots: ['TopContent', 'CenterRightContentSlot', 'EmptyCartMiddleContent'],
            },
            AccountPageTemplate: {
                slots: ['BodyContent', 'SideContent'],
            },
            LoginPageTemplate: {
                slots: ['LeftContentSlot', 'RightContentSlot'],
            },
            ErrorPageTemplate: {
                slots: ['TopContent', 'MiddleContent', 'BottomContent'],
            },
            OrderConfirmationPageTemplate: {
                slots: ['BodyContent', 'SideContent'],
            },
            MultiStepCheckoutSummaryPageTemplate: {
                slots: ['TopContent', 'BodyContent', 'SideContent', 'BottomContent'],
            },
            CheckoutLoginPageTemplate: {
                slots: ['RightContentSlot'],
            },
        },
    };
    /**
     * @deprecated the b2cLayoutConfig will be dropped with version 4.0.
     *
     * With Spartacus 3.0 we started to align various layout configurations. Moreover, we move
     * into a pattern where layout configurations are shattered through various (lazy loaded) modules.
     */
    var b2cLayoutConfig = layoutConfig;

    var headerComponents = {
        HamburgerMenuComponent: {
            typeCode: 'HamburgerMenuComponent',
            flexType: 'HamburgerMenuComponent',
        },
        LoginComponent: {
            typeCode: 'LoginComponent',
            flexType: 'LoginComponent',
            uid: 'LoginComponent',
        },
    };
    var defaultPageHeaderConfig = {
        PreHeader: {
            componentIds: ['HamburgerMenuComponent'],
        },
        SiteLogin: {
            componentIds: ['LoginComponent'],
        },
    };

    function defaultCmsContentConfig() {
        return {
            cmsStructure: {
                components: Object.assign({}, headerComponents),
                slots: Object.assign({}, defaultPageHeaderConfig),
                pages: [],
            },
        };
    }

    var EventsModule = /** @class */ (function () {
        function EventsModule() {
        }
        return EventsModule;
    }());
    EventsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [CartPageEventModule, PageEventModule, ProductPageEventModule],
                },] }
    ];

    var StorefrontFoundationModule = /** @class */ (function () {
        function StorefrontFoundationModule() {
        }
        return StorefrontFoundationModule;
    }());
    StorefrontFoundationModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i1.StateModule.forRoot(),
                        i1.AuthModule.forRoot(),
                        i1.AnonymousConsentsModule.forRoot(),
                        i1.ConfigModule.forRoot(),
                        i1.ConfigInitializerModule.forRoot(),
                        i1.ConfigValidatorModule.forRoot(),
                        RoutingModule.forRoot(),
                        i1.I18nModule.forRoot(),
                        i1.CmsModule.forRoot(),
                        i1.GlobalMessageModule.forRoot(),
                        i1.ProcessModule.forRoot(),
                        i1.CartModule.forRoot(),
                        i1.CheckoutModule.forRoot(),
                        i1.UserModule.forRoot(),
                        i1.ProductModule.forRoot(),
                        ViewConfigModule.forRoot(),
                        i1.FeaturesConfigModule.forRoot('2.0'),
                        LayoutModule,
                        MediaModule.forRoot(),
                        EventsModule,
                    ],
                    exports: [LayoutModule],
                    providers: __spread(i1.provideConfigFromMetaTags()),
                },] }
    ];

    var StorefrontModule = /** @class */ (function () {
        function StorefrontModule() {
        }
        StorefrontModule.withConfig = function (config) {
            return {
                ngModule: StorefrontModule,
                providers: [i1.provideConfig(config)],
            };
        };
        return StorefrontModule;
    }());
    StorefrontModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        i4.RouterModule.forRoot([], {
                            scrollPositionRestoration: 'enabled',
                            anchorScrolling: 'enabled',
                        }),
                        i1$4.StoreModule.forRoot({}),
                        effects.EffectsModule.forRoot([]),
                        // ASM module must be imported before the `AuthModule (which is imported in `StorefrontFoundationModule`)
                        // since we might have conflicting interceptor logic. See #5461.
                        AsmModule,
                        StorefrontFoundationModule,
                        MainModule,
                        i1.SiteContextModule.forRoot(),
                        i1.SmartEditModule.forRoot(),
                        i1.PersonalizationModule.forRoot(),
                        // opt-in explicitly
                        i1.OccModule.forRoot(),
                        ProductDetailsPageModule,
                        ProductListingPageModule,
                        i1.ExternalRoutesModule.forRoot(),
                    ],
                    exports: [MainModule, StorefrontFoundationModule],
                },] }
    ];

    var B2cStorefrontModule = /** @class */ (function () {
        function B2cStorefrontModule() {
        }
        B2cStorefrontModule.withConfig = function (config) {
            return {
                ngModule: B2cStorefrontModule,
                providers: [i1.provideConfig(config)],
            };
        };
        return B2cStorefrontModule;
    }());
    B2cStorefrontModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        StorefrontModule,
                        // the cms lib module contains all components that added in the bundle
                        CmsLibModule,
                    ],
                    providers: [
                        i1.provideDefaultConfig({
                            pwa: {
                                enabled: true,
                                addToHomeScreen: true,
                            },
                        }),
                        i1.provideDefaultConfig(layoutConfig),
                        i1.provideDefaultConfig(mediaConfig),
                        i1.provideDefaultConfigFactory(defaultCmsContentConfig),
                    ],
                    exports: [StorefrontModule],
                },] }
    ];

    (function (FormUtils) {
        /**
         * Calls the native Angular method `#updateValueAndValidity` for the given from control
         * and all its descendants (in case when it's `FormGroup` or `FormArray`).
         *
         * In particular it's useful for triggering re-emission of observables
         * `valueChanges` and `statusChanges` for all descendant form controls.
         *
         * _Note: Dropping this function may be considered, when it's implemented natively
         * by Angular. See https://github.com/angular/angular/issues/6170_
         *
         * @param control form control
         * @param options additional options
         * * `emitEvent`: When true or not given (the default), the `statusChanges` and
         * `valueChanges` observables emit the latest status and value. When false,
         * it doesn't trigger observables emission.
         */
        function deepUpdateValueAndValidity(control, options) {
            if (options === void 0) { options = {}; }
            if (control instanceof forms.FormGroup || control instanceof forms.FormArray) {
                Object.values(control.controls).forEach(function (childControl) {
                    deepUpdateValueAndValidity(childControl, options);
                });
            }
            control.updateValueAndValidity({
                onlySelf: true,
                emitEvent: options.emitEvent,
            });
        }
        FormUtils.deepUpdateValueAndValidity = deepUpdateValueAndValidity;
    })(exports.FormUtils || (exports.FormUtils = {}));

    /*
     * Public API Surface of storefrontlib
     */
    /** AUGMENTABLE_TYPES_END */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AVOID_STACKED_OUTLETS = AVOID_STACKED_OUTLETS;
    exports.AbstractStoreItemComponent = AbstractStoreItemComponent;
    exports.ActiveFacetsComponent = ActiveFacetsComponent;
    exports.ActiveFacetsModule = ActiveFacetsModule;
    exports.AddToCartComponent = AddToCartComponent;
    exports.AddToCartModule = AddToCartModule;
    exports.AddToHomeScreenBannerComponent = AddToHomeScreenBannerComponent;
    exports.AddToHomeScreenBtnComponent = AddToHomeScreenBtnComponent;
    exports.AddToHomeScreenComponent = AddToHomeScreenComponent;
    exports.AddToHomeScreenService = AddToHomeScreenService;
    exports.AddToWishListComponent = AddToWishListComponent;
    exports.AddToWishListModule = AddToWishListModule;
    exports.AddedToCartDialogComponent = AddedToCartDialogComponent;
    exports.AddressBookComponent = AddressBookComponent;
    exports.AddressBookComponentService = AddressBookComponentService;
    exports.AddressBookModule = AddressBookModule;
    exports.AddressFormComponent = AddressFormComponent;
    exports.AddressFormModule = AddressFormModule;
    exports.AmendOrderActionsComponent = AmendOrderActionsComponent;
    exports.AmendOrderActionsModule = AmendOrderActionsModule;
    exports.AmendOrderItemsModule = AmendOrderItemsModule;
    exports.AnonymousConsentDialogComponent = AnonymousConsentDialogComponent;
    exports.AnonymousConsentLaunchDialogService = AnonymousConsentLaunchDialogService;
    exports.AnonymousConsentManagementBannerComponent = AnonymousConsentManagementBannerComponent;
    exports.AnonymousConsentManagementBannerModule = AnonymousConsentManagementBannerModule;
    exports.AnonymousConsentOpenDialogComponent = AnonymousConsentOpenDialogComponent;
    exports.AnonymousConsentsDialogModule = AnonymousConsentsDialogModule;
    exports.AppliedCouponsComponent = AppliedCouponsComponent;
    exports.AsmModule = AsmModule;
    exports.B2cStorefrontModule = B2cStorefrontModule;
    exports.BannerCarouselComponent = BannerCarouselComponent;
    exports.BannerCarouselModule = BannerCarouselModule;
    exports.BannerComponent = BannerComponent;
    exports.BannerModule = BannerModule;
    exports.BreadcrumbComponent = BreadcrumbComponent;
    exports.BreadcrumbModule = BreadcrumbModule;
    exports.BreadcrumbSchemaBuilder = BreadcrumbSchemaBuilder;
    exports.BreakpointService = BreakpointService;
    exports.CancelOrReturnItemsComponent = CancelOrReturnItemsComponent;
    exports.CancelOrderComponent = CancelOrderComponent;
    exports.CancelOrderConfirmationComponent = CancelOrderConfirmationComponent;
    exports.CancelOrderConfirmationModule = CancelOrderConfirmationModule;
    exports.CancelOrderModule = CancelOrderModule;
    exports.CardComponent = CardComponent;
    exports.CardModule = CardModule;
    exports.CarouselComponent = CarouselComponent;
    exports.CarouselModule = CarouselModule;
    exports.CarouselService = CarouselService;
    exports.CartComponentModule = CartComponentModule;
    exports.CartCouponComponent = CartCouponComponent;
    exports.CartCouponModule = CartCouponModule;
    exports.CartDetailsComponent = CartDetailsComponent;
    exports.CartDetailsModule = CartDetailsModule;
    exports.CartItemComponent = CartItemComponent;
    exports.CartItemListComponent = CartItemListComponent;
    exports.CartNotEmptyGuard = CartNotEmptyGuard;
    exports.CartPageEvent = CartPageEvent;
    exports.CartPageEventBuilder = CartPageEventBuilder;
    exports.CartPageEventModule = CartPageEventModule;
    exports.CartPageLayoutHandler = CartPageLayoutHandler;
    exports.CartSharedModule = CartSharedModule;
    exports.CartTotalsComponent = CartTotalsComponent;
    exports.CartTotalsModule = CartTotalsModule;
    exports.CategoryNavigationComponent = CategoryNavigationComponent;
    exports.CategoryNavigationModule = CategoryNavigationModule;
    exports.CategoryPageResultsEvent = CategoryPageResultsEvent;
    exports.CheckoutAuthGuard = CheckoutAuthGuard;
    exports.CheckoutComponentModule = CheckoutComponentModule;
    exports.CheckoutConfig = CheckoutConfig;
    exports.CheckoutConfigService = CheckoutConfigService;
    exports.CheckoutDetailsLoadedGuard = CheckoutDetailsLoadedGuard;
    exports.CheckoutDetailsService = CheckoutDetailsService;
    exports.CheckoutGuard = CheckoutGuard;
    exports.CheckoutLoginComponent = CheckoutLoginComponent;
    exports.CheckoutLoginModule = CheckoutLoginModule;
    exports.CheckoutOrchestratorComponent = CheckoutOrchestratorComponent;
    exports.CheckoutOrchestratorModule = CheckoutOrchestratorModule;
    exports.CheckoutOrderSummaryComponent = CheckoutOrderSummaryComponent;
    exports.CheckoutOrderSummaryModule = CheckoutOrderSummaryModule;
    exports.CheckoutProgressComponent = CheckoutProgressComponent;
    exports.CheckoutProgressMobileBottomComponent = CheckoutProgressMobileBottomComponent;
    exports.CheckoutProgressMobileBottomModule = CheckoutProgressMobileBottomModule;
    exports.CheckoutProgressMobileTopComponent = CheckoutProgressMobileTopComponent;
    exports.CheckoutProgressMobileTopModule = CheckoutProgressMobileTopModule;
    exports.CheckoutProgressModule = CheckoutProgressModule;
    exports.CheckoutReplenishmentFormService = CheckoutReplenishmentFormService;
    exports.CheckoutStepService = CheckoutStepService;
    exports.CloseAccountComponent = CloseAccountComponent;
    exports.CloseAccountModalComponent = CloseAccountModalComponent;
    exports.CloseAccountModule = CloseAccountModule;
    exports.CmsComponentData = CmsComponentData;
    exports.CmsComponentsService = CmsComponentsService;
    exports.CmsGuardsService = CmsGuardsService;
    exports.CmsI18nService = CmsI18nService;
    exports.CmsInjectorService = CmsInjectorService;
    exports.CmsLibModule = CmsLibModule;
    exports.CmsPageGuard = CmsPageGuard;
    exports.CmsParagraphModule = CmsParagraphModule;
    exports.CmsRouteModule = CmsRouteModule;
    exports.CmsRoutesService = CmsRoutesService;
    exports.ComponentHandler = ComponentHandler;
    exports.ComponentHandlerService = ComponentHandlerService;
    exports.ComponentWrapperDirective = ComponentWrapperDirective;
    exports.ConsentManagementComponent = ConsentManagementComponent;
    exports.ConsentManagementFormComponent = ConsentManagementFormComponent;
    exports.ConsentManagementModule = ConsentManagementModule;
    exports.ConsignmentTrackingComponent = ConsignmentTrackingComponent;
    exports.CouponCardComponent = CouponCardComponent;
    exports.CouponClaimComponent = CouponClaimComponent;
    exports.CouponDialogComponent = CouponDialogComponent;
    exports.CurrentProductService = CurrentProductService;
    exports.CustomFormValidators = CustomFormValidators;
    exports.DatePickerComponent = DatePickerComponent;
    exports.DatePickerModule = DatePickerModule;
    exports.DateTimePickerComponent = DateTimePickerComponent;
    exports.DateTimePickerModule = DateTimePickerModule;
    exports.DefaultComponentHandler = DefaultComponentHandler;
    exports.DeferLoaderService = DeferLoaderService;
    exports.DeliveryModeComponent = DeliveryModeComponent;
    exports.DeliveryModeModule = DeliveryModeModule;
    exports.DeliveryModeSetGuard = DeliveryModeSetGuard;
    exports.DirectionConfig = DirectionConfig;
    exports.DirectionModule = DirectionModule;
    exports.DirectionService = DirectionService;
    exports.ExpressCheckoutService = ExpressCheckoutService;
    exports.FacetComponent = FacetComponent;
    exports.FacetListComponent = FacetListComponent;
    exports.FacetListModule = FacetListModule;
    exports.FacetModule = FacetModule;
    exports.FacetService = FacetService;
    exports.FeatureModulesService = FeatureModulesService;
    exports.FocusDirective = FocusDirective;
    exports.FooterNavigationComponent = FooterNavigationComponent;
    exports.FooterNavigationModule = FooterNavigationModule;
    exports.ForgotPasswordComponent = ForgotPasswordComponent;
    exports.ForgotPasswordModule = ForgotPasswordModule;
    exports.FormErrorsComponent = FormErrorsComponent;
    exports.FormErrorsModule = FormErrorsModule;
    exports.GenericLinkComponent = GenericLinkComponent;
    exports.GenericLinkModule = GenericLinkModule;
    exports.GlobalMessageComponent = GlobalMessageComponent;
    exports.GlobalMessageComponentModule = GlobalMessageComponentModule;
    exports.GuestRegisterFormComponent = GuestRegisterFormComponent;
    exports.HamburgerMenuComponent = HamburgerMenuComponent;
    exports.HamburgerMenuModule = HamburgerMenuModule;
    exports.HamburgerMenuService = HamburgerMenuService;
    exports.HighlightPipe = HighlightPipe;
    exports.HomePageEvent = HomePageEvent;
    exports.IconComponent = IconComponent;
    exports.IconConfig = IconConfig;
    exports.IconLoaderService = IconLoaderService;
    exports.IconModule = IconModule;
    exports.InlineRenderStrategy = InlineRenderStrategy;
    exports.IntersectionService = IntersectionService;
    exports.ItemCounterComponent = ItemCounterComponent;
    exports.ItemCounterModule = ItemCounterModule;
    exports.JSONLD_PRODUCT_BUILDER = JSONLD_PRODUCT_BUILDER;
    exports.JsonLdBaseProductBuilder = JsonLdBaseProductBuilder;
    exports.JsonLdBuilderModule = JsonLdBuilderModule;
    exports.JsonLdDirective = JsonLdDirective;
    exports.JsonLdProductOfferBuilder = JsonLdProductOfferBuilder;
    exports.JsonLdProductReviewBuilder = JsonLdProductReviewBuilder;
    exports.JsonLdScriptFactory = JsonLdScriptFactory;
    exports.KeyboardFocusModule = KeyboardFocusModule;
    exports.KeyboardFocusService = KeyboardFocusService;
    exports.LanguageCurrencyComponent = LanguageCurrencyComponent;
    exports.LaunchDialogModule = LaunchDialogModule;
    exports.LaunchDialogService = LaunchDialogService;
    exports.LaunchRenderStrategy = LaunchRenderStrategy;
    exports.LayoutConfig = LayoutConfig;
    exports.LayoutModule = LayoutModule;
    exports.LazyComponentHandler = LazyComponentHandler;
    exports.LinkComponent = LinkComponent;
    exports.LinkModule = LinkModule;
    exports.ListNavigationModule = ListNavigationModule;
    exports.LoginComponent = LoginComponent;
    exports.LoginFormComponent = LoginFormComponent;
    exports.LoginFormModule = LoginFormModule;
    exports.LoginModule = LoginModule;
    exports.LoginRegisterModule = LoginRegisterModule;
    exports.LogoutGuard = LogoutGuard;
    exports.LogoutModule = LogoutModule;
    exports.MainModule = MainModule;
    exports.MediaComponent = MediaComponent;
    exports.MediaConfig = MediaConfig;
    exports.MediaModule = MediaModule;
    exports.MediaService = MediaService;
    exports.MiniCartComponent = MiniCartComponent;
    exports.MiniCartModule = MiniCartModule;
    exports.ModalRef = ModalRef;
    exports.ModalService = ModalService;
    exports.MyCouponsComponent = MyCouponsComponent;
    exports.MyCouponsModule = MyCouponsModule;
    exports.MyInterestsComponent = MyInterestsComponent;
    exports.MyInterestsModule = MyInterestsModule;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationModule = NavigationModule;
    exports.NavigationService = NavigationService;
    exports.NavigationUIComponent = NavigationUIComponent;
    exports.NotCheckoutAuthGuard = NotCheckoutAuthGuard;
    exports.NotificationPreferenceComponent = NotificationPreferenceComponent;
    exports.NotificationPreferenceModule = NotificationPreferenceModule;
    exports.OrderAmendService = OrderAmendService;
    exports.OrderCancellationGuard = OrderCancellationGuard;
    exports.OrderCancellationModule = OrderCancellationModule;
    exports.OrderCancellationService = OrderCancellationService;
    exports.OrderConfirmationGuard = OrderConfirmationGuard;
    exports.OrderConfirmationItemsComponent = OrderConfirmationItemsComponent;
    exports.OrderConfirmationModule = OrderConfirmationModule;
    exports.OrderConfirmationOverviewComponent = OrderConfirmationOverviewComponent;
    exports.OrderConfirmationThankYouMessageComponent = OrderConfirmationThankYouMessageComponent;
    exports.OrderConfirmationTotalsComponent = OrderConfirmationTotalsComponent;
    exports.OrderConsignedEntriesComponent = OrderConsignedEntriesComponent;
    exports.OrderDetailActionsComponent = OrderDetailActionsComponent;
    exports.OrderDetailApprovalDetailsComponent = OrderDetailApprovalDetailsComponent;
    exports.OrderDetailItemsComponent = OrderDetailItemsComponent;
    exports.OrderDetailShippingComponent = OrderDetailShippingComponent;
    exports.OrderDetailTotalsComponent = OrderDetailTotalsComponent;
    exports.OrderDetailsModule = OrderDetailsModule;
    exports.OrderDetailsService = OrderDetailsService;
    exports.OrderHistoryComponent = OrderHistoryComponent;
    exports.OrderHistoryModule = OrderHistoryModule;
    exports.OrderModule = OrderModule;
    exports.OrderOverviewComponent = OrderOverviewComponent;
    exports.OrderOverviewModule = OrderOverviewModule;
    exports.OrderReturnGuard = OrderReturnGuard;
    exports.OrderReturnModule = OrderReturnModule;
    exports.OrderReturnRequestListComponent = OrderReturnRequestListComponent;
    exports.OrderReturnService = OrderReturnService;
    exports.OrderSummaryComponent = OrderSummaryComponent;
    exports.OutletContextData = OutletContextData;
    exports.OutletDirective = OutletDirective;
    exports.OutletModule = OutletModule;
    exports.OutletRefDirective = OutletRefDirective;
    exports.OutletRefModule = OutletRefModule;
    exports.OutletRenderStrategy = OutletRenderStrategy;
    exports.OutletRendererService = OutletRendererService;
    exports.OutletService = OutletService;
    exports.PAGE_LAYOUT_HANDLER = PAGE_LAYOUT_HANDLER;
    exports.PRODUCT_DETAILS_URL_MATCHER = PRODUCT_DETAILS_URL_MATCHER;
    exports.PRODUCT_LISTING_URL_MATCHER = PRODUCT_LISTING_URL_MATCHER;
    exports.PWAModuleConfig = PWAModuleConfig;
    exports.PageComponentModule = PageComponentModule;
    exports.PageEvent = PageEvent;
    exports.PageEventBuilder = PageEventBuilder;
    exports.PageEventModule = PageEventModule;
    exports.PageLayoutComponent = PageLayoutComponent;
    exports.PageLayoutModule = PageLayoutModule;
    exports.PageLayoutService = PageLayoutService;
    exports.PageSlotComponent = PageSlotComponent;
    exports.PageSlotModule = PageSlotModule;
    exports.PaginationBuilder = PaginationBuilder;
    exports.PaginationComponent = PaginationComponent;
    exports.PaginationConfig = PaginationConfig;
    exports.PaginationModule = PaginationModule;
    exports.ParagraphComponent = ParagraphComponent;
    exports.PaymentDetailsSetGuard = PaymentDetailsSetGuard;
    exports.PaymentFormComponent = PaymentFormComponent;
    exports.PaymentFormModule = PaymentFormModule;
    exports.PaymentMethodComponent = PaymentMethodComponent;
    exports.PaymentMethodModule = PaymentMethodModule;
    exports.PaymentMethodsComponent = PaymentMethodsComponent;
    exports.PaymentMethodsModule = PaymentMethodsModule;
    exports.PlaceOrderComponent = PlaceOrderComponent;
    exports.PlaceOrderModule = PlaceOrderModule;
    exports.ProductAttributesComponent = ProductAttributesComponent;
    exports.ProductAttributesModule = ProductAttributesModule;
    exports.ProductCarouselComponent = ProductCarouselComponent;
    exports.ProductCarouselModule = ProductCarouselModule;
    exports.ProductCarouselService = ProductCarouselService;
    exports.ProductDetailsPageEvent = ProductDetailsPageEvent;
    exports.ProductDetailsPageModule = ProductDetailsPageModule;
    exports.ProductDetailsTabComponent = ProductDetailsTabComponent;
    exports.ProductDetailsTabModule = ProductDetailsTabModule;
    exports.ProductFacetNavigationComponent = ProductFacetNavigationComponent;
    exports.ProductFacetNavigationModule = ProductFacetNavigationModule;
    exports.ProductFacetService = ProductFacetService;
    exports.ProductGridItemComponent = ProductGridItemComponent;
    exports.ProductImagesComponent = ProductImagesComponent;
    exports.ProductImagesModule = ProductImagesModule;
    exports.ProductIntroComponent = ProductIntroComponent;
    exports.ProductIntroModule = ProductIntroModule;
    exports.ProductListComponent = ProductListComponent;
    exports.ProductListComponentService = ProductListComponentService;
    exports.ProductListItemComponent = ProductListItemComponent;
    exports.ProductListModule = ProductListModule;
    exports.ProductListingPageModule = ProductListingPageModule;
    exports.ProductPageEventBuilder = ProductPageEventBuilder;
    exports.ProductPageEventModule = ProductPageEventModule;
    exports.ProductReferencesComponent = ProductReferencesComponent;
    exports.ProductReferencesModule = ProductReferencesModule;
    exports.ProductReviewsComponent = ProductReviewsComponent;
    exports.ProductReviewsModule = ProductReviewsModule;
    exports.ProductSchemaBuilder = ProductSchemaBuilder;
    exports.ProductScrollComponent = ProductScrollComponent;
    exports.ProductSummaryComponent = ProductSummaryComponent;
    exports.ProductSummaryModule = ProductSummaryModule;
    exports.ProductTabsModule = ProductTabsModule;
    exports.ProductVariantGuard = ProductVariantGuard;
    exports.ProductVariantsComponent = ProductVariantsComponent;
    exports.ProductVariantsModule = ProductVariantsModule;
    exports.ProductViewComponent = ProductViewComponent;
    exports.PromotionService = PromotionService;
    exports.PromotionsComponent = PromotionsComponent;
    exports.PromotionsModule = PromotionsModule;
    exports.PwaModule = PwaModule;
    exports.QUALTRICS_EVENT_NAME = QUALTRICS_EVENT_NAME;
    exports.QualtricsComponent = QualtricsComponent;
    exports.QualtricsConfig = QualtricsConfig;
    exports.QualtricsLoaderService = QualtricsLoaderService;
    exports.QualtricsModule = QualtricsModule;
    exports.RegisterComponent = RegisterComponent;
    exports.RegisterComponentModule = RegisterComponentModule;
    exports.ReplenishmentOrderCancellationComponent = ReplenishmentOrderCancellationComponent;
    exports.ReplenishmentOrderCancellationDialogComponent = ReplenishmentOrderCancellationDialogComponent;
    exports.ReplenishmentOrderCancellationDialogModule = ReplenishmentOrderCancellationDialogModule;
    exports.ReplenishmentOrderCancellationLaunchDialogService = ReplenishmentOrderCancellationLaunchDialogService;
    exports.ReplenishmentOrderConfirmationModule = ReplenishmentOrderConfirmationModule;
    exports.ReplenishmentOrderDetailsModule = ReplenishmentOrderDetailsModule;
    exports.ReplenishmentOrderDetailsService = ReplenishmentOrderDetailsService;
    exports.ReplenishmentOrderHistoryComponent = ReplenishmentOrderHistoryComponent;
    exports.ReplenishmentOrderHistoryModule = ReplenishmentOrderHistoryModule;
    exports.ResetPasswordFormComponent = ResetPasswordFormComponent;
    exports.ResetPasswordModule = ResetPasswordModule;
    exports.ReturnOrderComponent = ReturnOrderComponent;
    exports.ReturnOrderConfirmationComponent = ReturnOrderConfirmationComponent;
    exports.ReturnOrderConfirmationModule = ReturnOrderConfirmationModule;
    exports.ReturnOrderModule = ReturnOrderModule;
    exports.ReturnRequestDetailModule = ReturnRequestDetailModule;
    exports.ReturnRequestItemsComponent = ReturnRequestItemsComponent;
    exports.ReturnRequestListModule = ReturnRequestListModule;
    exports.ReturnRequestOverviewComponent = ReturnRequestOverviewComponent;
    exports.ReturnRequestTotalsComponent = ReturnRequestTotalsComponent;
    exports.ReviewSubmitComponent = ReviewSubmitComponent;
    exports.ReviewSubmitModule = ReviewSubmitModule;
    exports.RoutingModule = RoutingModule;
    exports.RoutingRenderStrategy = RoutingRenderStrategy;
    exports.SCHEMA_BUILDER = SCHEMA_BUILDER;
    exports.SaveForLaterComponent = SaveForLaterComponent;
    exports.SaveForLaterModule = SaveForLaterModule;
    exports.ScheduleComponent = ScheduleComponent;
    exports.ScheduleReplenishmentOrderComponent = ScheduleReplenishmentOrderComponent;
    exports.ScheduleReplenishmentOrderModule = ScheduleReplenishmentOrderModule;
    exports.SearchBoxComponent = SearchBoxComponent;
    exports.SearchBoxComponentService = SearchBoxComponentService;
    exports.SearchBoxModule = SearchBoxModule;
    exports.SearchPageResultsEvent = SearchPageResultsEvent;
    exports.SelectFocusUtility = SelectFocusUtility;
    exports.SeoMetaService = SeoMetaService;
    exports.SeoModule = SeoModule;
    exports.ShippingAddressComponent = ShippingAddressComponent;
    exports.ShippingAddressModule = ShippingAddressModule;
    exports.ShippingAddressSetGuard = ShippingAddressSetGuard;
    exports.SiteContextComponentService = SiteContextComponentService;
    exports.SiteContextSelectorComponent = SiteContextSelectorComponent;
    exports.SiteContextSelectorModule = SiteContextSelectorModule;
    exports.SkipLink = SkipLink;
    exports.SkipLinkComponent = SkipLinkComponent;
    exports.SkipLinkConfig = SkipLinkConfig;
    exports.SkipLinkDirective = SkipLinkDirective;
    exports.SkipLinkModule = SkipLinkModule;
    exports.SkipLinkService = SkipLinkService;
    exports.SortingComponent = SortingComponent;
    exports.SpinnerComponent = SpinnerComponent;
    exports.SpinnerModule = SpinnerModule;
    exports.SplitViewComponent = SplitViewComponent;
    exports.SplitViewDeactivateGuard = SplitViewDeactivateGuard;
    exports.SplitViewModule = SplitViewModule;
    exports.SplitViewService = SplitViewService;
    exports.StarRatingComponent = StarRatingComponent;
    exports.StarRatingModule = StarRatingModule;
    exports.StockNotificationComponent = StockNotificationComponent;
    exports.StockNotificationDialogComponent = StockNotificationDialogComponent;
    exports.StockNotificationModule = StockNotificationModule;
    exports.StoreFinderComponent = StoreFinderComponent;
    exports.StoreFinderGridComponent = StoreFinderGridComponent;
    exports.StoreFinderHeaderComponent = StoreFinderHeaderComponent;
    exports.StoreFinderListComponent = StoreFinderListComponent;
    exports.StoreFinderListItemComponent = StoreFinderListItemComponent;
    exports.StoreFinderMapComponent = StoreFinderMapComponent;
    exports.StoreFinderModule = StoreFinderModule;
    exports.StoreFinderPaginationDetailsComponent = StoreFinderPaginationDetailsComponent;
    exports.StoreFinderSearchComponent = StoreFinderSearchComponent;
    exports.StoreFinderSearchResultComponent = StoreFinderSearchResultComponent;
    exports.StoreFinderStoreComponent = StoreFinderStoreComponent;
    exports.StoreFinderStoreDescriptionComponent = StoreFinderStoreDescriptionComponent;
    exports.StoreFinderStoresCountComponent = StoreFinderStoresCountComponent;
    exports.StorefrontComponent = StorefrontComponent;
    exports.StorefrontFoundationModule = StorefrontFoundationModule;
    exports.StorefrontModule = StorefrontModule;
    exports.StructuredDataModule = StructuredDataModule;
    exports.SuggestedAddressDialogComponent = SuggestedAddressDialogComponent;
    exports.TabParagraphContainerComponent = TabParagraphContainerComponent;
    exports.TabParagraphContainerModule = TabParagraphContainerModule;
    exports.TableComponent = TableComponent;
    exports.TableConfig = TableConfig;
    exports.TableDataCellComponent = TableDataCellComponent;
    exports.TableDataCellModule = TableDataCellModule;
    exports.TableHeaderCellComponent = TableHeaderCellComponent;
    exports.TableHeaderCellModule = TableHeaderCellModule;
    exports.TableModule = TableModule;
    exports.TableRendererService = TableRendererService;
    exports.TableService = TableService;
    exports.TrackingEventsComponent = TrackingEventsComponent;
    exports.USE_STACKED_OUTLETS = USE_STACKED_OUTLETS;
    exports.UpdateEmailComponent = UpdateEmailComponent;
    exports.UpdateEmailFormComponent = UpdateEmailFormComponent;
    exports.UpdateEmailModule = UpdateEmailModule;
    exports.UpdatePasswordComponent = UpdatePasswordComponent;
    exports.UpdatePasswordFormComponent = UpdatePasswordFormComponent;
    exports.UpdatePasswordModule = UpdatePasswordModule;
    exports.UpdateProfileComponent = UpdateProfileComponent;
    exports.UpdateProfileFormComponent = UpdateProfileFormComponent;
    exports.UpdateProfileModule = UpdateProfileModule;
    exports.UserComponentModule = UserComponentModule;
    exports.VariantColorSelectorComponent = VariantColorSelectorComponent;
    exports.VariantColorSelectorModule = VariantColorSelectorModule;
    exports.VariantSizeSelectorComponent = VariantSizeSelectorComponent;
    exports.VariantSizeSelectorModule = VariantSizeSelectorModule;
    exports.VariantStyleIconsComponent = VariantStyleIconsComponent;
    exports.VariantStyleIconsModule = VariantStyleIconsModule;
    exports.VariantStyleSelectorComponent = VariantStyleSelectorComponent;
    exports.VariantStyleSelectorModule = VariantStyleSelectorModule;
    exports.ViewComponent = ViewComponent;
    exports.ViewConfig = ViewConfig;
    exports.ViewConfigModule = ViewConfigModule;
    exports.WishListComponent = WishListComponent;
    exports.WishListItemComponent = WishListItemComponent;
    exports.WishListModule = WishListModule;
    exports.b2cLayoutConfig = b2cLayoutConfig;
    exports.checkoutPaymentSteps = checkoutPaymentSteps;
    exports.checkoutShippingSteps = checkoutShippingSteps;
    exports.controlsMustMatch = controlsMustMatch;
    exports.defaultCmsContentConfig = defaultCmsContentConfig;
    exports.defaultLayoutConfig = defaultLayoutConfig;
    exports.defaultPWAModuleConfig = defaultPWAModuleConfig;
    exports.defaultPageHeaderConfig = defaultPageHeaderConfig;
    exports.defaultPaginationConfig = defaultPaginationConfig;
    exports.defaultReplenishmentOrderCancellationLayoutConfig = defaultReplenishmentOrderCancellationLayoutConfig;
    exports.defaultScrollConfig = defaultScrollConfig;
    exports.defaultSkipLinkConfig = defaultSkipLinkConfig;
    exports.defaultTableConfig = defaultTableConfig;
    exports.fontawesomeIconConfig = fontawesomeIconConfig;
    exports.getSuffixUrlMatcher = getSuffixUrlMatcher;
    exports.headerComponents = headerComponents;
    exports.initSeoService = initSeoService;
    exports.layoutConfig = layoutConfig;
    exports.mediaConfig = mediaConfig;
    exports.sortTitles = sortTitles;
    exports.titleScores = titleScores;
    exports.ɵ0 = ɵ0$1;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;
    exports.ɵa = initPageTemplateStyle;
    exports.ɵb = pwaConfigurationFactory;
    exports.ɵba = AsmEnablerService;
    exports.ɵbb = AsmMainUiComponent;
    exports.ɵbc = AsmComponentService;
    exports.ɵbd = CSAgentLoginFormComponent;
    exports.ɵbe = CustomerSelectionComponent;
    exports.ɵbf = AsmSessionTimerComponent;
    exports.ɵbg = FormatTimerPipe;
    exports.ɵbh = CustomerEmulationComponent;
    exports.ɵbi = AsmToggleUiComponent;
    exports.ɵbj = defaultAsmLayoutConfig;
    exports.ɵbk = defaultIconConfig;
    exports.ɵbl = defaultCheckoutConfig;
    exports.ɵbm = MultiLinePipe;
    exports.ɵbn = CheckoutStepsSetGuard;
    exports.ɵbo = PaymentTypeModule;
    exports.ɵbp = PaymentTypeComponent;
    exports.ɵbq = defaultPlaceOrderSpinnerLayoutConfig;
    exports.ɵbr = CostCenterModule;
    exports.ɵbs = CostCenterComponent;
    exports.ɵbt = CheckoutAuthGuard;
    exports.ɵbu = CartNotEmptyGuard;
    exports.ɵbv = defaultQualtricsConfig;
    exports.ɵbw = CmsPageGuardService;
    exports.ɵbx = CmsRoutesImplService;
    exports.ɵby = ReturnRequestService;
    exports.ɵbz = LoginRegisterComponent;
    exports.ɵc = pwaFactory;
    exports.ɵca = PageTemplateStyleService;
    exports.ɵcb = MyCouponsComponentService;
    exports.ɵcc = addCmsRoute;
    exports.ɵcd = defaultStorefrontRoutesConfig;
    exports.ɵce = defaultRoutingConfig;
    exports.ɵcf = htmlLangProvider;
    exports.ɵcg = setHtmlLangAttribute;
    exports.ɵch = defaultDirectionConfig;
    exports.ɵci = EventsModule;
    exports.ɵcj = DatePickerFormatterService;
    exports.ɵck = DateTimePickerFormatterService;
    exports.ɵd = getStructuredDataFactory;
    exports.ɵe = FOCUS_ATTR;
    exports.ɵf = skipLinkFactory;
    exports.ɵg = initHtmlDirAttribute;
    exports.ɵh = LockFocusDirective;
    exports.ɵi = TrapFocusDirective;
    exports.ɵj = TabFocusDirective;
    exports.ɵk = AutoFocusDirective;
    exports.ɵl = EscapeFocusDirective;
    exports.ɵm = PersistFocusDirective;
    exports.ɵn = BlockFocusDirective;
    exports.ɵo = VisibleFocusDirective;
    exports.ɵp = BaseFocusDirective;
    exports.ɵq = BaseFocusService;
    exports.ɵr = PersistFocusService;
    exports.ɵs = EscapeFocusService;
    exports.ɵt = AutoFocusService;
    exports.ɵu = TabFocusService;
    exports.ɵv = TrapFocusService;
    exports.ɵw = LockFocusService;
    exports.ɵx = defaultAnonymousConsentLayoutConfig;
    exports.ɵy = AsmLoaderModule;
    exports.ɵz = asmFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=spartacus-storefront.umd.js.map
