{"version":3,"file":"table.component.d.ts","sources":["table.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EventEmitter } from '@angular/core';\nimport { TableRendererService } from './table-renderer.service';\nimport { Table, TableDataOutletContext, TableHeaderOutletContext } from './table.model';\n/**\n * The table component provides a generic DOM structure based on the `dataset` input.\n * The `Table` dataset contains a type, table structure and table data.\n *\n * The table component only supports horizontal, vertical and stacked table layout.\n *\n * The implementation is fairly \"dumb\" and only renders string based content for TH and TD elements.\n * The actual cell rendering is delegated to a (configurable) cell component. Additionally, each cell\n * is registered as an outlet, so that customizations can be done by both outlet templates\n * and components.\n *\n * The outlet references are concatenated from the table `type` and header `key`. The following\n * snippet shows an outlet generated for a table header, for the table type \"cost-center\" with\n * a header key \"name\":\n *\n * ```\n * <th>\n *   <template cxOutlet=\"table.cost-center.header.name\">\n *   </template>\n * </th>\n * ```\n *\n * Similarly, the data cells (`<td>`) are generated with the outlet template reference\n * `table.cost-center.data.name`.\n */\nexport declare class TableComponent {\n    protected rendererService: TableRendererService;\n    tableType: string;\n    horizontalLayout: boolean;\n    verticalLayout: boolean;\n    verticalStackedLayout: boolean;\n    private _dataset;\n    set dataset(value: Table);\n    get dataset(): Table;\n    /**\n     * Provides a mechanism to compare a matching value for each item.\n     *\n     * The `property` refers to the dataset.value property, and the value tot the\n     * matching property value.\n     */\n    currentItem: {\n        value: any;\n        property: string;\n    };\n    launch: EventEmitter<any>;\n    constructor(rendererService: TableRendererService);\n    init(dataset: Table): void;\n    launchItem(item: any): void;\n    /**\n     * Indicates whether the given item is the current item.\n     *\n     * The current item is driven by the `currentItem`, that holds a\n     * property and value to compare.\n     */\n    isCurrentItem(item: any): boolean;\n    /**\n     * Returns the header (th) outlet reference for the given field.\n     */\n    getHeaderOutletRef(field: string): string;\n    /**\n     * Returns the header (th) outlet context for the given field.\n     */\n    getHeaderOutletContext(field: string): TableHeaderOutletContext;\n    /**\n     * Returns the data (td) outlet reference for the given field.\n     */\n    getDataOutletRef(field: string): string;\n    /**\n     * Returns the data (td) outlet context for the given field.\n     */\n    getDataOutletContext(field: string, data: any): TableDataOutletContext;\n    trackData(_i: number, item: any): any;\n    /**\n     * Generates the table type into the UI in devMode, so that developers\n     * can easily get the notion of the table type.\n     */\n    protected addTableDebugInfo(): void;\n    /**\n     * Helper method to return the deeply nested orientation configuration.\n     */\n    private get layout();\n    /**\n     * Helper method to return the deeply nested type.\n     */\n    private get type();\n    private get options();\n}\n"]}