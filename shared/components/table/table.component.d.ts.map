{"version":3,"file":"table.component.d.ts","sources":["table.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EventEmitter } from '@angular/core';\nimport { TableRendererService } from './table-renderer.service';\nimport { TableDataOutletContext, TableHeaderOutletContext, TableStructure } from './table.model';\n/**\n * The table component provides a generic table DOM structure, with 3 layout types:\n * horizontal, vertical and _stacked vertical_ layout. The layout is driven by the\n * table structure.\n *\n * The implementation is fairly \"dumb\" and only renders string based content for TH\n * and TD elements. The actual cell rendering is delegated to a (configurable) cell\n * component. Additionally, each cell is registered as an outlet, so that customizations\n * can be done by both outlet templates and components.\n *\n * The outlet references are concatenated from the table `type` and header `key`. The\n * following snippet shows an outlet generated for a table header, for the table type\n * \"cost-center\" with a header key \"name\":\n *\n * ```\n * <th>\n *   <template cxOutlet=\"table.cost-center.header.name\">\n *   </template>\n * </th>\n * ```\n *\n * Similarly, the data cells (`<td>`) are generated with the outlet template reference\n * `table.cost-center.data.name`.\n */\nexport declare class TableComponent<T> {\n    protected rendererService: TableRendererService;\n    tableType: string;\n    horizontalLayout: boolean;\n    verticalLayout: boolean;\n    verticalStackedLayout: boolean;\n    private _structure;\n    set structure(structure: TableStructure);\n    get structure(): TableStructure;\n    data: T[];\n    /**\n     * The i18nRoot is passed into the table cell context, so that\n     * cell components can concatenate the i18n root and label.\n     */\n    i18nRoot: string;\n    /**\n     * Provides a mechanism to compare a matching value for each item.\n     *\n     * The `property` refers to the dataset.value property, and the value tot the\n     * matching property value.\n     */\n    currentItem: {\n        value: any;\n        property: string;\n    };\n    launch: EventEmitter<any>;\n    constructor(rendererService: TableRendererService);\n    init(): void;\n    launchItem(item: any): void;\n    /**\n     * Indicates whether the given item is the current item.\n     *\n     * The current item is driven by the `currentItem`, that holds a\n     * property and value to compare.\n     */\n    isCurrentItem(item: any): boolean;\n    /**\n     * Returns the header (th) outlet reference for the given field.\n     */\n    getHeaderOutletRef(field: string): string;\n    /**\n     * Returns the header (th) outlet context for the given field.\n     */\n    getHeaderOutletContext(field: string): TableHeaderOutletContext;\n    /**\n     * Returns the data (td) outlet reference for the given field.\n     */\n    getDataOutletRef(field: string): string;\n    /**\n     * Returns the data (td) outlet context for the given field.\n     */\n    getDataOutletContext(field: string, data: any): TableDataOutletContext;\n    trackData(_i: number, item: any): any;\n    /**\n     * Generates the table type into the UI in devMode, so that developers\n     * can easily get the notion of the table type.\n     */\n    protected addTableDebugInfo(): void;\n    /**\n     * Helper method to return the deeply nested orientation configuration.\n     */\n    private get layout();\n    /**\n     * Helper method to return the deeply nested type.\n     */\n    private get type();\n    private get options();\n}\n"]}